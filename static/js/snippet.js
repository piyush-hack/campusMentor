/*!
 * @license Copyright (c) 2003-2022, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */
var seteditor = function (param) {
  console.log("..");
};

var editorInt = function (param) { 
  console.log("...")
 }

!(function (t) {
  var e = {};
  function n(i) {
    if (e[i]) return e[i].exports;
    var s = (e[i] = { i: i, l: !1, exports: {} });
    return t[i].call(s.exports, s, s.exports, n), (s.l = !0), s.exports;
  }
  (n.m = t),
    (n.c = e),
    (n.d = function (t, e, i) {
      n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: i });
    }),
    (n.r = function (t) {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(t, "__esModule", { value: !0 });
    }),
    (n.t = function (t, e) {
      if ((1 & e && (t = n(t)), 8 & e)) return t;
      if (4 & e && "object" == typeof t && t && t.__esModule) return t;
      var i = Object.create(null);
      if (
        (n.r(i),
        Object.defineProperty(i, "default", { enumerable: !0, value: t }),
        2 & e && "string" != typeof t)
      )
        for (var s in t)
          n.d(
            i,
            s,
            function (e) {
              return t[e];
            }.bind(null, s)
          );
      return i;
    }),
    (n.n = function (t) {
      var e =
        t && t.__esModule
          ? function () {
              return t.default;
            }
          : function () {
              return t;
            };
      return n.d(e, "a", e), e;
    }),
    (n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }),
    (n.p = ""),
    n((n.s = 808));
})([
  function (t, e, n) {
    "use strict";
    n.r(e),
      n.d(e, "DOCUMENTATION_URL", function () {
        return i;
      }),
      n.d(e, "default", function () {
        return s;
      }),
      n.d(e, "logWarning", function () {
        return o;
      }),
      n.d(e, "logError", function () {
        return r;
      });
    const i =
      "https://ckeditor.com/docs/ckeditor5/latest/framework/guides/support/error-codes.html";
    class s extends Error {
      constructor(t, e, n) {
        super(
          (function (t, e) {
            const n = new WeakSet(),
              i = e
                ? " " +
                  JSON.stringify(e, (t, e) => {
                    if ("object" == typeof e && null !== e) {
                      if (n.has(e)) return `[object ${e.constructor.name}]`;
                      n.add(e);
                    }
                    return e;
                  })
                : "",
              s = a(t);
            return t + i + s;
          })(t, n)
        ),
          (this.name = "CKEditorError"),
          (this.context = e),
          (this.data = n);
      }
      is(t) {
        return "CKEditorError" === t;
      }
      static rethrowUnexpectedError(t, e) {
        if (t.is && t.is("CKEditorError")) throw t;
        const n = new s(t.message, e);
        throw ((n.stack = t.stack), n);
      }
    }
    function o(t, e) {
      console.warn(...c(t, e));
    }
    function r(t, e) {
      console.error(...c(t, e));
    }
    function a(t) {
      return `\nRead more: ${i}#error-${t}`;
    }
    function c(t, e) {
      const n = a(t);
      return e ? [t, e, n] : [t, n];
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "j", function () {
      return i.a;
    }),
      n.d(e, "a", function () {
        return s.a;
      }),
      n.d(e, "h", function () {
        return o;
      }),
      n.d(e, "b", function () {
        return r.a;
      }),
      n.d(e, "c", function () {
        return a.a;
      }),
      n.d(e, "e", function () {
        return c.a;
      }),
      n.d(e, "f", function () {
        return l.a;
      }),
      n.d(e, "k", function () {
        return u.a;
      }),
      n.d(e, "d", function () {
        return d.a;
      }),
      n.d(e, "g", function () {
        return h.a;
      }),
      n.d(e, "m", function () {
        return m;
      }),
      n.d(e, "i", function () {
        return g.a;
      }),
      n.d(e, "l", function () {
        return _;
      });
    var i = n(9),
      s = n(45);
    class o extends s.a {
      constructor(t) {
        super(t), (this._childCommands = []);
      }
      refresh() {}
      execute(...t) {
        const e = this._getFirstEnabledCommand();
        return null != e && e.execute(t);
      }
      registerChildCommand(t) {
        this._childCommands.push(t),
          t.on("change:isEnabled", () => this._checkEnabled()),
          this._checkEnabled();
      }
      _checkEnabled() {
        this.isEnabled = !!this._getFirstEnabledCommand();
      }
      _getFirstEnabledCommand() {
        return this._childCommands.find((t) => t.isEnabled);
      }
    }
    var r = n(186),
      a = n(141),
      c = n(271),
      l = n(272),
      u = n(280),
      d = n(269),
      h = n(281),
      f = n(0);
    function m(t) {
      const e = t.sourceElement;
      if (e) {
        if (e.ckeditorInstance)
          throw new f.default("editor-source-element-already-used", t);
        (e.ckeditorInstance = t),
          t.once("destroy", () => {
            delete e.ckeditorInstance;
          });
      }
    }
    var g = n(175),
      p = n(287),
      b = n(288),
      w = n(223),
      v = n(189);
    const _ = {
      cancel: p.a,
      caption:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>',
      check: b.a,
      cog: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>',
      eraser:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>',
      lowVision:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>',
      image:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>',
      alignBottom:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>',
      alignMiddle:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>',
      alignTop:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>',
      alignLeft:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
      alignCenter:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>',
      alignRight:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>',
      alignJustify:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
      objectLeft:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
      objectCenter:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>',
      objectRight:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
      objectFullWidth:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>',
      objectInline:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
      objectBlockLeft:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
      objectBlockRight:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
      objectSizeFull:
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>',
      objectSizeLarge:
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>',
      objectSizeSmall:
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>',
      objectSizeMedium:
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>',
      pencil:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>',
      pilcrow: w.a,
      quote:
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>',
      threeVerticalDots: v.a,
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(121);
    n.d(e, "a", function () {
      return i.a;
    }),
      n.d(e, "b", function () {
        return i.b;
      }),
      n.d(e, "c", function () {
        return i.c;
      }),
      n.d(e, "d", function () {
        return i.d;
      }),
      n.d(e, "e", function () {
        return i.e;
      }),
      n.d(e, "f", function () {
        return i.f;
      }),
      n.d(e, "g", function () {
        return i.g;
      }),
      n.d(e, "h", function () {
        return i.h;
      }),
      n.d(e, "i", function () {
        return i.i;
      }),
      n.d(e, "j", function () {
        return i.j;
      }),
      n.d(e, "k", function () {
        return i.k;
      }),
      n.d(e, "l", function () {
        return i.l;
      }),
      n.d(e, "m", function () {
        return i.m;
      }),
      n.d(e, "n", function () {
        return i.n;
      }),
      n.d(e, "o", function () {
        return i.o;
      }),
      n.d(e, "p", function () {
        return i.p;
      }),
      n.d(e, "q", function () {
        return i.q;
      }),
      n.d(e, "r", function () {
        return i.r;
      }),
      n.d(e, "s", function () {
        return i.s;
      }),
      n.d(e, "t", function () {
        return i.u;
      }),
      n.d(e, "u", function () {
        return i.v;
      }),
      n.d(e, "v", function () {
        return i.w;
      }),
      n.d(e, "w", function () {
        return i.x;
      }),
      n.d(e, "x", function () {
        return i.y;
      }),
      n.d(e, "y", function () {
        return i.z;
      }),
      n.d(e, "z", function () {
        return i.A;
      }),
      n.d(e, "A", function () {
        return i.B;
      }),
      n.d(e, "B", function () {
        return i.C;
      }),
      n.d(e, "C", function () {
        return i.D;
      }),
      n.d(e, "D", function () {
        return i.E;
      });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(5),
      s = n(71),
      o = n(0),
      r = n(37);
    class a {
      constructor(t, e = null) {
        (this.start = i.a._createAt(t)),
          (this.end = e ? i.a._createAt(e) : i.a._createAt(t)),
          (this.start.stickiness = this.isCollapsed ? "toNone" : "toNext"),
          (this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious");
      }
      *[Symbol.iterator]() {
        yield* new s.a({ boundaries: this, ignoreElementEnd: !0 });
      }
      get isCollapsed() {
        return this.start.isEqual(this.end);
      }
      get isFlat() {
        const t = this.start.getParentPath(),
          e = this.end.getParentPath();
        return "same" == Object(r.a)(t, e);
      }
      get root() {
        return this.start.root;
      }
      containsPosition(t) {
        return t.isAfter(this.start) && t.isBefore(this.end);
      }
      containsRange(t, e = !1) {
        t.isCollapsed && (e = !1);
        const n =
            this.containsPosition(t.start) ||
            (e && this.start.isEqual(t.start)),
          i = this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
        return n && i;
      }
      containsItem(t) {
        const e = i.a._createBefore(t);
        return this.containsPosition(e) || this.start.isEqual(e);
      }
      is(t) {
        return "range" === t || "model:range" === t;
      }
      isEqual(t) {
        return this.start.isEqual(t.start) && this.end.isEqual(t.end);
      }
      isIntersecting(t) {
        return this.start.isBefore(t.end) && this.end.isAfter(t.start);
      }
      getDifference(t) {
        const e = [];
        return (
          this.isIntersecting(t)
            ? (this.containsPosition(t.start) &&
                e.push(new a(this.start, t.start)),
              this.containsPosition(t.end) && e.push(new a(t.end, this.end)))
            : e.push(new a(this.start, this.end)),
          e
        );
      }
      getIntersection(t) {
        if (this.isIntersecting(t)) {
          let e = this.start,
            n = this.end;
          return (
            this.containsPosition(t.start) && (e = t.start),
            this.containsPosition(t.end) && (n = t.end),
            new a(e, n)
          );
        }
        return null;
      }
      getJoined(t, e = !1) {
        let n = this.isIntersecting(t);
        if (
          (n ||
            (n = this.start.isBefore(t.start)
              ? e
                ? this.end.isTouching(t.start)
                : this.end.isEqual(t.start)
              : e
              ? t.end.isTouching(this.start)
              : t.end.isEqual(this.start)),
          !n)
        )
          return null;
        let i = this.start,
          s = this.end;
        return (
          t.start.isBefore(i) && (i = t.start),
          t.end.isAfter(s) && (s = t.end),
          new a(i, s)
        );
      }
      getMinimalFlatRanges() {
        const t = [],
          e = this.start.getCommonPath(this.end).length,
          n = i.a._createAt(this.start);
        let s = n.parent;
        for (; n.path.length > e + 1; ) {
          const e = s.maxOffset - n.offset;
          0 !== e && t.push(new a(n, n.getShiftedBy(e))),
            (n.path = n.path.slice(0, -1)),
            n.offset++,
            (s = s.parent);
        }
        for (; n.path.length <= this.end.path.length; ) {
          const e = this.end.path[n.path.length - 1],
            i = e - n.offset;
          0 !== i && t.push(new a(n, n.getShiftedBy(i))),
            (n.offset = e),
            n.path.push(0);
        }
        return t;
      }
      getWalker(t = {}) {
        return (t.boundaries = this), new s.a(t);
      }
      *getItems(t = {}) {
        (t.boundaries = this), (t.ignoreElementEnd = !0);
        const e = new s.a(t);
        for (const t of e) yield t.item;
      }
      *getPositions(t = {}) {
        t.boundaries = this;
        const e = new s.a(t);
        yield e.position;
        for (const t of e) yield t.nextPosition;
      }
      getTransformedByOperation(t) {
        switch (t.type) {
          case "insert":
            return this._getTransformedByInsertOperation(t);
          case "move":
          case "remove":
          case "reinsert":
            return this._getTransformedByMoveOperation(t);
          case "split":
            return [this._getTransformedBySplitOperation(t)];
          case "merge":
            return [this._getTransformedByMergeOperation(t)];
        }
        return [new a(this.start, this.end)];
      }
      getTransformedByOperations(t) {
        const e = [new a(this.start, this.end)];
        for (const n of t)
          for (let t = 0; t < e.length; t++) {
            const i = e[t].getTransformedByOperation(n);
            e.splice(t, 1, ...i), (t += i.length - 1);
          }
        for (let t = 0; t < e.length; t++) {
          const n = e[t];
          for (let i = t + 1; i < e.length; i++) {
            const t = e[i];
            (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) &&
              e.splice(i, 1);
          }
        }
        return e;
      }
      getCommonAncestor() {
        return this.start.getCommonAncestor(this.end);
      }
      getContainedElement() {
        if (this.isCollapsed) return null;
        const t = this.start.nodeAfter,
          e = this.end.nodeBefore;
        return t && t.is("element") && t === e ? t : null;
      }
      toJSON() {
        return { start: this.start.toJSON(), end: this.end.toJSON() };
      }
      clone() {
        return new this.constructor(this.start, this.end);
      }
      _getTransformedByInsertOperation(t, e = !1) {
        return this._getTransformedByInsertion(t.position, t.howMany, e);
      }
      _getTransformedByMoveOperation(t, e = !1) {
        const n = t.sourcePosition,
          i = t.howMany,
          s = t.targetPosition;
        return this._getTransformedByMove(n, s, i, e);
      }
      _getTransformedBySplitOperation(t) {
        const e = this.start._getTransformedBySplitOperation(t);
        let n = this.end._getTransformedBySplitOperation(t);
        return (
          this.end.isEqual(t.insertionPosition) &&
            (n = this.end.getShiftedBy(1)),
          e.root != n.root && (n = this.end.getShiftedBy(-1)),
          new a(e, n)
        );
      }
      _getTransformedByMergeOperation(t) {
        if (
          this.start.isEqual(t.targetPosition) &&
          this.end.isEqual(t.deletionPosition)
        )
          return new a(this.start);
        let e = this.start._getTransformedByMergeOperation(t),
          n = this.end._getTransformedByMergeOperation(t);
        return (
          e.root != n.root && (n = this.end.getShiftedBy(-1)),
          e.isAfter(n)
            ? (t.sourcePosition.isBefore(t.targetPosition)
                ? ((e = i.a._createAt(n)), (e.offset = 0))
                : (t.deletionPosition.isEqual(e) || (n = t.deletionPosition),
                  (e = t.targetPosition)),
              new a(e, n))
            : new a(e, n)
        );
      }
      _getTransformedByInsertion(t, e, n = !1) {
        if (n && this.containsPosition(t))
          return [
            new a(this.start, t),
            new a(t.getShiftedBy(e), this.end._getTransformedByInsertion(t, e)),
          ];
        {
          const n = new a(this.start, this.end);
          return (
            (n.start = n.start._getTransformedByInsertion(t, e)),
            (n.end = n.end._getTransformedByInsertion(t, e)),
            [n]
          );
        }
      }
      _getTransformedByMove(t, e, n, i = !1) {
        if (this.isCollapsed) {
          const i = this.start._getTransformedByMove(t, e, n);
          return [new a(i)];
        }
        const s = a._createFromPositionAndShift(t, n),
          o = e._getTransformedByDeletion(t, n);
        if (
          this.containsPosition(e) &&
          !i &&
          (s.containsPosition(this.start) || s.containsPosition(this.end))
        ) {
          const i = this.start._getTransformedByMove(t, e, n),
            s = this.end._getTransformedByMove(t, e, n);
          return [new a(i, s)];
        }
        let r;
        const c = this.getDifference(s);
        let l = null;
        const u = this.getIntersection(s);
        if (
          (1 == c.length
            ? (l = new a(
                c[0].start._getTransformedByDeletion(t, n),
                c[0].end._getTransformedByDeletion(t, n)
              ))
            : 2 == c.length &&
              (l = new a(this.start, this.end._getTransformedByDeletion(t, n))),
          (r = l ? l._getTransformedByInsertion(o, n, null !== u || i) : []),
          u)
        ) {
          const t = new a(
            u.start._getCombined(s.start, o),
            u.end._getCombined(s.start, o)
          );
          2 == r.length ? r.splice(1, 0, t) : r.push(t);
        }
        return r;
      }
      _getTransformedByDeletion(t, e) {
        let n = this.start._getTransformedByDeletion(t, e),
          i = this.end._getTransformedByDeletion(t, e);
        return null == n && null == i
          ? null
          : (null == n && (n = t), null == i && (i = t), new a(n, i));
      }
      static _createFromPositionAndShift(t, e) {
        const n = t,
          i = t.getShiftedBy(e);
        return e > 0 ? new this(n, i) : new this(i, n);
      }
      static _createIn(t) {
        return new this(i.a._createAt(t, 0), i.a._createAt(t, t.maxOffset));
      }
      static _createOn(t) {
        return this._createFromPositionAndShift(
          i.a._createBefore(t),
          t.offsetSize
        );
      }
      static _createFromRanges(t) {
        if (0 === t.length)
          throw new o.default("range-create-from-ranges-empty-array", null);
        if (1 == t.length) return t[0].clone();
        const e = t[0];
        t.sort((t, e) => (t.start.isAfter(e.start) ? 1 : -1));
        const n = t.indexOf(e),
          s = new this(e.start, e.end);
        if (n > 0)
          for (let e = n - 1; t[e].end.isEqual(s.start); e++)
            s.start = i.a._createAt(t[e].start);
        for (let e = n + 1; e < t.length && t[e].start.isEqual(s.end); e++)
          s.end = i.a._createAt(t[e].end);
        return s;
      }
      static fromJSON(t, e) {
        return new this(i.a.fromJSON(t.start, e), i.a.fromJSON(t.end, e));
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "H", function () {
      return i.a;
    }),
      n.d(e, "N", function () {
        return s;
      }),
      n.d(e, "Q", function () {
        return o;
      }),
      n.d(e, "c", function () {
        return r.a;
      }),
      n.d(e, "e", function () {
        return a.a;
      }),
      n.d(e, "y", function () {
        return c.a;
      }),
      n.d(e, "M", function () {
        return l;
      }),
      n.d(e, "O", function () {
        return u;
      }),
      n.d(e, "f", function () {
        return b;
      }),
      n.d(e, "g", function () {
        return f;
      }),
      n.d(e, "i", function () {
        return w.a;
      }),
      n.d(e, "w", function () {
        return _;
      }),
      n.d(e, "I", function () {
        return y.c;
      }),
      n.d(e, "G", function () {
        return y.b;
      }),
      n.d(e, "F", function () {
        return y.a;
      }),
      n.d(e, "j", function () {
        return k.a;
      }),
      n.d(e, "d", function () {
        return E;
      }),
      n.d(e, "o", function () {
        return O.a;
      }),
      n.d(e, "l", function () {
        return P;
      }),
      n.d(e, "k", function () {
        return g.a;
      }),
      n.d(e, "m", function () {
        return T.a;
      }),
      n.d(e, "p", function () {
        return x;
      }),
      n.d(e, "n", function () {
        return S;
      }),
      n.d(e, "q", function () {
        return C;
      }),
      n.d(e, "r", function () {
        return I;
      }),
      n.d(e, "K", function () {
        return R;
      }),
      n.d(e, "J", function () {
        return j;
      }),
      n.d(e, "s", function () {
        return M.a;
      }),
      n.d(e, "t", function () {
        return V.a;
      }),
      n.d(e, "v", function () {
        return B;
      }),
      n.d(e, "u", function () {
        return D.a;
      }),
      n.d(e, "a", function () {
        return F.a;
      }),
      n.d(e, "h", function () {
        return z.a;
      }),
      n.d(e, "x", function () {
        return $;
      }),
      n.d(e, "C", function () {
        return U.a;
      }),
      n.d(e, "z", function () {
        return H.a;
      }),
      n.d(e, "B", function () {
        return K.a;
      }),
      n.d(e, "A", function () {
        return G.a;
      }),
      n.d(e, "L", function () {
        return J.a;
      }),
      n.d(e, "P", function () {
        return Q.a;
      }),
      n.d(e, "b", function () {
        return it;
      }),
      n.d(e, "D", function () {
        return h.a;
      }),
      n.d(e, "E", function () {
        return st.a;
      });
    var i = n(142);
    function s(t) {
      t.set("_isCssTransitionsDisabled", !1),
        (t.disableCssTransitions = () => {
          t._isCssTransitionsDisabled = !0;
        }),
        (t.enableCssTransitions = () => {
          t._isCssTransitionsDisabled = !1;
        }),
        t.extendTemplate({
          attributes: {
            class: [
              t.bindTemplate.if(
                "_isCssTransitionsDisabled",
                "ck-transitions-disabled"
              ),
            ],
          },
        });
    }
    function o({ view: t }) {
      t.listenTo(
        t.element,
        "submit",
        (e, n) => {
          n.preventDefault(), t.fire("submit");
        },
        { useCapture: !0 }
      );
    }
    var r = n(192),
      a = n(34),
      c = n(168);
    function l(t, e) {
      const n = t.t,
        i = {
          Black: n("Black"),
          "Dim grey": n("Dim grey"),
          Grey: n("Grey"),
          "Light grey": n("Light grey"),
          White: n("White"),
          Red: n("Red"),
          Orange: n("Orange"),
          Yellow: n("Yellow"),
          "Light green": n("Light green"),
          Green: n("Green"),
          Aquamarine: n("Aquamarine"),
          Turquoise: n("Turquoise"),
          "Light blue": n("Light blue"),
          Blue: n("Blue"),
          Purple: n("Purple"),
        };
      return e.map((t) => {
        const e = i[t.label];
        return e && e != t.label && (t.label = e), t;
      });
    }
    function u(t) {
      return t.map(d).filter((t) => !!t);
    }
    function d(t) {
      return "string" == typeof t
        ? {
            model: t,
            label: t,
            hasBorder: !1,
            view: { name: "span", styles: { color: t } },
          }
        : {
            model: t.color,
            label: t.label || t.color,
            hasBorder: void 0 !== t.hasBorder && t.hasBorder,
            view: { name: "span", styles: { color: "" + t.color } },
          };
    }
    var h = n(8);
    class f extends a.a {
      constructor(t) {
        super(t);
        const e = this.bindTemplate;
        this.set("color"),
          this.set("hasBorder"),
          (this.icon =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>'),
          this.extendTemplate({
            attributes: {
              style: { backgroundColor: e.to("color") },
              class: [
                "ck",
                "ck-color-grid__tile",
                e.if("hasBorder", "ck-color-table__color-tile_bordered"),
              ],
            },
          });
      }
      render() {
        super.render(), (this.iconView.fillColor = "hsl(0, 0%, 100%)");
      }
    }
    var m = n(52),
      g = n(115),
      p = n(69);
    n(334);
    class b extends h.a {
      constructor(t, e) {
        super(t);
        const n = (e && e.colorDefinitions) || [],
          i = {};
        e &&
          e.columns &&
          (i.gridTemplateColumns = `repeat( ${e.columns}, 1fr)`),
          this.set("selectedColor"),
          (this.items = this.createCollection()),
          (this.focusTracker = new m.a()),
          (this.keystrokes = new p.a()),
          (this._focusCycler = new g.a({
            focusables: this.items,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "arrowleft", focusNext: "arrowright" },
          })),
          this.items.on("add", (t, e) => {
            e.isOn = e.color === this.selectedColor;
          }),
          n.forEach((t) => {
            const e = new f();
            e.set({
              color: t.color,
              label: t.label,
              tooltip: !0,
              hasBorder: t.options.hasBorder,
            }),
              e.on("execute", () => {
                this.fire("execute", {
                  value: t.color,
                  hasBorder: t.options.hasBorder,
                  label: t.label,
                });
              }),
              this.items.add(e);
          }),
          this.setTemplate({
            tag: "div",
            children: this.items,
            attributes: { class: ["ck", "ck-color-grid"], style: i },
          }),
          this.on("change:selectedColor", (t, e, n) => {
            for (const t of this.items) t.isOn = t.color === n;
          });
      }
      focus() {
        this.items.length && this.items.first.focus();
      }
      focusLast() {
        this.items.length && this.items.last.focus();
      }
      render() {
        super.render();
        for (const t of this.items) this.focusTracker.add(t.element);
        this.items.on("add", (t, e) => {
          this.focusTracker.add(e.element);
        }),
          this.items.on("remove", (t, e) => {
            this.focusTracker.remove(e.element);
          }),
          this.keystrokes.listenTo(this.element);
      }
      destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
      }
    }
    var w = n(169),
      v = n(224);
    n(335);
    class _ extends h.a {
      constructor(t) {
        super(t);
        const e = this.bindTemplate;
        this.set("class"),
          this.set("icon"),
          this.set("isEnabled", !0),
          this.set("isOn", !1),
          this.set("isToggleable", !1),
          this.set("isVisible", !0),
          this.set("keystroke"),
          this.set("label"),
          this.set("tabindex", -1),
          this.set("tooltip"),
          this.set("tooltipPosition", "s"),
          this.set("type", "button"),
          this.set("withText", !1),
          (this.children = this.createCollection()),
          (this.actionView = this._createActionView()),
          (this.arrowView = this._createArrowView()),
          (this.keystrokes = new p.a()),
          (this.focusTracker = new m.a()),
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-splitbutton",
                e.to("class"),
                e.if("isVisible", "ck-hidden", (t) => !t),
                this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open"),
              ],
            },
            children: this.children,
          });
      }
      render() {
        super.render(),
          this.children.add(this.actionView),
          this.children.add(this.arrowView),
          this.focusTracker.add(this.actionView.element),
          this.focusTracker.add(this.arrowView.element),
          this.keystrokes.listenTo(this.element),
          this.keystrokes.set("arrowright", (t, e) => {
            this.focusTracker.focusedElement === this.actionView.element &&
              (this.arrowView.focus(), e());
          }),
          this.keystrokes.set("arrowleft", (t, e) => {
            this.focusTracker.focusedElement === this.arrowView.element &&
              (this.actionView.focus(), e());
          });
      }
      destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
      }
      focus() {
        this.actionView.focus();
      }
      _createActionView() {
        const t = new a.a();
        return (
          t
            .bind(
              "icon",
              "isEnabled",
              "isOn",
              "isToggleable",
              "keystroke",
              "label",
              "tabindex",
              "tooltip",
              "tooltipPosition",
              "type",
              "withText"
            )
            .to(this),
          t.extendTemplate({ attributes: { class: "ck-splitbutton__action" } }),
          t.delegate("execute").to(this),
          t
        );
      }
      _createArrowView() {
        const t = new a.a(),
          e = t.bindTemplate;
        return (
          (t.icon = v.a),
          t.extendTemplate({
            attributes: {
              class: "ck-splitbutton__arrow",
              "aria-haspopup": !0,
              "aria-expanded": e.to("isOn", (t) => String(t)),
            },
          }),
          t.bind("isEnabled").to(this),
          t.delegate("execute").to(this, "open"),
          t
        );
      }
    }
    var y = n(132),
      k = n(182),
      A = n(44);
    n(342);
    class C extends h.a {
      constructor(t) {
        super(t),
          this.set("text"),
          this.set("for"),
          (this.id = "ck-editor__label_" + Object(A.a)());
        const e = this.bindTemplate;
        this.setTemplate({
          tag: "label",
          attributes: {
            class: ["ck", "ck-label"],
            id: this.id,
            for: e.to("for"),
          },
          children: [{ text: e.to("text") }],
        });
      }
    }
    class E extends k.a {
      constructor(t) {
        super(t),
          (this.top = this.createCollection()),
          (this.main = this.createCollection()),
          (this._voiceLabelView = this._createVoiceLabel()),
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"],
              role: "application",
              dir: t.uiLanguageDirection,
              lang: t.uiLanguage,
              "aria-labelledby": this._voiceLabelView.id,
            },
            children: [
              this._voiceLabelView,
              {
                tag: "div",
                attributes: {
                  class: ["ck", "ck-editor__top", "ck-reset_all"],
                  role: "presentation",
                },
                children: this.top,
              },
              {
                tag: "div",
                attributes: {
                  class: ["ck", "ck-editor__main"],
                  role: "presentation",
                },
                children: this.main,
              },
            ],
          });
      }
      _createVoiceLabel() {
        const t = this.t,
          e = new C();
        return (
          (e.text = t("Rich Text Editor")),
          e.extendTemplate({ attributes: { class: "ck-voice-label" } }),
          e
        );
      }
    }
    var O = n(273);
    n(343);
    class P extends h.a {
      constructor(t, e = {}) {
        super(t);
        const n = this.bindTemplate;
        this.set("label", e.label || ""),
          this.set("class", e.class || null),
          (this.children = this.createCollection()),
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-form__header", n.to("class")] },
            children: this.children,
          });
        const i = new h.a(t);
        i.setTemplate({
          tag: "span",
          attributes: { class: ["ck", "ck-form__header__label"] },
          children: [{ text: n.to("label") }],
        }),
          this.children.add(i);
      }
    }
    var T = n(114);
    n(344);
    class x extends h.a {
      constructor(t) {
        super(t),
          this.set("value"),
          this.set("id"),
          this.set("placeholder"),
          this.set("isReadOnly", !1),
          this.set("hasError", !1),
          this.set("ariaDescribedById"),
          (this.focusTracker = new m.a()),
          this.bind("isFocused").to(this.focusTracker),
          this.set("isEmpty", !0);
        const e = this.bindTemplate;
        this.setTemplate({
          tag: "input",
          attributes: {
            type: "text",
            class: [
              "ck",
              "ck-input",
              "ck-input-text",
              e.if("isFocused", "ck-input_focused"),
              e.if("isEmpty", "ck-input-text_empty"),
              e.if("hasError", "ck-error"),
            ],
            id: e.to("id"),
            placeholder: e.to("placeholder"),
            readonly: e.to("isReadOnly"),
            "aria-invalid": e.if("hasError", !0),
            "aria-describedby": e.to("ariaDescribedById"),
          },
          on: {
            input: e.to((...t) => {
              this.fire("input", ...t), this._updateIsEmpty();
            }),
            change: e.to(this._updateIsEmpty.bind(this)),
          },
        });
      }
      render() {
        super.render(),
          this.focusTracker.add(this.element),
          this._setDomElementValue(this.value),
          this._updateIsEmpty(),
          this.on("change:value", (t, e, n) => {
            this._setDomElementValue(n), this._updateIsEmpty();
          });
      }
      destroy() {
        super.destroy(), this.focusTracker.destroy();
      }
      select() {
        this.element.select();
      }
      focus() {
        this.element.focus();
      }
      _updateIsEmpty() {
        this.isEmpty = !this.element.value;
      }
      _setDomElementValue(t) {
        this.element.value = t || 0 === t ? t : "";
      }
    }
    class S extends h.a {
      constructor(t) {
        super(t);
        const e = this.bindTemplate;
        this.setTemplate({
          tag: "iframe",
          attributes: {
            class: ["ck", "ck-reset_all"],
            sandbox: "allow-same-origin allow-scripts",
          },
          on: { load: e.to("loaded") },
        });
      }
      render() {
        return new Promise((t) => {
          this.on("loaded", t), super.render();
        });
      }
    }
    n(345);
    class I extends h.a {
      constructor(t, e) {
        super(t);
        const n = "ck-labeled-field-view-" + Object(A.a)(),
          i = "ck-labeled-field-view-status-" + Object(A.a)();
        (this.fieldView = e(this, n, i)),
          this.set("label"),
          this.set("isEnabled", !0),
          this.set("isEmpty", !0),
          this.set("isFocused", !1),
          this.set("errorText", null),
          this.set("infoText", null),
          this.set("class"),
          this.set("placeholder"),
          (this.labelView = this._createLabelView(n)),
          (this.statusView = this._createStatusView(i)),
          this.bind("_statusText").to(
            this,
            "errorText",
            this,
            "infoText",
            (t, e) => t || e
          );
        const s = this.bindTemplate;
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-labeled-field-view",
              s.to("class"),
              s.if("isEnabled", "ck-disabled", (t) => !t),
              s.if("isEmpty", "ck-labeled-field-view_empty"),
              s.if("isFocused", "ck-labeled-field-view_focused"),
              s.if("placeholder", "ck-labeled-field-view_placeholder"),
              s.if("errorText", "ck-error"),
            ],
          },
          children: [
            {
              tag: "div",
              attributes: {
                class: ["ck", "ck-labeled-field-view__input-wrapper"],
              },
              children: [this.fieldView, this.labelView],
            },
            this.statusView,
          ],
        });
      }
      _createLabelView(t) {
        const e = new C(this.locale);
        return (e.for = t), e.bind("text").to(this, "label"), e;
      }
      _createStatusView(t) {
        const e = new h.a(this.locale),
          n = this.bindTemplate;
        return (
          e.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-labeled-field-view__status",
                n.if("errorText", "ck-labeled-field-view__status_error"),
                n.if("_statusText", "ck-hidden", (t) => !t),
              ],
              id: t,
              role: n.if("errorText", "alert"),
            },
            children: [{ text: n.to("_statusText") }],
          }),
          e
        );
      }
      focus() {
        this.fieldView.focus();
      }
    }
    function R(t, e, n) {
      const i = new x(t.locale);
      return (
        i.set({ id: e, ariaDescribedById: n }),
        i.bind("isReadOnly").to(t, "isEnabled", (t) => !t),
        i.bind("hasError").to(t, "errorText", (t) => !!t),
        i.on("input", () => {
          t.errorText = null;
        }),
        t.bind("isEmpty", "isFocused", "placeholder").to(i),
        i
      );
    }
    function j(t, e, n) {
      const i = Object(y.c)(t.locale);
      return (
        i.set({ id: e, ariaDescribedById: n }), i.bind("isEnabled").to(t), i
      );
    }
    var M = n(195),
      V = n(194),
      N = n(141);
    class B extends N.a {
      static get pluginName() {
        return "Notification";
      }
      init() {
        this.on(
          "show:warning",
          (t, e) => {
            window.alert(e.message);
          },
          { priority: "lowest" }
        );
      }
      showSuccess(t, e = {}) {
        this._showNotification({
          message: t,
          type: "success",
          namespace: e.namespace,
          title: e.title,
        });
      }
      showInfo(t, e = {}) {
        this._showNotification({
          message: t,
          type: "info",
          namespace: e.namespace,
          title: e.title,
        });
      }
      showWarning(t, e = {}) {
        this._showNotification({
          message: t,
          type: "warning",
          namespace: e.namespace,
          title: e.title,
        });
      }
      _showNotification(t) {
        const e = "show:" + t.type + (t.namespace ? ":" + t.namespace : "");
        this.fire(e, {
          message: t.message,
          type: t.type,
          title: t.title || "",
        });
      }
    }
    var D = n(260),
      F = n(82),
      z = n(139),
      L = n(27),
      H = n(61),
      W = n(68);
    n(349);
    const q = Object(W.a)("px");
    class $ extends h.a {
      constructor(t) {
        super(t);
        const e = this.bindTemplate;
        this.set("isActive", !1),
          this.set("isSticky", !1),
          this.set("limiterElement", null),
          this.set("limiterBottomOffset", 50),
          this.set("viewportTopOffset", 0),
          this.set("_marginLeft", null),
          this.set("_isStickyToTheLimiter", !1),
          this.set("_hasViewportTopOffset", !1),
          (this.content = this.createCollection()),
          (this._contentPanelPlaceholder = new H.a({
            tag: "div",
            attributes: {
              class: ["ck", "ck-sticky-panel__placeholder"],
              style: {
                display: e.to("isSticky", (t) => (t ? "block" : "none")),
                height: e.to("isSticky", (t) =>
                  t ? q(this._panelRect.height) : null
                ),
              },
            },
          }).render()),
          (this._contentPanel = new H.a({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-sticky-panel__content",
                e.if("isSticky", "ck-sticky-panel__content_sticky"),
                e.if(
                  "_isStickyToTheLimiter",
                  "ck-sticky-panel__content_sticky_bottom-limit"
                ),
              ],
              style: {
                width: e.to("isSticky", (t) =>
                  t
                    ? q(
                        this._contentPanelPlaceholder.getBoundingClientRect()
                          .width
                      )
                    : null
                ),
                top: e.to("_hasViewportTopOffset", (t) =>
                  t ? q(this.viewportTopOffset) : null
                ),
                bottom: e.to("_isStickyToTheLimiter", (t) =>
                  t ? q(this.limiterBottomOffset) : null
                ),
                marginLeft: e.to("_marginLeft"),
              },
            },
            children: this.content,
          }).render()),
          this.setTemplate({
            tag: "div",
            // attributes: { class: ["ck", "ck-sticky-panel"] },
            children: [this._contentPanelPlaceholder, this._contentPanel],
          });
      }
      render() {
        super.render(),
          this._checkIfShouldBeSticky(),
          this.listenTo(L.a.window, "scroll", () => {
            this._checkIfShouldBeSticky();
          }),
          this.listenTo(this, "change:isActive", () => {
            this._checkIfShouldBeSticky();
          });
      }
      _checkIfShouldBeSticky() {
        const t = (this._panelRect =
          this._contentPanel.getBoundingClientRect());
        let e;
        this.limiterElement
          ? ((e = this._limiterRect =
              this.limiterElement.getBoundingClientRect()),
            (this.isSticky =
              this.isActive &&
              e.top < this.viewportTopOffset &&
              this._panelRect.height + this.limiterBottomOffset < e.height))
          : (this.isSticky = !1),
          this.isSticky
            ? ((this._isStickyToTheLimiter =
                e.bottom <
                t.height + this.limiterBottomOffset + this.viewportTopOffset),
              (this._hasViewportTopOffset =
                !this._isStickyToTheLimiter && !!this.viewportTopOffset),
              (this._marginLeft = this._isStickyToTheLimiter
                ? null
                : q(-L.a.window.scrollX)))
            : ((this._isStickyToTheLimiter = !1),
              (this._hasViewportTopOffset = !1),
              (this._marginLeft = null));
      }
    }
    var U = n(193),
      K = n(97),
      G = n(170),
      J = n(282),
      Q = n(116),
      Y = n(9),
      X = n(18),
      Z = n(261),
      tt = n(112),
      et = n(121);
    const nt = Object(W.a)("px");
    class it extends Y.a {
      static get pluginName() {
        return "BalloonToolbar";
      }
      static get requires() {
        return [z.a];
      }
      constructor(t) {
        super(t),
          (this._balloonConfig = Object(Q.a)(t.config.get("balloonToolbar"))),
          (this.toolbarView = this._createToolbarView()),
          (this.focusTracker = new m.a()),
          t.ui.once("ready", () => {
            this.focusTracker.add(t.ui.getEditableElement()),
              this.focusTracker.add(this.toolbarView.element);
          }),
          (this._resizeObserver = null),
          (this._balloon = t.plugins.get(z.a)),
          (this._fireSelectionChangeDebounced = Object(Z.a)(
            () => this.fire("_selectionChangeDebounced"),
            200
          )),
          this.decorate("show");
      }
      init() {
        const t = this.editor,
          e = t.model.document.selection;
        this.listenTo(this.focusTracker, "change:isFocused", (t, e, n) => {
          const i = this._balloon.visibleView === this.toolbarView;
          !n && i ? this.hide() : n && this.show();
        }),
          this.listenTo(e, "change:range", (t, n) => {
            (n.directChange || e.isCollapsed) && this.hide(),
              this._fireSelectionChangeDebounced();
          }),
          this.listenTo(this, "_selectionChangeDebounced", () => {
            this.editor.editing.view.document.isFocused && this.show();
          }),
          this._balloonConfig.shouldNotGroupWhenFull ||
            this.listenTo(t, "ready", () => {
              const e = t.ui.view.editable.element;
              this._resizeObserver = new tt.a(e, () => {
                this.toolbarView.maxWidth = nt(0.9 * new X.a(e).width);
              });
            }),
          this.listenTo(this.toolbarView, "groupedItemsUpdate", () => {
            this._updatePosition();
          });
      }
      afterInit() {
        const t = this.editor.ui.componentFactory;
        this.toolbarView.fillFromConfig(this._balloonConfig, t);
      }
      _createToolbarView() {
        const t = !this._balloonConfig.shouldNotGroupWhenFull,
          e = new K.a(this.editor.locale, {
            shouldGroupWhenFull: t,
            isFloating: !0,
          });
        return e.render(), e;
      }
      show() {
        const t = this.editor,
          e = t.model.document.selection,
          n = t.model.schema;
        this._balloon.hasView(this.toolbarView) ||
          e.isCollapsed ||
          (function (t, e) {
            if (1 === t.rangeCount) return !1;
            return [...t.getRanges()].every((t) => {
              const n = t.getContainedElement();
              return n && e.isSelectable(n);
            });
          })(e, n) ||
          Array.from(this.toolbarView.items).every(
            (t) => void 0 !== t.isEnabled && !t.isEnabled
          ) ||
          (this.listenTo(this.editor.ui, "update", () => {
            this._updatePosition();
          }),
          this._balloon.add({
            view: this.toolbarView,
            position: this._getBalloonPositionData(),
            balloonClassName: "ck-toolbar-container",
          }));
      }
      hide() {
        this._balloon.hasView(this.toolbarView) &&
          (this.stopListening(this.editor.ui, "update"),
          this._balloon.remove(this.toolbarView));
      }
      _getBalloonPositionData() {
        const t = this.editor.editing.view,
          e = t.document,
          n = e.selection,
          i = e.selection.isBackward;
        return {
          target: () => {
            const e = i ? n.getFirstRange() : n.getLastRange(),
              s = X.a.getDomRangeRects(t.domConverter.viewRangeToDom(e));
            return i
              ? s[0]
              : (s.length > 1 && 0 === s[s.length - 1].width && s.pop(),
                s[s.length - 1]);
          },
          positions: this._getBalloonPositions(i),
        };
      }
      _updatePosition() {
        this._balloon.updatePosition(this._getBalloonPositionData());
      }
      destroy() {
        super.destroy(),
          this.stopListening(),
          this._fireSelectionChangeDebounced.cancel(),
          this.toolbarView.destroy(),
          this.focusTracker.destroy(),
          this._resizeObserver && this._resizeObserver.destroy();
      }
      _getBalloonPositions(t) {
        const e =
          et.m.isSafari && et.m.isiOS
            ? Object(F.b)({
                verticalOffset: Math.max(
                  F.a.arrowVerticalOffset,
                  Math.round(20 / et.s.window.visualViewport.scale)
                ),
              })
            : F.a.defaultPositions;
        return t
          ? [
              e.northWestArrowSouth,
              e.northWestArrowSouthWest,
              e.northWestArrowSouthEast,
              e.northWestArrowSouthMiddleEast,
              e.northWestArrowSouthMiddleWest,
              e.southWestArrowNorth,
              e.southWestArrowNorthWest,
              e.southWestArrowNorthEast,
              e.southWestArrowNorthMiddleWest,
              e.southWestArrowNorthMiddleEast,
            ]
          : [
              e.southEastArrowNorth,
              e.southEastArrowNorthEast,
              e.southEastArrowNorthWest,
              e.southEastArrowNorthMiddleEast,
              e.southEastArrowNorthMiddleWest,
              e.northEastArrowSouth,
              e.northEastArrowSouthEast,
              e.northEastArrowSouthWest,
              e.northEastArrowSouthMiddleEast,
              e.northEastArrowSouthMiddleWest,
            ];
      }
    }
    n(264);
    var st = n(113);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    }),
      n.d(e, "d", function () {
        return a;
      }),
      n.d(e, "b", function () {
        return c;
      }),
      n.d(e, "c", function () {
        return l;
      });
    var i = n(71),
      s = n(37),
      o = n(0);
    n(133);
    class r {
      constructor(t, e, n = "toNone") {
        if (!t.is("element") && !t.is("documentFragment"))
          throw new o.default("model-position-root-invalid", t);
        if (!(e instanceof Array) || 0 === e.length)
          throw new o.default("model-position-path-incorrect-format", t, {
            path: e,
          });
        t.is("rootElement")
          ? (e = e.slice())
          : ((e = [...t.getPath(), ...e]), (t = t.root)),
          (this.root = t),
          (this.path = e),
          (this.stickiness = n);
      }
      get offset() {
        return this.path[this.path.length - 1];
      }
      set offset(t) {
        this.path[this.path.length - 1] = t;
      }
      get parent() {
        let t = this.root;
        for (let e = 0; e < this.path.length - 1; e++)
          if (((t = t.getChild(t.offsetToIndex(this.path[e]))), !t))
            throw new o.default("model-position-path-incorrect", this, {
              position: this,
            });
        if (t.is("$text"))
          throw new o.default("model-position-path-incorrect", this, {
            position: this,
          });
        return t;
      }
      get index() {
        return this.parent.offsetToIndex(this.offset);
      }
      get textNode() {
        return a(this, this.parent);
      }
      get nodeAfter() {
        const t = this.parent;
        return c(this, t, a(this, t));
      }
      get nodeBefore() {
        const t = this.parent;
        return l(this, t, a(this, t));
      }
      get isAtStart() {
        return 0 === this.offset;
      }
      get isAtEnd() {
        return this.offset == this.parent.maxOffset;
      }
      compareWith(t) {
        if (this.root != t.root) return "different";
        const e = Object(s.a)(this.path, t.path);
        switch (e) {
          case "same":
            return "same";
          case "prefix":
            return "before";
          case "extension":
            return "after";
          default:
            return this.path[e] < t.path[e] ? "before" : "after";
        }
      }
      getLastMatchingPosition(t, e = {}) {
        e.startPosition = this;
        const n = new i.a(e);
        return n.skip(t), n.position;
      }
      getParentPath() {
        return this.path.slice(0, -1);
      }
      getAncestors() {
        const t = this.parent;
        return t.is("documentFragment")
          ? [t]
          : t.getAncestors({ includeSelf: !0 });
      }
      findAncestor(t) {
        const e = this.parent;
        return e.is("element") ? e.findAncestor(t, { includeSelf: !0 }) : null;
      }
      getCommonPath(t) {
        if (this.root != t.root) return [];
        const e = Object(s.a)(this.path, t.path),
          n =
            "string" == typeof e
              ? Math.min(this.path.length, t.path.length)
              : e;
        return this.path.slice(0, n);
      }
      getCommonAncestor(t) {
        const e = this.getAncestors(),
          n = t.getAncestors();
        let i = 0;
        for (; e[i] == n[i] && e[i]; ) i++;
        return 0 === i ? null : e[i - 1];
      }
      getShiftedBy(t) {
        const e = this.clone(),
          n = e.offset + t;
        return (e.offset = n < 0 ? 0 : n), e;
      }
      isAfter(t) {
        return "after" == this.compareWith(t);
      }
      isBefore(t) {
        return "before" == this.compareWith(t);
      }
      isEqual(t) {
        return "same" == this.compareWith(t);
      }
      isTouching(t) {
        let e = null,
          n = null;
        switch (this.compareWith(t)) {
          case "same":
            return !0;
          case "before":
            (e = r._createAt(this)), (n = r._createAt(t));
            break;
          case "after":
            (e = r._createAt(t)), (n = r._createAt(this));
            break;
          default:
            return !1;
        }
        let i = e.parent;
        for (; e.path.length + n.path.length; ) {
          if (e.isEqual(n)) return !0;
          if (e.path.length > n.path.length) {
            if (e.offset !== i.maxOffset) return !1;
            (e.path = e.path.slice(0, -1)), (i = i.parent), e.offset++;
          } else {
            if (0 !== n.offset) return !1;
            n.path = n.path.slice(0, -1);
          }
        }
      }
      is(t) {
        return "position" === t || "model:position" === t;
      }
      hasSameParentAs(t) {
        if (this.root !== t.root) return !1;
        const e = this.getParentPath(),
          n = t.getParentPath();
        return "same" == Object(s.a)(e, n);
      }
      getTransformedByOperation(t) {
        let e;
        switch (t.type) {
          case "insert":
            e = this._getTransformedByInsertOperation(t);
            break;
          case "move":
          case "remove":
          case "reinsert":
            e = this._getTransformedByMoveOperation(t);
            break;
          case "split":
            e = this._getTransformedBySplitOperation(t);
            break;
          case "merge":
            e = this._getTransformedByMergeOperation(t);
            break;
          default:
            e = r._createAt(this);
        }
        return e;
      }
      _getTransformedByInsertOperation(t) {
        return this._getTransformedByInsertion(t.position, t.howMany);
      }
      _getTransformedByMoveOperation(t) {
        return this._getTransformedByMove(
          t.sourcePosition,
          t.targetPosition,
          t.howMany
        );
      }
      _getTransformedBySplitOperation(t) {
        const e = t.movedRange;
        return e.containsPosition(this) ||
          (e.start.isEqual(this) && "toNext" == this.stickiness)
          ? this._getCombined(t.splitPosition, t.moveTargetPosition)
          : t.graveyardPosition
          ? this._getTransformedByMove(
              t.graveyardPosition,
              t.insertionPosition,
              1
            )
          : this._getTransformedByInsertion(t.insertionPosition, 1);
      }
      _getTransformedByMergeOperation(t) {
        const e = t.movedRange;
        let n;
        return (
          e.containsPosition(this) || e.start.isEqual(this)
            ? ((n = this._getCombined(t.sourcePosition, t.targetPosition)),
              t.sourcePosition.isBefore(t.targetPosition) &&
                (n = n._getTransformedByDeletion(t.deletionPosition, 1)))
            : (n = this.isEqual(t.deletionPosition)
                ? r._createAt(t.deletionPosition)
                : this._getTransformedByMove(
                    t.deletionPosition,
                    t.graveyardPosition,
                    1
                  )),
          n
        );
      }
      _getTransformedByDeletion(t, e) {
        const n = r._createAt(this);
        if (this.root != t.root) return n;
        if ("same" == Object(s.a)(t.getParentPath(), this.getParentPath())) {
          if (t.offset < this.offset) {
            if (t.offset + e > this.offset) return null;
            n.offset -= e;
          }
        } else if (
          "prefix" == Object(s.a)(t.getParentPath(), this.getParentPath())
        ) {
          const i = t.path.length - 1;
          if (t.offset <= this.path[i]) {
            if (t.offset + e > this.path[i]) return null;
            n.path[i] -= e;
          }
        }
        return n;
      }
      _getTransformedByInsertion(t, e) {
        const n = r._createAt(this);
        if (this.root != t.root) return n;
        if ("same" == Object(s.a)(t.getParentPath(), this.getParentPath()))
          (t.offset < this.offset ||
            (t.offset == this.offset && "toPrevious" != this.stickiness)) &&
            (n.offset += e);
        else if (
          "prefix" == Object(s.a)(t.getParentPath(), this.getParentPath())
        ) {
          const i = t.path.length - 1;
          t.offset <= this.path[i] && (n.path[i] += e);
        }
        return n;
      }
      _getTransformedByMove(t, e, n) {
        if (((e = e._getTransformedByDeletion(t, n)), t.isEqual(e)))
          return r._createAt(this);
        const i = this._getTransformedByDeletion(t, n);
        return null === i ||
          (t.isEqual(this) && "toNext" == this.stickiness) ||
          (t.getShiftedBy(n).isEqual(this) && "toPrevious" == this.stickiness)
          ? this._getCombined(t, e)
          : i._getTransformedByInsertion(e, n);
      }
      _getCombined(t, e) {
        const n = t.path.length - 1,
          i = r._createAt(e);
        return (
          (i.stickiness = this.stickiness),
          (i.offset = i.offset + this.path[n] - t.offset),
          (i.path = [...i.path, ...this.path.slice(n + 1)]),
          i
        );
      }
      toJSON() {
        return {
          root: this.root.toJSON(),
          path: Array.from(this.path),
          stickiness: this.stickiness,
        };
      }
      clone() {
        return new this.constructor(this.root, this.path, this.stickiness);
      }
      static _createAt(t, e, n = "toNone") {
        if (t instanceof r) return new r(t.root, t.path, t.stickiness);
        {
          const i = t;
          if ("end" == e) e = i.maxOffset;
          else {
            if ("before" == e) return this._createBefore(i, n);
            if ("after" == e) return this._createAfter(i, n);
            if (0 !== e && !e)
              throw new o.default("model-createpositionat-offset-required", [
                this,
                t,
              ]);
          }
          if (!i.is("element") && !i.is("documentFragment"))
            throw new o.default("model-position-parent-incorrect", [this, t]);
          const s = i.getPath();
          return s.push(e), new this(i.root, s, n);
        }
      }
      static _createAfter(t, e) {
        if (!t.parent)
          throw new o.default("model-position-after-root", [this, t], {
            root: t,
          });
        return this._createAt(t.parent, t.endOffset, e);
      }
      static _createBefore(t, e) {
        if (!t.parent)
          throw new o.default("model-position-before-root", t, { root: t });
        return this._createAt(t.parent, t.startOffset, e);
      }
      static fromJSON(t, e) {
        if ("$graveyard" === t.root) {
          const n = new r(e.graveyard, t.path);
          return (n.stickiness = t.stickiness), n;
        }
        if (!e.getRoot(t.root))
          throw new o.default("model-position-fromjson-no-root", e, {
            rootName: t.root,
          });
        return new r(e.getRoot(t.root), t.path, t.stickiness);
      }
    }
    function a(t, e) {
      const n = e.getChild(e.offsetToIndex(t.offset));
      return n && n.is("$text") && n.startOffset < t.offset ? n : null;
    }
    function c(t, e, n) {
      return null !== n ? null : e.getChild(e.offsetToIndex(t.offset));
    }
    function l(t, e, n) {
      return null !== n ? null : e.getChild(e.offsetToIndex(t.offset) - 1);
    }
  },
  function (t, e, n) {
    "use strict";
    function i(t, ...e) {
      e.forEach((e) => {
        Object.getOwnPropertyNames(e)
          .concat(Object.getOwnPropertySymbols(e))
          .forEach((n) => {
            if (n in t.prototype) return;
            const i = Object.getOwnPropertyDescriptor(e, n);
            (i.enumerable = !1), Object.defineProperty(t.prototype, n, i);
          });
      });
    }
    n.r(e),
      n.d(e, "default", function () {
        return i;
      });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(94),
      s = n(37),
      o = n(0),
      r = n(152);
    n(133);
    class a {
      constructor(t, e) {
        (this.parent = t), (this.offset = e);
      }
      get nodeAfter() {
        return this.parent.is("$text")
          ? null
          : this.parent.getChild(this.offset) || null;
      }
      get nodeBefore() {
        return this.parent.is("$text")
          ? null
          : this.parent.getChild(this.offset - 1) || null;
      }
      get isAtStart() {
        return 0 === this.offset;
      }
      get isAtEnd() {
        const t = this.parent.is("$text")
          ? this.parent.data.length
          : this.parent.childCount;
        return this.offset === t;
      }
      get root() {
        return this.parent.root;
      }
      get editableElement() {
        let t = this.parent;
        for (; !(t instanceof r.a); ) {
          if (!t.parent) return null;
          t = t.parent;
        }
        return t;
      }
      getShiftedBy(t) {
        const e = a._createAt(this),
          n = e.offset + t;
        return (e.offset = n < 0 ? 0 : n), e;
      }
      getLastMatchingPosition(t, e = {}) {
        e.startPosition = this;
        const n = new i.a(e);
        return n.skip(t), n.position;
      }
      getAncestors() {
        return this.parent.is("documentFragment")
          ? [this.parent]
          : this.parent.getAncestors({ includeSelf: !0 });
      }
      getCommonAncestor(t) {
        const e = this.getAncestors(),
          n = t.getAncestors();
        let i = 0;
        for (; e[i] == n[i] && e[i]; ) i++;
        return 0 === i ? null : e[i - 1];
      }
      is(t) {
        return "position" === t || "view:position" === t;
      }
      isEqual(t) {
        return this.parent == t.parent && this.offset == t.offset;
      }
      isBefore(t) {
        return "before" == this.compareWith(t);
      }
      isAfter(t) {
        return "after" == this.compareWith(t);
      }
      compareWith(t) {
        if (this.root !== t.root) return "different";
        if (this.isEqual(t)) return "same";
        const e = this.parent.is("node") ? this.parent.getPath() : [],
          n = t.parent.is("node") ? t.parent.getPath() : [];
        e.push(this.offset), n.push(t.offset);
        const i = Object(s.a)(e, n);
        switch (i) {
          case "prefix":
            return "before";
          case "extension":
            return "after";
          default:
            return e[i] < n[i] ? "before" : "after";
        }
      }
      getWalker(t = {}) {
        return (t.startPosition = this), new i.a(t);
      }
      clone() {
        return new a(this.parent, this.offset);
      }
      static _createAt(t, e) {
        if (t instanceof a) return new this(t.parent, t.offset);
        {
          const n = t;
          if ("end" == e) e = n.is("$text") ? n.data.length : n.childCount;
          else {
            if ("before" == e) return this._createBefore(n);
            if ("after" == e) return this._createAfter(n);
            if (0 !== e && !e)
              throw new o.default("view-createpositionat-offset-required", n);
          }
          return new a(n, e);
        }
      }
      static _createAfter(t) {
        if (t.is("$textProxy"))
          return new a(t.textNode, t.offsetInText + t.data.length);
        if (!t.parent)
          throw new o.default("view-position-after-root", t, { root: t });
        return new a(t.parent, t.index + 1);
      }
      static _createBefore(t) {
        if (t.is("$textProxy")) return new a(t.textNode, t.offsetInText);
        if (!t.parent)
          throw new o.default("view-position-before-root", t, { root: t });
        return new a(t.parent, t.index);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return d;
    });
    var i = n(0),
      s = n(113),
      o = n(61),
      r = n(72),
      a = n(14),
      c = n(51),
      l = n(6),
      u = n(39);
    n(329);
    class d {
      constructor(t) {
        (this.element = null),
          (this.isRendered = !1),
          (this.locale = t),
          (this.t = t && t.t),
          (this._viewCollections = new c.default()),
          (this._unboundChildren = this.createCollection()),
          this._viewCollections.on("add", (e, n) => {
            n.locale = t;
          }),
          this.decorate("render");
      }
      get bindTemplate() {
        return this._bindTemplate
          ? this._bindTemplate
          : (this._bindTemplate = o.a.bind(this, this));
      }
      createCollection(t) {
        const e = new s.a(t);
        return this._viewCollections.add(e), e;
      }
      registerChild(t) {
        Object(u.a)(t) || (t = [t]);
        for (const e of t) this._unboundChildren.add(e);
      }
      deregisterChild(t) {
        Object(u.a)(t) || (t = [t]);
        for (const e of t) this._unboundChildren.remove(e);
      }
      setTemplate(t) {
        this.template = new o.a(t);
      }
      extendTemplate(t) {
        o.a.extend(this.template, t);
      }
      render() {
        if (this.isRendered)
          throw new i.default("ui-view-render-already-rendered", this);
        this.template &&
          ((this.element = this.template.render()),
          this.registerChild(this.template.getViews())),
          (this.isRendered = !0);
      }
      destroy() {
        this.stopListening(),
          this._viewCollections.map((t) => t.destroy()),
          this.template &&
            this.template._revertData &&
            this.template.revert(this.element);
      }
    }
    Object(l.default)(d, r.a), Object(l.default)(d, a.default);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(14),
      s = n(6);
    class o {
      constructor(t) {
        (this.editor = t),
          this.set("isEnabled", !0),
          (this._disableStack = new Set());
      }
      forceDisabled(t) {
        this._disableStack.add(t),
          1 == this._disableStack.size &&
            (this.on("set:isEnabled", r, { priority: "highest" }),
            (this.isEnabled = !1));
      }
      clearForceDisabled(t) {
        this._disableStack.delete(t),
          0 == this._disableStack.size &&
            (this.off("set:isEnabled", r), (this.isEnabled = !0));
      }
      destroy() {
        this.stopListening();
      }
      static get isContextPlugin() {
        return !1;
      }
    }
    function r(t) {
      (t.return = !1), t.stop();
    }
    Object(s.default)(o, i.default);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "c", function () {
      return s;
    }),
      n.d(e, "e", function () {
        return o;
      }),
      n.d(e, "d", function () {
        return r;
      }),
      n.d(e, "b", function () {
        return a;
      }),
      n.d(e, "a", function () {
        return c;
      }),
      n.d(e, "f", function () {
        return l;
      }),
      n.d(e, "g", function () {
        return u;
      });
    var i = n(16);
    function s(t) {
      const e = [];
      for (const n of u(t.getRanges())) {
        const t = n.getContainedElement();
        t && t.is("element", "tableCell") && e.push(t);
      }
      return e;
    }
    function o(t) {
      const e = [];
      for (const n of t.getRanges()) {
        const t = n.start.findAncestor("tableCell");
        t && e.push(t);
      }
      return e;
    }
    function r(t) {
      const e = s(t);
      return e.length ? e : o(t);
    }
    function a(t) {
      return d(t.map((t) => t.parent.index));
    }
    function c(t) {
      const e = t[0].findAncestor("table");
      return d(
        [...new i.a(e)].filter((e) => t.includes(e.cell)).map((t) => t.column)
      );
    }
    function l(t, e) {
      if (
        t.length < 2 ||
        !(function (t) {
          const e = t[0].findAncestor("table"),
            n = a(t),
            i = parseInt(e.getAttribute("headingRows") || 0);
          if (!f(n, i)) return !1;
          const s = parseInt(e.getAttribute("headingColumns") || 0);
          return f(c(t), s);
        })(t)
      )
        return !1;
      const n = new Set(),
        i = new Set();
      let s = 0;
      for (const o of t) {
        const { row: t, column: r } = e.getCellLocation(o),
          a = parseInt(o.getAttribute("rowspan") || 1),
          c = parseInt(o.getAttribute("colspan") || 1);
        n.add(t),
          i.add(r),
          a > 1 && n.add(t + a - 1),
          c > 1 && i.add(r + c - 1),
          (s += a * c);
      }
      return (
        (function (t, e) {
          const n = Array.from(t.values()),
            i = Array.from(e.values()),
            s = Math.max(...n),
            o = Math.min(...n),
            r = Math.max(...i),
            a = Math.min(...i);
          return (s - o + 1) * (r - a + 1);
        })(n, i) == s
      );
    }
    function u(t) {
      return Array.from(t).sort(h);
    }
    function d(t) {
      const e = t.sort((t, e) => t - e);
      return { first: e[0], last: e[e.length - 1] };
    }
    function h(t, e) {
      const n = t.start,
        i = e.start;
      return n.isBefore(i) ? -1 : 1;
    }
    function f({ first: t, last: e }, n) {
      return t < n === e < n;
    }
  },
  function (t, e, n) {
    "use strict";
    n.r(e),
      n.d(e, "_getEmitterListenedTo", function () {
        return u;
      }),
      n.d(e, "_setEmitterId", function () {
        return d;
      }),
      n.d(e, "_getEmitterId", function () {
        return h;
      });
    var i = n(74),
      s = n(44),
      o = n(109),
      r = (n(133), n(0));
    const a = Symbol("listeningTo"),
      c = Symbol("emitterId"),
      l = {
        on(t, e, n = {}) {
          this.listenTo(this, t, e, n);
        },
        once(t, e, n) {
          let i = !1;
          this.listenTo(
            this,
            t,
            function (t, ...n) {
              i || ((i = !0), t.off(), e.call(this, t, ...n));
            },
            n
          );
        },
        off(t, e) {
          this.stopListening(this, t, e);
        },
        listenTo(t, e, n, i = {}) {
          let s, o;
          this[a] || (this[a] = {});
          const r = this[a];
          h(t) || d(t);
          const c = h(t);
          (s = r[c]) || (s = r[c] = { emitter: t, callbacks: {} }),
            (o = s.callbacks[e]) || (o = s.callbacks[e] = []),
            o.push(n),
            (function (t, e, n, i, s) {
              e._addEventListener
                ? e._addEventListener(n, i, s)
                : t._addEventListener.call(e, n, i, s);
            })(this, t, e, n, i);
        },
        stopListening(t, e, n) {
          const i = this[a];
          let s = t && h(t);
          const o = i && s && i[s],
            r = o && e && o.callbacks[e];
          if (!(!i || (t && !o) || (e && !r)))
            if (n) {
              p(this, t, e, n);
              -1 !== r.indexOf(n) &&
                (1 === r.length ? delete o.callbacks[e] : p(this, t, e, n));
            } else if (r) {
              for (; (n = r.pop()); ) p(this, t, e, n);
              delete o.callbacks[e];
            } else if (o) {
              for (e in o.callbacks) this.stopListening(t, e);
              delete i[s];
            } else {
              for (s in i) this.stopListening(i[s].emitter);
              delete this[a];
            }
        },
        fire(t, ...e) {
          try {
            const n = t instanceof i.a ? t : new i.a(this, t),
              s = n.name;
            let o = (function t(e, n) {
              let i;
              if (!e._events || !(i = e._events[n]) || !i.callbacks.length)
                return n.indexOf(":") > -1
                  ? t(e, n.substr(0, n.lastIndexOf(":")))
                  : null;
              return i.callbacks;
            })(this, s);
            if ((n.path.push(this), o)) {
              const t = [n, ...e];
              o = Array.from(o);
              for (
                let e = 0;
                e < o.length &&
                (o[e].callback.apply(this, t),
                n.off.called &&
                  (delete n.off.called,
                  this._removeEventListener(s, o[e].callback)),
                !n.stop.called);
                e++
              );
            }
            if (this._delegations) {
              const t = this._delegations.get(s),
                i = this._delegations.get("*");
              t && g(t, n, e), i && g(i, n, e);
            }
            return n.return;
          } catch (t) {
            r.default.rethrowUnexpectedError(t, this);
          }
        },
        delegate(...t) {
          return {
            to: (e, n) => {
              this._delegations || (this._delegations = new Map()),
                t.forEach((t) => {
                  const i = this._delegations.get(t);
                  i ? i.set(e, n) : this._delegations.set(t, new Map([[e, n]]));
                });
            },
          };
        },
        stopDelegating(t, e) {
          if (this._delegations)
            if (t)
              if (e) {
                const n = this._delegations.get(t);
                n && n.delete(e);
              } else this._delegations.delete(t);
            else this._delegations.clear();
        },
        _addEventListener(t, e, n) {
          !(function (t, e) {
            const n = f(t);
            if (n[e]) return;
            let i = e,
              s = null;
            const o = [];
            for (; "" !== i && !n[i]; )
              (n[i] = { callbacks: [], childEvents: [] }),
                o.push(n[i]),
                s && n[i].childEvents.push(s),
                (s = i),
                (i = i.substr(0, i.lastIndexOf(":")));
            if ("" !== i) {
              for (const t of o) t.callbacks = n[i].callbacks.slice();
              n[i].childEvents.push(s);
            }
          })(this, t);
          const i = m(this, t),
            s = o.default.get(n.priority),
            r = { callback: e, priority: s };
          for (const t of i) {
            let e = !1;
            for (let n = 0; n < t.length; n++)
              if (t[n].priority < s) {
                t.splice(n, 0, r), (e = !0);
                break;
              }
            e || t.push(r);
          }
        },
        _removeEventListener(t, e) {
          const n = m(this, t);
          for (const t of n)
            for (let n = 0; n < t.length; n++)
              t[n].callback == e && (t.splice(n, 1), n--);
        },
      };
    function u(t, e) {
      return t[a] && t[a][e] ? t[a][e].emitter : null;
    }
    function d(t, e) {
      t[c] || (t[c] = e || Object(s.a)());
    }
    function h(t) {
      return t[c];
    }
    function f(t) {
      return (
        t._events || Object.defineProperty(t, "_events", { value: {} }),
        t._events
      );
    }
    function m(t, e) {
      const n = f(t)[e];
      if (!n) return [];
      let i = [n.callbacks];
      for (let e = 0; e < n.childEvents.length; e++) {
        const s = m(t, n.childEvents[e]);
        i = i.concat(s);
      }
      return i;
    }
    function g(t, e, n) {
      for (let [s, o] of t) {
        o ? "function" == typeof o && (o = o(e.name)) : (o = e.name);
        const t = new i.a(e.source, o);
        (t.path = [...e.path]), s.fire(t, ...n);
      }
    }
    function p(t, e, n, i) {
      e._removeEventListener
        ? e._removeEventListener(n, i)
        : t._removeEventListener.call(e, n, i);
    }
    e.default = l;
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "f", function () {
      return a;
    }),
      n.d(e, "a", function () {
        return l;
      }),
      n.d(e, "g", function () {
        return u;
      }),
      n.d(e, "b", function () {
        return d;
      }),
      n.d(e, "d", function () {
        return h;
      }),
      n.d(e, "c", function () {
        return f;
      }),
      n.d(e, "e", function () {
        return m;
      });
    var i = n(0),
      s = n(21);
    const o = { ctrl: "⌃", cmd: "⌘", alt: "⌥", shift: "⇧" },
      r = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" },
      a = (function () {
        const t = {
          arrowleft: 37,
          arrowup: 38,
          arrowright: 39,
          arrowdown: 40,
          backspace: 8,
          delete: 46,
          enter: 13,
          space: 32,
          esc: 27,
          tab: 9,
          ctrl: 1114112,
          shift: 2228224,
          alt: 4456448,
          cmd: 8912896,
        };
        for (let e = 65; e <= 90; e++) {
          const n = String.fromCharCode(e);
          t[n.toLowerCase()] = e;
        }
        for (let e = 48; e <= 57; e++) t[e - 48] = e;
        for (let e = 112; e <= 123; e++) t["f" + (e - 111)] = e;
        for (const e of "`-=[];',./\\") t[e] = e.charCodeAt(0);
        return t;
      })(),
      c = Object.fromEntries(
        Object.entries(a).map(([t, e]) => [
          e,
          t.charAt(0).toUpperCase() + t.slice(1),
        ])
      );
    function l(t) {
      let e;
      if ("string" == typeof t) {
        if (((e = a[t.toLowerCase()]), !e))
          throw new i.default("keyboard-unknown-key", null, { key: t });
      } else
        e =
          t.keyCode +
          (t.altKey ? a.alt : 0) +
          (t.ctrlKey ? a.ctrl : 0) +
          (t.shiftKey ? a.shift : 0) +
          (t.metaKey ? a.cmd : 0);
      return e;
    }
    function u(t) {
      return (
        "string" == typeof t &&
          (t = (function (t) {
            return t.split("+").map((t) => t.trim());
          })(t)),
        t
          .map((t) =>
            "string" == typeof t
              ? (function (t) {
                  if (t.endsWith("!")) return l(t.slice(0, -1));
                  const e = l(t);
                  return s.a.isMac && e == a.ctrl ? a.cmd : e;
                })(t)
              : t
          )
          .reduce((t, e) => e + t, 0)
      );
    }
    function d(t) {
      let e = u(t);
      return (
        Object.entries(s.a.isMac ? o : r).reduce(
          (t, [n, i]) => (0 != (e & a[n]) && ((e &= ~a[n]), (t += i)), t),
          ""
        ) + (e ? c[e] : "")
      );
    }
    function h(t) {
      return (
        t == a.arrowright ||
        t == a.arrowleft ||
        t == a.arrowup ||
        t == a.arrowdown
      );
    }
    function f(t, e) {
      const n = "ltr" === e;
      switch (t) {
        case a.arrowleft:
          return n ? "left" : "right";
        case a.arrowright:
          return n ? "right" : "left";
        case a.arrowup:
          return "up";
        case a.arrowdown:
          return "down";
      }
    }
    function m(t, e) {
      const n = f(t, e);
      return "down" === n || "right" === n;
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "x", function () {
      return i.b;
    }),
      n.d(e, "w", function () {
        return i.a;
      }),
      n.d(e, "E", function () {
        return i.e;
      }),
      n.d(e, "z", function () {
        return i.c;
      }),
      n.d(e, "D", function () {
        return i.d;
      }),
      n.d(e, "f", function () {
        return s.a;
      }),
      n.d(e, "g", function () {
        return o.a;
      }),
      n.d(e, "j", function () {
        return r.a;
      }),
      n.d(e, "n", function () {
        return a.a;
      }),
      n.d(e, "F", function () {
        return c.a;
      }),
      n.d(e, "i", function () {
        return l.a;
      }),
      n.d(e, "h", function () {
        return u.a;
      }),
      n.d(e, "p", function () {
        return d.a;
      }),
      n.d(e, "e", function () {
        return h.a;
      }),
      n.d(e, "b", function () {
        return f.a;
      }),
      n.d(e, "o", function () {
        return m.a;
      }),
      n.d(e, "r", function () {
        return g.a;
      }),
      n.d(e, "y", function () {
        return p.b;
      }),
      n.d(e, "m", function () {
        return b.a;
      }),
      n.d(e, "a", function () {
        return w.a;
      }),
      n.d(e, "c", function () {
        return v.a;
      }),
      n.d(e, "l", function () {
        return _.a;
      }),
      n.d(e, "d", function () {
        return y.a;
      }),
      n.d(e, "q", function () {
        return k.a;
      }),
      n.d(e, "k", function () {
        return A.a;
      }),
      n.d(e, "s", function () {
        return J;
      }),
      n.d(e, "t", function () {
        return Y;
      }),
      n.d(e, "u", function () {
        return ct;
      }),
      n.d(e, "v", function () {
        return lt;
      }),
      n.d(e, "A", function () {
        return S;
      }),
      n.d(e, "B", function () {
        return M;
      }),
      n.d(e, "C", function () {
        return N;
      });
    var i = n(283),
      s = (n(200), n(201), n(190), n(185)),
      o = n(47),
      r = n(65),
      a = n(191),
      c = n(196),
      l = (n(53), n(3), n(89)),
      u = n(55),
      d = (n(199), n(71)),
      h = n(20),
      f = n(110),
      m = n(202),
      g = n(145),
      p = n(118),
      b = n(58),
      w = n(284),
      v = n(59),
      _ = n(129),
      y = n(144),
      k = n(270),
      A = n(101);
    n(111), n(143);
    const C = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i,
      E = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i,
      O = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i,
      P =
        /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i,
      T = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i,
      x = new Set([
        "black",
        "silver",
        "gray",
        "white",
        "maroon",
        "red",
        "purple",
        "fuchsia",
        "green",
        "lime",
        "olive",
        "yellow",
        "navy",
        "blue",
        "teal",
        "aqua",
        "orange",
        "aliceblue",
        "antiquewhite",
        "aquamarine",
        "azure",
        "beige",
        "bisque",
        "blanchedalmond",
        "blueviolet",
        "brown",
        "burlywood",
        "cadetblue",
        "chartreuse",
        "chocolate",
        "coral",
        "cornflowerblue",
        "cornsilk",
        "crimson",
        "cyan",
        "darkblue",
        "darkcyan",
        "darkgoldenrod",
        "darkgray",
        "darkgreen",
        "darkgrey",
        "darkkhaki",
        "darkmagenta",
        "darkolivegreen",
        "darkorange",
        "darkorchid",
        "darkred",
        "darksalmon",
        "darkseagreen",
        "darkslateblue",
        "darkslategray",
        "darkslategrey",
        "darkturquoise",
        "darkviolet",
        "deeppink",
        "deepskyblue",
        "dimgray",
        "dimgrey",
        "dodgerblue",
        "firebrick",
        "floralwhite",
        "forestgreen",
        "gainsboro",
        "ghostwhite",
        "gold",
        "goldenrod",
        "greenyellow",
        "grey",
        "honeydew",
        "hotpink",
        "indianred",
        "indigo",
        "ivory",
        "khaki",
        "lavender",
        "lavenderblush",
        "lawngreen",
        "lemonchiffon",
        "lightblue",
        "lightcoral",
        "lightcyan",
        "lightgoldenrodyellow",
        "lightgray",
        "lightgreen",
        "lightgrey",
        "lightpink",
        "lightsalmon",
        "lightseagreen",
        "lightskyblue",
        "lightslategray",
        "lightslategrey",
        "lightsteelblue",
        "lightyellow",
        "limegreen",
        "linen",
        "magenta",
        "mediumaquamarine",
        "mediumblue",
        "mediumorchid",
        "mediumpurple",
        "mediumseagreen",
        "mediumslateblue",
        "mediumspringgreen",
        "mediumturquoise",
        "mediumvioletred",
        "midnightblue",
        "mintcream",
        "mistyrose",
        "moccasin",
        "navajowhite",
        "oldlace",
        "olivedrab",
        "orangered",
        "orchid",
        "palegoldenrod",
        "palegreen",
        "paleturquoise",
        "palevioletred",
        "papayawhip",
        "peachpuff",
        "peru",
        "pink",
        "plum",
        "powderblue",
        "rosybrown",
        "royalblue",
        "saddlebrown",
        "salmon",
        "sandybrown",
        "seagreen",
        "seashell",
        "sienna",
        "skyblue",
        "slateblue",
        "slategray",
        "slategrey",
        "snow",
        "springgreen",
        "steelblue",
        "tan",
        "thistle",
        "tomato",
        "turquoise",
        "violet",
        "wheat",
        "whitesmoke",
        "yellowgreen",
        "activeborder",
        "activecaption",
        "appworkspace",
        "background",
        "buttonface",
        "buttonhighlight",
        "buttonshadow",
        "buttontext",
        "captiontext",
        "graytext",
        "highlight",
        "highlighttext",
        "inactiveborder",
        "inactivecaption",
        "inactivecaptiontext",
        "infobackground",
        "infotext",
        "menu",
        "menutext",
        "scrollbar",
        "threeddarkshadow",
        "threedface",
        "threedhighlight",
        "threedlightshadow",
        "threedshadow",
        "window",
        "windowframe",
        "windowtext",
        "rebeccapurple",
        "currentcolor",
        "transparent",
      ]);
    function S(t) {
      return t.startsWith("#")
        ? C.test(t)
        : t.startsWith("rgb")
        ? E.test(t) || O.test(t)
        : t.startsWith("hsl")
        ? P.test(t) || T.test(t)
        : x.has(t.toLowerCase());
    }
    const I = [
      "none",
      "hidden",
      "dotted",
      "dashed",
      "solid",
      "double",
      "groove",
      "ridge",
      "inset",
      "outset",
    ];
    function R(t) {
      return I.includes(t);
    }
    const j =
      /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;
    function M(t) {
      return j.test(t);
    }
    const V = /^[+-]?[0-9]*([.][0-9]+)?%$/;
    function N(t) {
      return V.test(t);
    }
    const B = ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"];
    const D = ["center", "top", "bottom", "left", "right"];
    function F(t) {
      return D.includes(t);
    }
    const z = ["fixed", "scroll", "local"];
    function L(t) {
      return z.includes(t);
    }
    const H = /^url\(/;
    function W(t) {
      return H.test(t);
    }
    function q(t = "") {
      if ("" === t)
        return { top: void 0, right: void 0, bottom: void 0, left: void 0 };
      const e = G(t),
        n = e[0],
        i = e[2] || n,
        s = e[1] || n;
      return { top: n, bottom: i, right: s, left: e[3] || s };
    }
    function $(t) {
      return (e) => {
        const { top: n, right: i, bottom: s, left: o } = e,
          r = [];
        return (
          [n, i, o, s].every((t) => !!t)
            ? r.push([t, U(e)])
            : (n && r.push([t + "-top", n]),
              i && r.push([t + "-right", i]),
              s && r.push([t + "-bottom", s]),
              o && r.push([t + "-left", o])),
          r
        );
      };
    }
    function U({ top: t, right: e, bottom: n, left: i }) {
      const s = [];
      return (
        i !== e
          ? s.push(t, e, n, i)
          : n !== t
          ? s.push(t, e, n)
          : e !== t
          ? s.push(t, e)
          : s.push(t),
        s.join(" ")
      );
    }
    function K(t) {
      return (e) => ({ path: t, value: q(e) });
    }
    function G(t) {
      return t
        .replace(/, /g, ",")
        .split(" ")
        .map((t) => t.replace(/,/g, ", "));
    }
    function J(t) {
      t.setNormalizer("background", Q),
        t.setNormalizer("background-color", (t) => ({
          path: "background.color",
          value: t,
        })),
        t.setReducer("background", (t) => {
          const e = [];
          return e.push(["background-color", t.color]), e;
        }),
        t.setStyleRelation("background", ["background-color"]);
    }
    function Q(t) {
      const e = {},
        n = G(t);
      for (const t of n)
        (i = t),
          B.includes(i)
            ? ((e.repeat = e.repeat || []), e.repeat.push(t))
            : F(t)
            ? ((e.position = e.position || []), e.position.push(t))
            : L(t)
            ? (e.attachment = t)
            : S(t)
            ? (e.color = t)
            : W(t) && (e.image = t);
      var i;
      return { path: "background", value: e };
    }
    function Y(t) {
      t.setNormalizer("border", X),
        t.setNormalizer("border-top", Z("top")),
        t.setNormalizer("border-right", Z("right")),
        t.setNormalizer("border-bottom", Z("bottom")),
        t.setNormalizer("border-left", Z("left")),
        t.setNormalizer("border-color", tt("color")),
        t.setNormalizer("border-width", tt("width")),
        t.setNormalizer("border-style", tt("style")),
        t.setNormalizer("border-top-color", nt("color", "top")),
        t.setNormalizer("border-top-style", nt("style", "top")),
        t.setNormalizer("border-top-width", nt("width", "top")),
        t.setNormalizer("border-right-color", nt("color", "right")),
        t.setNormalizer("border-right-style", nt("style", "right")),
        t.setNormalizer("border-right-width", nt("width", "right")),
        t.setNormalizer("border-bottom-color", nt("color", "bottom")),
        t.setNormalizer("border-bottom-style", nt("style", "bottom")),
        t.setNormalizer("border-bottom-width", nt("width", "bottom")),
        t.setNormalizer("border-left-color", nt("color", "left")),
        t.setNormalizer("border-left-style", nt("style", "left")),
        t.setNormalizer("border-left-width", nt("width", "left")),
        t.setExtractor("border-top", it("top")),
        t.setExtractor("border-right", it("right")),
        t.setExtractor("border-bottom", it("bottom")),
        t.setExtractor("border-left", it("left")),
        t.setExtractor("border-top-color", "border.color.top"),
        t.setExtractor("border-right-color", "border.color.right"),
        t.setExtractor("border-bottom-color", "border.color.bottom"),
        t.setExtractor("border-left-color", "border.color.left"),
        t.setExtractor("border-top-width", "border.width.top"),
        t.setExtractor("border-right-width", "border.width.right"),
        t.setExtractor("border-bottom-width", "border.width.bottom"),
        t.setExtractor("border-left-width", "border.width.left"),
        t.setExtractor("border-top-style", "border.style.top"),
        t.setExtractor("border-right-style", "border.style.right"),
        t.setExtractor("border-bottom-style", "border.style.bottom"),
        t.setExtractor("border-left-style", "border.style.left"),
        t.setReducer("border-color", $("border-color")),
        t.setReducer("border-style", $("border-style")),
        t.setReducer("border-width", $("border-width")),
        t.setReducer("border-top", rt("top")),
        t.setReducer("border-right", rt("right")),
        t.setReducer("border-bottom", rt("bottom")),
        t.setReducer("border-left", rt("left")),
        t.setReducer(
          "border",
          (function () {
            return (e) => {
              const n = st(e, "top"),
                i = st(e, "right"),
                s = st(e, "bottom"),
                o = st(e, "left"),
                r = [n, i, s, o],
                a = {
                  width: t(r, "width"),
                  style: t(r, "style"),
                  color: t(r, "color"),
                },
                c = at(a, "all");
              if (c.length) return c;
              return [
                ...Object.entries(a).reduce(
                  (t, [e, n]) => (
                    n &&
                      (t.push(["border-" + e, n]),
                      r.forEach((t) => (t[e] = null))),
                    t
                  ),
                  []
                ),
                ...at(n, "top"),
                ...at(i, "right"),
                ...at(s, "bottom"),
                ...at(o, "left"),
              ];
            };
            function t(t, e) {
              return t.map((t) => t[e]).reduce((t, e) => (t == e ? t : null));
            }
          })()
        ),
        t.setStyleRelation("border", [
          "border-color",
          "border-style",
          "border-width",
          "border-top",
          "border-right",
          "border-bottom",
          "border-left",
          "border-top-color",
          "border-right-color",
          "border-bottom-color",
          "border-left-color",
          "border-top-style",
          "border-right-style",
          "border-bottom-style",
          "border-left-style",
          "border-top-width",
          "border-right-width",
          "border-bottom-width",
          "border-left-width",
        ]),
        t.setStyleRelation("border-color", [
          "border-top-color",
          "border-right-color",
          "border-bottom-color",
          "border-left-color",
        ]),
        t.setStyleRelation("border-style", [
          "border-top-style",
          "border-right-style",
          "border-bottom-style",
          "border-left-style",
        ]),
        t.setStyleRelation("border-width", [
          "border-top-width",
          "border-right-width",
          "border-bottom-width",
          "border-left-width",
        ]),
        t.setStyleRelation("border-top", [
          "border-top-color",
          "border-top-style",
          "border-top-width",
        ]),
        t.setStyleRelation("border-right", [
          "border-right-color",
          "border-right-style",
          "border-right-width",
        ]),
        t.setStyleRelation("border-bottom", [
          "border-bottom-color",
          "border-bottom-style",
          "border-bottom-width",
        ]),
        t.setStyleRelation("border-left", [
          "border-left-color",
          "border-left-style",
          "border-left-width",
        ]);
    }
    function X(t) {
      const { color: e, style: n, width: i } = ot(t);
      return {
        path: "border",
        value: { color: q(e), style: q(n), width: q(i) },
      };
    }
    function Z(t) {
      return (e) => {
        const { color: n, style: i, width: s } = ot(e),
          o = {};
        return (
          void 0 !== n && (o.color = { [t]: n }),
          void 0 !== i && (o.style = { [t]: i }),
          void 0 !== s && (o.width = { [t]: s }),
          { path: "border", value: o }
        );
      };
    }
    function tt(t) {
      return (e) => ({ path: "border", value: et(e, t) });
    }
    function et(t, e) {
      return { [e]: q(t) };
    }
    function nt(t, e) {
      return (n) => ({ path: "border", value: { [t]: { [e]: n } } });
    }
    function it(t) {
      return (e, n) => {
        if (n.border) return st(n.border, t);
      };
    }
    function st(t, e) {
      const n = {};
      return (
        t.width && t.width[e] && (n.width = t.width[e]),
        t.style && t.style[e] && (n.style = t.style[e]),
        t.color && t.color[e] && (n.color = t.color[e]),
        n
      );
    }
    function ot(t) {
      const e = {},
        n = G(t);
      for (const t of n)
        M(t) || /thin|medium|thick/.test(t)
          ? (e.width = t)
          : R(t)
          ? (e.style = t)
          : (e.color = t);
      return e;
    }
    function rt(t) {
      return (e) => at(e, t);
    }
    function at(t, e) {
      const n = [];
      if (
        (t && t.width && n.push("width"),
        t && t.style && n.push("style"),
        t && t.color && n.push("color"),
        3 == n.length)
      ) {
        const i = n.map((e) => t[e]).join(" ");
        return ["all" == e ? ["border", i] : ["border-" + e, i]];
      }
      return "all" == e ? [] : n.map((n) => [`border-${e}-${n}`, t[n]]);
    }
    function ct(t) {
      t.setNormalizer("margin", K("margin")),
        t.setNormalizer("margin-top", (t) => ({
          path: "margin.top",
          value: t,
        })),
        t.setNormalizer("margin-right", (t) => ({
          path: "margin.right",
          value: t,
        })),
        t.setNormalizer("margin-bottom", (t) => ({
          path: "margin.bottom",
          value: t,
        })),
        t.setNormalizer("margin-left", (t) => ({
          path: "margin.left",
          value: t,
        })),
        t.setReducer("margin", $("margin")),
        t.setStyleRelation("margin", [
          "margin-top",
          "margin-right",
          "margin-bottom",
          "margin-left",
        ]);
    }
    function lt(t) {
      t.setNormalizer("padding", K("padding")),
        t.setNormalizer("padding-top", (t) => ({
          path: "padding.top",
          value: t,
        })),
        t.setNormalizer("padding-right", (t) => ({
          path: "padding.right",
          value: t,
        })),
        t.setNormalizer("padding-bottom", (t) => ({
          path: "padding.bottom",
          value: t,
        })),
        t.setNormalizer("padding-left", (t) => ({
          path: "padding.left",
          value: t,
        })),
        t.setReducer("padding", $("padding")),
        t.setStyleRelation("padding", [
          "padding-top",
          "padding-right",
          "padding-bottom",
          "padding-left",
        ]);
    }
  },
  function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(11),
      s = n(0),
      o = n(30),
      r = n(174);
    const a = Symbol("observableProperties"),
      c = Symbol("boundObservables"),
      l = Symbol("boundProperties"),
      u = Symbol("decoratedMethods"),
      d = Symbol("decoratedOriginal"),
      h = {
        set(t, e) {
          if (Object(o.a)(t))
            return void Object.keys(t).forEach((e) => {
              this.set(e, t[e]);
            }, this);
          f(this);
          const n = this[a];
          if (t in this && !n.has(t))
            throw new s.default("observable-set-cannot-override", this);
          Object.defineProperty(this, t, {
            enumerable: !0,
            configurable: !0,
            get: () => n.get(t),
            set(e) {
              const i = n.get(t);
              let s = this.fire("set:" + t, t, e, i);
              void 0 === s && (s = e),
                (i === s && n.has(t)) ||
                  (n.set(t, s), this.fire("change:" + t, t, s, i));
            },
          }),
            (this[t] = e);
        },
        bind(...t) {
          if (!t.length || !p(t))
            throw new s.default("observable-bind-wrong-properties", this);
          if (new Set(t).size !== t.length)
            throw new s.default("observable-bind-duplicate-properties", this);
          f(this);
          const e = this[l];
          t.forEach((t) => {
            if (e.has(t)) throw new s.default("observable-bind-rebind", this);
          });
          const n = new Map();
          return (
            t.forEach((t) => {
              const i = { property: t, to: [] };
              e.set(t, i), n.set(t, i);
            }),
            {
              to: m,
              toMany: g,
              _observable: this,
              _bindProperties: t,
              _to: [],
              _bindings: n,
            }
          );
        },
        unbind(...t) {
          if (!this[a]) return;
          const e = this[l],
            n = this[c];
          if (t.length) {
            if (!p(t))
              throw new s.default("observable-unbind-wrong-properties", this);
            t.forEach((t) => {
              const i = e.get(t);
              if (!i) return;
              let s, o, r, a;
              i.to.forEach((t) => {
                (s = t[0]),
                  (o = t[1]),
                  (r = n.get(s)),
                  (a = r[o]),
                  a.delete(i),
                  a.size || delete r[o],
                  Object.keys(r).length ||
                    (n.delete(s), this.stopListening(s, "change"));
              }),
                e.delete(t);
            });
          } else
            n.forEach((t, e) => {
              this.stopListening(e, "change");
            }),
              n.clear(),
              e.clear();
        },
        decorate(t) {
          const e = this[t];
          if (!e)
            throw new s.default(
              "observablemixin-cannot-decorate-undefined",
              this,
              { object: this, methodName: t }
            );
          this.on(t, (t, n) => {
            t.return = e.apply(this, n);
          }),
            (this[t] = function (...e) {
              return this.fire(t, e);
            }),
            (this[t][d] = e),
            this[u] || (this[u] = []),
            this[u].push(t);
        },
      };
    function f(t) {
      t[a] ||
        (Object.defineProperty(t, a, { value: new Map() }),
        Object.defineProperty(t, c, { value: new Map() }),
        Object.defineProperty(t, l, { value: new Map() }));
    }
    function m(...t) {
      const e = (function (...t) {
          if (!t.length)
            throw new s.default("observable-bind-to-parse-error", null);
          const e = { to: [] };
          let n;
          "function" == typeof t[t.length - 1] && (e.callback = t.pop());
          return (
            t.forEach((t) => {
              if ("string" == typeof t) n.properties.push(t);
              else {
                if ("object" != typeof t)
                  throw new s.default("observable-bind-to-parse-error", null);
                (n = { observable: t, properties: [] }), e.to.push(n);
              }
            }),
            e
          );
        })(...t),
        n = Array.from(this._bindings.keys()),
        i = n.length;
      if (!e.callback && e.to.length > 1)
        throw new s.default("observable-bind-to-no-callback", this);
      if (i > 1 && e.callback)
        throw new s.default("observable-bind-to-extra-callback", this);
      var o;
      e.to.forEach((t) => {
        if (t.properties.length && t.properties.length !== i)
          throw new s.default("observable-bind-to-properties-length", this);
        t.properties.length || (t.properties = this._bindProperties);
      }),
        (this._to = e.to),
        e.callback && (this._bindings.get(n[0]).callback = e.callback),
        (o = this._observable),
        this._to.forEach((t) => {
          const e = o[c];
          let n;
          e.get(t.observable) ||
            o.listenTo(t.observable, "change", (i, s) => {
              (n = e.get(t.observable)[s]),
                n &&
                  n.forEach((t) => {
                    b(o, t.property);
                  });
            });
        }),
        (function (t) {
          let e;
          t._bindings.forEach((n, i) => {
            t._to.forEach((s) => {
              (e = s.properties[n.callback ? 0 : t._bindProperties.indexOf(i)]),
                n.to.push([s.observable, e]),
                (function (t, e, n, i) {
                  const s = t[c],
                    o = s.get(n),
                    r = o || {};
                  r[i] || (r[i] = new Set());
                  r[i].add(e), o || s.set(n, r);
                })(t._observable, n, s.observable, e);
            });
          });
        })(this),
        this._bindProperties.forEach((t) => {
          b(this._observable, t);
        });
    }
    function g(t, e, n) {
      if (this._bindings.size > 1)
        throw new s.default("observable-bind-to-many-not-one-binding", this);
      this.to(
        ...(function (t, e) {
          const n = t.map((t) => [t, e]);
          return Array.prototype.concat.apply([], n);
        })(t, e),
        n
      );
    }
    function p(t) {
      return t.every((t) => "string" == typeof t);
    }
    function b(t, e) {
      const n = t[l].get(e);
      let i;
      n.callback
        ? (i = n.callback.apply(
            t,
            n.to.map((t) => t[0][t[1]])
          ))
        : ((i = n.to[0]), (i = i[0][i[1]])),
        Object.prototype.hasOwnProperty.call(t, e) ? (t[e] = i) : t.set(e, i);
    }
    Object(r.a)(h, i.default),
      (h.stopListening = function (t, e, n) {
        if (!t && this[u]) {
          for (const t of this[u]) this[t] = this[t][d];
          delete this[u];
        }
        i.default.stopListening.call(this, t, e, n);
      }),
      (e.default = h);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(7),
      s = n(94);
    class o {
      constructor(t, e = null) {
        (this.start = t.clone()), (this.end = e ? e.clone() : t.clone());
      }
      *[Symbol.iterator]() {
        yield* new s.a({ boundaries: this, ignoreElementEnd: !0 });
      }
      get isCollapsed() {
        return this.start.isEqual(this.end);
      }
      get isFlat() {
        return this.start.parent === this.end.parent;
      }
      get root() {
        return this.start.root;
      }
      getEnlarged() {
        let t = this.start.getLastMatchingPosition(r, {
            direction: "backward",
          }),
          e = this.end.getLastMatchingPosition(r);
        return (
          t.parent.is("$text") &&
            t.isAtStart &&
            (t = i.a._createBefore(t.parent)),
          e.parent.is("$text") && e.isAtEnd && (e = i.a._createAfter(e.parent)),
          new o(t, e)
        );
      }
      getTrimmed() {
        let t = this.start.getLastMatchingPosition(r);
        if (t.isAfter(this.end) || t.isEqual(this.end)) return new o(t, t);
        let e = this.end.getLastMatchingPosition(r, { direction: "backward" });
        const n = t.nodeAfter,
          s = e.nodeBefore;
        return (
          n && n.is("$text") && (t = new i.a(n, 0)),
          s && s.is("$text") && (e = new i.a(s, s.data.length)),
          new o(t, e)
        );
      }
      isEqual(t) {
        return (
          this == t || (this.start.isEqual(t.start) && this.end.isEqual(t.end))
        );
      }
      containsPosition(t) {
        return t.isAfter(this.start) && t.isBefore(this.end);
      }
      containsRange(t, e = !1) {
        t.isCollapsed && (e = !1);
        const n =
            this.containsPosition(t.start) ||
            (e && this.start.isEqual(t.start)),
          i = this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
        return n && i;
      }
      getDifference(t) {
        const e = [];
        return (
          this.isIntersecting(t)
            ? (this.containsPosition(t.start) &&
                e.push(new o(this.start, t.start)),
              this.containsPosition(t.end) && e.push(new o(t.end, this.end)))
            : e.push(this.clone()),
          e
        );
      }
      getIntersection(t) {
        if (this.isIntersecting(t)) {
          let e = this.start,
            n = this.end;
          return (
            this.containsPosition(t.start) && (e = t.start),
            this.containsPosition(t.end) && (n = t.end),
            new o(e, n)
          );
        }
        return null;
      }
      getWalker(t = {}) {
        return (t.boundaries = this), new s.a(t);
      }
      getCommonAncestor() {
        return this.start.getCommonAncestor(this.end);
      }
      getContainedElement() {
        if (this.isCollapsed) return null;
        let t = this.start.nodeAfter,
          e = this.end.nodeBefore;
        return (
          this.start.parent.is("$text") &&
            this.start.isAtEnd &&
            this.start.parent.nextSibling &&
            (t = this.start.parent.nextSibling),
          this.end.parent.is("$text") &&
            this.end.isAtStart &&
            this.end.parent.previousSibling &&
            (e = this.end.parent.previousSibling),
          t && t.is("element") && t === e ? t : null
        );
      }
      clone() {
        return new o(this.start, this.end);
      }
      *getItems(t = {}) {
        (t.boundaries = this), (t.ignoreElementEnd = !0);
        const e = new s.a(t);
        for (const t of e) yield t.item;
      }
      *getPositions(t = {}) {
        t.boundaries = this;
        const e = new s.a(t);
        yield e.position;
        for (const t of e) yield t.nextPosition;
      }
      is(t) {
        return "range" === t || "view:range" === t;
      }
      isIntersecting(t) {
        return this.start.isBefore(t.end) && this.end.isAfter(t.start);
      }
      static _createFromParentsAndOffsets(t, e, n, s) {
        return new this(new i.a(t, e), new i.a(n, s));
      }
      static _createFromPositionAndShift(t, e) {
        const n = t,
          i = t.getShiftedBy(e);
        return e > 0 ? new this(n, i) : new this(i, n);
      }
      static _createIn(t) {
        return this._createFromParentsAndOffsets(t, 0, t, t.childCount);
      }
      static _createOn(t) {
        const e = t.is("$textProxy") ? t.offsetSize : 1;
        return this._createFromPositionAndShift(i.a._createBefore(t), e);
      }
    }
    function r(t) {
      return !(!t.item.is("attributeElement") && !t.item.is("uiElement"));
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return i;
    });
    class i {
      constructor(t, e = {}) {
        (this._table = t),
          (this._startRow = void 0 !== e.row ? e.row : e.startRow || 0),
          (this._endRow = void 0 !== e.row ? e.row : e.endRow),
          (this._startColumn =
            void 0 !== e.column ? e.column : e.startColumn || 0),
          (this._endColumn = void 0 !== e.column ? e.column : e.endColumn),
          (this._includeAllSlots = !!e.includeAllSlots),
          (this._skipRows = new Set()),
          (this._row = 0),
          (this._rowIndex = 0),
          (this._column = 0),
          (this._cellIndex = 0),
          (this._spannedCells = new Map()),
          (this._nextCellAtColumn = -1);
      }
      [Symbol.iterator]() {
        return this;
      }
      next() {
        const t = this._table.getChild(this._rowIndex);
        if (!t || this._isOverEndRow()) return { done: !0 };
        if (!t.is("element", "tableRow")) return this._rowIndex++, this.next();
        if (this._isOverEndColumn()) return this._advanceToNextRow();
        let e = null;
        const n = this._getSpanned();
        if (n)
          this._includeAllSlots &&
            !this._shouldSkipSlot() &&
            (e = this._formatOutValue(n.cell, n.row, n.column));
        else {
          const n = t.getChild(this._cellIndex);
          if (!n) return this._advanceToNextRow();
          const i = parseInt(n.getAttribute("colspan") || 1),
            s = parseInt(n.getAttribute("rowspan") || 1);
          (i > 1 || s > 1) && this._recordSpans(n, s, i),
            this._shouldSkipSlot() || (e = this._formatOutValue(n)),
            (this._nextCellAtColumn = this._column + i);
        }
        return (
          this._column++,
          this._column == this._nextCellAtColumn && this._cellIndex++,
          e || this.next()
        );
      }
      skipRow(t) {
        this._skipRows.add(t);
      }
      _advanceToNextRow() {
        return (
          this._row++,
          this._rowIndex++,
          (this._column = 0),
          (this._cellIndex = 0),
          (this._nextCellAtColumn = -1),
          this.next()
        );
      }
      _isOverEndRow() {
        return void 0 !== this._endRow && this._row > this._endRow;
      }
      _isOverEndColumn() {
        return void 0 !== this._endColumn && this._column > this._endColumn;
      }
      _formatOutValue(t, e = this._row, n = this._column) {
        return { done: !1, value: new s(this, t, e, n) };
      }
      _shouldSkipSlot() {
        const t = this._skipRows.has(this._row),
          e = this._row < this._startRow,
          n = this._column < this._startColumn,
          i = void 0 !== this._endColumn && this._column > this._endColumn;
        return t || e || n || i;
      }
      _getSpanned() {
        const t = this._spannedCells.get(this._row);
        return (t && t.get(this._column)) || null;
      }
      _recordSpans(t, e, n) {
        const i = { cell: t, row: this._row, column: this._column };
        for (let t = this._row; t < this._row + e; t++)
          for (let e = this._column; e < this._column + n; e++)
            (t == this._row && e == this._column) ||
              this._markSpannedCell(t, e, i);
      }
      _markSpannedCell(t, e, n) {
        this._spannedCells.has(t) || this._spannedCells.set(t, new Map());
        this._spannedCells.get(t).set(e, n);
      }
    }
    class s {
      constructor(t, e, n, i) {
        (this.cell = e),
          (this.row = t._row),
          (this.column = t._column),
          (this.cellAnchorRow = n),
          (this.cellAnchorColumn = i),
          (this._cellIndex = t._cellIndex),
          (this._rowIndex = t._rowIndex),
          (this._table = t._table);
      }
      get isAnchor() {
        return (
          this.row === this.cellAnchorRow &&
          this.column === this.cellAnchorColumn
        );
      }
      get cellWidth() {
        return parseInt(this.cell.getAttribute("colspan") || 1);
      }
      get cellHeight() {
        return parseInt(this.cell.getAttribute("rowspan") || 1);
      }
      get rowIndex() {
        return this._rowIndex;
      }
      getPositionBefore() {
        return this._table.root.document.model.createPositionAt(
          this._table.getChild(this.row),
          this._cellIndex
        );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    function i(t, e, n, i, s = 1) {
      e > s ? i.setAttribute(t, e, n) : i.removeAttribute(t, n);
    }
    function s(t, e, n = {}) {
      const i = t.createElement("tableCell", n);
      return t.insertElement("paragraph", i), t.insert(i, e), i;
    }
    function o(t, e) {
      const n = e.parent.parent,
        i = parseInt(n.getAttribute("headingColumns") || 0),
        { column: s } = t.getCellLocation(e);
      return !!i && s < i;
    }
    n.d(e, "c", function () {
      return i;
    }),
      n.d(e, "a", function () {
        return s;
      }),
      n.d(e, "b", function () {
        return o;
      });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return l;
    });
    var i = n(135),
      s = n(163),
      o = n(219),
      r = n(42),
      a = n(179);
    const c = ["top", "right", "bottom", "left", "width", "height"];
    class l {
      constructor(t) {
        const e = Object(i.a)(t);
        if (
          (Object.defineProperty(this, "_source", {
            value: t._source || t,
            writable: !0,
            enumerable: !1,
          }),
          Object(a.a)(t) || e)
        )
          if (e) {
            const e = l.getDomRangeRects(t);
            u(this, l.getBoundingRect(e));
          } else u(this, t.getBoundingClientRect());
        else if (Object(s.a)(t)) {
          const { innerWidth: e, innerHeight: n } = t;
          u(this, {
            top: 0,
            right: e,
            bottom: n,
            left: 0,
            width: e,
            height: n,
          });
        } else u(this, t);
      }
      clone() {
        return new l(this);
      }
      moveTo(t, e) {
        return (
          (this.top = e),
          (this.right = t + this.width),
          (this.bottom = e + this.height),
          (this.left = t),
          this
        );
      }
      moveBy(t, e) {
        return (
          (this.top += e),
          (this.right += t),
          (this.left += t),
          (this.bottom += e),
          this
        );
      }
      getIntersection(t) {
        const e = {
          top: Math.max(this.top, t.top),
          right: Math.min(this.right, t.right),
          bottom: Math.min(this.bottom, t.bottom),
          left: Math.max(this.left, t.left),
        };
        return (
          (e.width = e.right - e.left),
          (e.height = e.bottom - e.top),
          e.width < 0 || e.height < 0 ? null : new l(e)
        );
      }
      getIntersectionArea(t) {
        const e = this.getIntersection(t);
        return e ? e.getArea() : 0;
      }
      getArea() {
        return this.width * this.height;
      }
      getVisible() {
        const t = this._source;
        let e = this.clone();
        if (!d(t)) {
          let n = t.parentNode || t.commonAncestorContainer;
          for (; n && !d(n); ) {
            const t = new l(n),
              i = e.getIntersection(t);
            if (!i) return null;
            i.getArea() < e.getArea() && (e = i), (n = n.parentNode);
          }
        }
        return e;
      }
      isEqual(t) {
        for (const e of c) if (this[e] !== t[e]) return !1;
        return !0;
      }
      contains(t) {
        const e = this.getIntersection(t);
        return !(!e || !e.isEqual(t));
      }
      excludeScrollbarsAndBorders() {
        const t = this._source;
        let e, n, i;
        if (Object(s.a)(t))
          (e = t.innerWidth - t.document.documentElement.clientWidth),
            (n = t.innerHeight - t.document.documentElement.clientHeight),
            (i = t.getComputedStyle(t.document.documentElement).direction);
        else {
          const s = Object(o.a)(this._source);
          (e = t.offsetWidth - t.clientWidth - s.left - s.right),
            (n = t.offsetHeight - t.clientHeight - s.top - s.bottom),
            (i = t.ownerDocument.defaultView.getComputedStyle(t).direction),
            (this.left += s.left),
            (this.top += s.top),
            (this.right -= s.right),
            (this.bottom -= s.bottom),
            (this.width = this.right - this.left),
            (this.height = this.bottom - this.top);
        }
        return (
          (this.width -= e),
          "ltr" === i ? (this.right -= e) : (this.left += e),
          (this.height -= n),
          (this.bottom -= n),
          this
        );
      }
      static getDomRangeRects(t) {
        const e = [],
          n = Array.from(t.getClientRects());
        if (n.length) for (const t of n) e.push(new l(t));
        else {
          let n = t.startContainer;
          Object(r.a)(n) && (n = n.parentNode);
          const i = new l(n.getBoundingClientRect());
          (i.right = i.left), (i.width = 0), e.push(i);
        }
        return e;
      }
      static getBoundingRect(t) {
        const e = {
          left: Number.POSITIVE_INFINITY,
          top: Number.POSITIVE_INFINITY,
          right: Number.NEGATIVE_INFINITY,
          bottom: Number.NEGATIVE_INFINITY,
        };
        let n = 0;
        for (const i of t)
          n++,
            (e.left = Math.min(e.left, i.left)),
            (e.top = Math.min(e.top, i.top)),
            (e.right = Math.max(e.right, i.right)),
            (e.bottom = Math.max(e.bottom, i.bottom));
        return 0 == n
          ? null
          : ((e.width = e.right - e.left),
            (e.height = e.bottom - e.top),
            new l(e));
      }
    }
    function u(t, e) {
      for (const n of c) t[n] = e[n];
    }
    function d(t) {
      return !!Object(a.a)(t) && t === t.ownerDocument.body;
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return i.a;
    }),
      n.d(e, "c", function () {
        return u;
      }),
      n.d(e, "b", function () {
        return O;
      }),
      n.d(e, "e", function () {
        return c.d;
      }),
      n.d(e, "g", function () {
        return c.f;
      }),
      n.d(e, "f", function () {
        return c.e;
      }),
      n.d(e, "h", function () {
        return c.g;
      }),
      n.d(e, "d", function () {
        return c.b;
      });
    var i = n(181),
      s = n(9),
      o = n(139),
      r = n(97),
      a = n(82),
      c = n(28),
      l = n(0);
    class u extends s.a {
      static get requires() {
        return [o.a];
      }
      static get pluginName() {
        return "WidgetToolbarRepository";
      }
      init() {
        const t = this.editor;
        if (t.plugins.has("BalloonToolbar")) {
          const e = t.plugins.get("BalloonToolbar");
          this.listenTo(
            e,
            "show",
            (e) => {
              (function (t) {
                const e = t.getSelectedElement();
                return !(!e || !Object(c.d)(e));
              })(t.editing.view.document.selection) && e.stop();
            },
            { priority: "high" }
          );
        }
        (this._toolbarDefinitions = new Map()),
          (this._balloon = this.editor.plugins.get("ContextualBalloon")),
          this.on("change:isEnabled", () => {
            this._updateToolbarsVisibility();
          }),
          this.listenTo(t.ui, "update", () => {
            this._updateToolbarsVisibility();
          }),
          this.listenTo(
            t.ui.focusTracker,
            "change:isFocused",
            () => {
              this._updateToolbarsVisibility();
            },
            { priority: "low" }
          );
      }
      destroy() {
        super.destroy();
        for (const t of this._toolbarDefinitions.values()) t.view.destroy();
      }
      register(
        t,
        {
          ariaLabel: e,
          items: n,
          getRelatedElement: i,
          balloonClassName: s = "ck-toolbar-container",
        }
      ) {
        if (!n.length)
          return void Object(l.logWarning)("widget-toolbar-no-items", {
            toolbarId: t,
          });
        const o = this.editor,
          a = o.t,
          c = new r.a(o.locale);
        if (
          ((c.ariaLabel = e || a("Widget toolbar")),
          this._toolbarDefinitions.has(t))
        )
          throw new l.default("widget-toolbar-duplicated", this, {
            toolbarId: t,
          });
        c.fillFromConfig(n, o.ui.componentFactory),
          this._toolbarDefinitions.set(t, {
            view: c,
            getRelatedElement: i,
            balloonClassName: s,
          });
      }
      _updateToolbarsVisibility() {
        let t = 0,
          e = null,
          n = null;
        for (const i of this._toolbarDefinitions.values()) {
          const s = i.getRelatedElement(
            this.editor.editing.view.document.selection
          );
          if (this.isEnabled && s)
            if (this.editor.ui.focusTracker.isFocused) {
              const o = s.getAncestors().length;
              o > t && ((t = o), (e = s), (n = i));
            } else this._isToolbarVisible(i) && this._hideToolbar(i);
          else this._isToolbarInBalloon(i) && this._hideToolbar(i);
        }
        n && this._showToolbar(n, e);
      }
      _hideToolbar(t) {
        this._balloon.remove(t.view),
          this.stopListening(this._balloon, "change:visibleView");
      }
      _showToolbar(t, e) {
        this._isToolbarVisible(t)
          ? d(this.editor, e)
          : this._isToolbarInBalloon(t) ||
            (this._balloon.add({
              view: t.view,
              position: h(this.editor, e),
              balloonClassName: t.balloonClassName,
            }),
            this.listenTo(this._balloon, "change:visibleView", () => {
              for (const t of this._toolbarDefinitions.values())
                if (this._isToolbarVisible(t)) {
                  const e = t.getRelatedElement(
                    this.editor.editing.view.document.selection
                  );
                  d(this.editor, e);
                }
            }));
      }
      _isToolbarVisible(t) {
        return this._balloon.visibleView === t.view;
      }
      _isToolbarInBalloon(t) {
        return this._balloon.hasView(t.view);
      }
    }
    function d(t, e) {
      const n = t.plugins.get("ContextualBalloon"),
        i = h(t, e);
      n.updatePosition(i);
    }
    function h(t, e) {
      const n = t.editing.view,
        i = a.a.defaultPositions;
      return {
        target: n.domConverter.mapViewToDom(e),
        positions: [
          i.northArrowSouth,
          i.northArrowSouthWest,
          i.northArrowSouthEast,
          i.southArrowNorth,
          i.southArrowNorthWest,
          i.southArrowNorthEast,
          i.viewportStickyNorth,
        ],
      };
    }
    var f = n(61),
      m = n(18),
      g = n(37),
      p = n(14),
      b = n(6);
    class w {
      constructor(t) {
        this.set("activeHandlePosition", null),
          this.set("proposedWidthPercents", null),
          this.set("proposedWidth", null),
          this.set("proposedHeight", null),
          this.set("proposedHandleHostWidth", null),
          this.set("proposedHandleHostHeight", null),
          (this._options = t),
          (this._referenceCoordinates = null);
      }
      begin(t, e, n) {
        const i = new m.a(e);
        (this.activeHandlePosition = (function (t) {
          const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
          for (const n of e)
            if (t.classList.contains("ck-widget__resizer__handle-" + n))
              return n;
        })(t)),
          (this._referenceCoordinates = (function (t, e) {
            const n = new m.a(t),
              i = e.split("-"),
              s = {
                x: "right" == i[1] ? n.right : n.left,
                y: "bottom" == i[0] ? n.bottom : n.top,
              };
            return (
              (s.x += t.ownerDocument.defaultView.scrollX),
              (s.y += t.ownerDocument.defaultView.scrollY),
              s
            );
          })(
            e,
            (function (t) {
              const e = t.split("-"),
                n = {
                  top: "bottom",
                  bottom: "top",
                  left: "right",
                  right: "left",
                };
              return `${n[e[0]]}-${n[e[1]]}`;
            })(this.activeHandlePosition)
          )),
          (this.originalWidth = i.width),
          (this.originalHeight = i.height),
          (this.aspectRatio = i.width / i.height);
        const s = n.style.width;
        s && s.match(/^\d+(\.\d*)?%$/)
          ? (this.originalWidthPercents = parseFloat(s))
          : (this.originalWidthPercents = (function (t, e) {
              const n = t.parentElement,
                i = parseFloat(
                  n.ownerDocument.defaultView.getComputedStyle(n).width
                );
              return (e.width / i) * 100;
            })(n, i));
      }
      update(t) {
        (this.proposedWidth = t.width),
          (this.proposedHeight = t.height),
          (this.proposedWidthPercents = t.widthPercents),
          (this.proposedHandleHostWidth = t.handleHostWidth),
          (this.proposedHandleHostHeight = t.handleHostHeight);
      }
    }
    Object(b.default)(w, p.default);
    var v = n(8);
    class _ extends v.a {
      constructor() {
        super();
        const t = this.bindTemplate;
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-size-view",
              t.to("_viewPosition", (t) => (t ? "ck-orientation-" + t : "")),
            ],
            style: { display: t.if("_isVisible", "none", (t) => !t) },
          },
          children: [{ text: t.to("_label") }],
        });
      }
      _bindToState(t, e) {
        this.bind("_isVisible").to(
          e,
          "proposedWidth",
          e,
          "proposedHeight",
          (t, e) => null !== t && null !== e
        ),
          this.bind("_label").to(
            e,
            "proposedHandleHostWidth",
            e,
            "proposedHandleHostHeight",
            e,
            "proposedWidthPercents",
            (e, n, i) => ("px" === t.unit ? `${e}×${n}` : i + "%")
          ),
          this.bind("_viewPosition").to(
            e,
            "activeHandlePosition",
            e,
            "proposedHandleHostWidth",
            e,
            "proposedHandleHostHeight",
            (t, e, n) => (e < 50 || n < 50 ? "above-center" : t)
          );
      }
      _dismiss() {
        this.unbind(), (this._isVisible = !1);
      }
    }
    class y {
      constructor(t) {
        (this._options = t),
          (this._viewResizerWrapper = null),
          this.set("isEnabled", !0),
          this.decorate("begin"),
          this.decorate("cancel"),
          this.decorate("commit"),
          this.decorate("updateSize"),
          this.on(
            "commit",
            (t) => {
              this.state.proposedWidth ||
                this.state.proposedWidthPercents ||
                (this._cleanup(), t.stop());
            },
            { priority: "high" }
          ),
          this.on("change:isEnabled", () => {
            this.isEnabled && this.redraw();
          });
      }
      attach() {
        const t = this,
          e = this._options.viewElement;
        this._options.editor.editing.view.change((n) => {
          const i = n.createUIElement(
            "div",
            { class: "ck ck-reset_all ck-widget__resizer" },
            function (e) {
              const n = this.toDomElement(e);
              return (
                t._appendHandles(n),
                t._appendSizeUI(n),
                t.on("change:isEnabled", (t, e, i) => {
                  n.style.display = i ? "" : "none";
                }),
                (n.style.display = t.isEnabled ? "" : "none"),
                n
              );
            }
          );
          n.insert(n.createPositionAt(e, "end"), i),
            n.addClass("ck-widget_with-resizer", e),
            (this._viewResizerWrapper = i);
        });
      }
      begin(t) {
        (this.state = new w(this._options)),
          this._sizeView._bindToState(this._options, this.state),
          (this._initialViewWidth =
            this._options.viewElement.getStyle("width")),
          this.state.begin(t, this._getHandleHost(), this._getResizeHost());
      }
      updateSize(t) {
        const e = this._proposeNewSize(t);
        this._options.editor.editing.view.change((t) => {
          const n = this._options.unit || "%",
            i = ("%" === n ? e.widthPercents : e.width) + n;
          t.setStyle("width", i, this._options.viewElement);
        });
        const n = this._getHandleHost(),
          i = new m.a(n);
        (e.handleHostWidth = Math.round(i.width)),
          (e.handleHostHeight = Math.round(i.height));
        const s = new m.a(n);
        (e.width = Math.round(s.width)),
          (e.height = Math.round(s.height)),
          this.redraw(i),
          this.state.update(e);
      }
      commit() {
        const t = this._options.unit || "%",
          e =
            ("%" === t
              ? this.state.proposedWidthPercents
              : this.state.proposedWidth) + t;
        this._options.editor.editing.view.change(() => {
          this._cleanup(), this._options.onCommit(e);
        });
      }
      cancel() {
        this._cleanup();
      }
      destroy() {
        this.cancel();
      }
      redraw(t) {
        const e = this._domResizerWrapper;
        if (!((n = e) && n.ownerDocument && n.ownerDocument.contains(n)))
          return;
        var n;
        const i = e.parentElement,
          s = this._getHandleHost(),
          o = this._viewResizerWrapper,
          r = [
            o.getStyle("width"),
            o.getStyle("height"),
            o.getStyle("left"),
            o.getStyle("top"),
          ];
        let a;
        if (i.isSameNode(s)) {
          const e = t || new m.a(s);
          a = [e.width + "px", e.height + "px", void 0, void 0];
        } else
          a = [
            s.offsetWidth + "px",
            s.offsetHeight + "px",
            s.offsetLeft + "px",
            s.offsetTop + "px",
          ];
        "same" !== Object(g.a)(r, a) &&
          this._options.editor.editing.view.change((t) => {
            t.setStyle({ width: a[0], height: a[1], left: a[2], top: a[3] }, o);
          });
      }
      containsHandle(t) {
        return this._domResizerWrapper.contains(t);
      }
      static isResizeHandle(t) {
        return t.classList.contains("ck-widget__resizer__handle");
      }
      _cleanup() {
        this._sizeView._dismiss();
        this._options.editor.editing.view.change((t) => {
          t.setStyle(
            "width",
            this._initialViewWidth,
            this._options.viewElement
          );
        });
      }
      _proposeNewSize(t) {
        const e = this.state,
          n = { x: (i = t).pageX, y: i.pageY };
        var i;
        const s = !this._options.isCentered || this._options.isCentered(this),
          o = {
            x: e._referenceCoordinates.x - (n.x + e.originalWidth),
            y: n.y - e.originalHeight - e._referenceCoordinates.y,
          };
        s &&
          e.activeHandlePosition.endsWith("-right") &&
          (o.x = n.x - (e._referenceCoordinates.x + e.originalWidth)),
          s && (o.x *= 2);
        const r = {
          width: Math.abs(e.originalWidth + o.x),
          height: Math.abs(e.originalHeight + o.y),
        };
        (r.dominant = r.width / e.aspectRatio > r.height ? "width" : "height"),
          (r.max = r[r.dominant]);
        const a = { width: r.width, height: r.height };
        return (
          "width" == r.dominant
            ? (a.height = a.width / e.aspectRatio)
            : (a.width = a.height * e.aspectRatio),
          {
            width: Math.round(a.width),
            height: Math.round(a.height),
            widthPercents: Math.min(
              Math.round(
                (e.originalWidthPercents / e.originalWidth) * a.width * 100
              ) / 100,
              100
            ),
          }
        );
      }
      _getResizeHost() {
        const t = this._domResizerWrapper.parentElement;
        return this._options.getResizeHost(t);
      }
      _getHandleHost() {
        const t = this._domResizerWrapper.parentElement;
        return this._options.getHandleHost(t);
      }
      get _domResizerWrapper() {
        return this._options.editor.editing.view.domConverter.mapViewToDom(
          this._viewResizerWrapper
        );
      }
      _appendHandles(t) {
        const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
        for (const i of e)
          t.appendChild(
            new f.a({
              tag: "div",
              attributes: {
                class:
                  "ck-widget__resizer__handle " +
                  ((n = i), "ck-widget__resizer__handle-" + n),
              },
            }).render()
          );
        var n;
      }
      _appendSizeUI(t) {
        (this._sizeView = new _()),
          this._sizeView.render(),
          t.appendChild(this._sizeView.element);
      }
    }
    Object(b.default)(y, p.default);
    var k = n(72),
      A = n(27),
      C = n(129),
      E = n(326);
    n(358);
    class O extends s.a {
      static get pluginName() {
        return "WidgetResize";
      }
      init() {
        const t = this.editor.editing,
          e = A.a.window.document;
        this.set("visibleResizer", null),
          this.set("_activeResizer", null),
          (this._resizers = new Map()),
          t.view.addObserver(C.a),
          (this._observer = Object.create(k.a)),
          this.listenTo(
            t.view.document,
            "mousedown",
            this._mouseDownListener.bind(this),
            { priority: "high" }
          ),
          this._observer.listenTo(
            e,
            "mousemove",
            this._mouseMoveListener.bind(this)
          ),
          this._observer.listenTo(
            e,
            "mouseup",
            this._mouseUpListener.bind(this)
          );
        const n = () => {
          this.visibleResizer && this.visibleResizer.redraw();
        };
        (this._redrawFocusedResizerThrottled = Object(E.a)(n, 200)),
          this.on("change:visibleResizer", n),
          this.editor.ui.on("update", this._redrawFocusedResizerThrottled),
          this.editor.model.document.on(
            "change",
            () => {
              for (const [t, e] of this._resizers)
                t.isAttached() || (this._resizers.delete(t), e.destroy());
            },
            { priority: "lowest" }
          ),
          this._observer.listenTo(
            A.a.window,
            "resize",
            this._redrawFocusedResizerThrottled
          );
        const i = this.editor.editing.view.document.selection;
        i.on("change", () => {
          const t = i.getSelectedElement();
          this.visibleResizer = this.getResizerByViewElement(t) || null;
        });
      }
      destroy() {
        this._observer.stopListening();
        for (const t of this._resizers.values()) t.destroy();
        this._redrawFocusedResizerThrottled.cancel();
      }
      attachTo(t) {
        const e = new y(t),
          n = this.editor.plugins;
        if ((e.attach(), n.has("WidgetToolbarRepository"))) {
          const t = n.get("WidgetToolbarRepository");
          e.on(
            "begin",
            () => {
              t.forceDisabled("resize");
            },
            { priority: "lowest" }
          ),
            e.on(
              "cancel",
              () => {
                t.clearForceDisabled("resize");
              },
              { priority: "highest" }
            ),
            e.on(
              "commit",
              () => {
                t.clearForceDisabled("resize");
              },
              { priority: "highest" }
            );
        }
        this._resizers.set(t.viewElement, e);
        const i =
          this.editor.editing.view.document.selection.getSelectedElement();
        return (
          this.getResizerByViewElement(i) == e && (this.visibleResizer = e), e
        );
      }
      getResizerByViewElement(t) {
        return this._resizers.get(t);
      }
      _getResizerByHandle(t) {
        for (const e of this._resizers.values())
          if (e.containsHandle(t)) return e;
      }
      _mouseDownListener(t, e) {
        const n = e.domTarget;
        y.isResizeHandle(n) &&
          ((this._activeResizer = this._getResizerByHandle(n)),
          this._activeResizer &&
            (this._activeResizer.begin(n), t.stop(), e.preventDefault()));
      }
      _mouseMoveListener(t, e) {
        this._activeResizer && this._activeResizer.updateSize(e);
      }
      _mouseUpListener() {
        this._activeResizer &&
          (this._activeResizer.commit(), (this._activeResizer = null));
      }
    }
    Object(b.default)(O, p.default);
    n(234);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return c;
    });
    var i = n(88),
      s = n(91),
      o = n(26),
      r = n(60),
      a = n(39);
    class c extends i.a {
      constructor(t, e, n) {
        super(e),
          (this.name = t),
          (this._children = new s.a()),
          n && this._insertChild(0, n);
      }
      get childCount() {
        return this._children.length;
      }
      get maxOffset() {
        return this._children.maxOffset;
      }
      get isEmpty() {
        return 0 === this.childCount;
      }
      is(t, e = null) {
        return e
          ? e === this.name && ("element" === t || "model:element" === t)
          : "element" === t ||
              "model:element" === t ||
              "node" === t ||
              "model:node" === t;
      }
      getChild(t) {
        return this._children.getNode(t);
      }
      getChildren() {
        return this._children[Symbol.iterator]();
      }
      getChildIndex(t) {
        return this._children.getNodeIndex(t);
      }
      getChildStartOffset(t) {
        return this._children.getNodeStartOffset(t);
      }
      offsetToIndex(t) {
        return this._children.offsetToIndex(t);
      }
      getNodeByPath(t) {
        let e = this;
        for (const n of t) e = e.getChild(e.offsetToIndex(n));
        return e;
      }
      findAncestor(t, e = { includeSelf: !1 }) {
        let n = e.includeSelf ? this : this.parent;
        for (; n; ) {
          if (n.name === t) return n;
          n = n.parent;
        }
        return null;
      }
      toJSON() {
        const t = super.toJSON();
        if (((t.name = this.name), this._children.length > 0)) {
          t.children = [];
          for (const e of this._children) t.children.push(e.toJSON());
        }
        return t;
      }
      _clone(t = !1) {
        const e = t
          ? Array.from(this._children).map((t) => t._clone(!0))
          : null;
        return new c(this.name, this.getAttributes(), e);
      }
      _appendChild(t) {
        this._insertChild(this.childCount, t);
      }
      _insertChild(t, e) {
        const n = (function (t) {
          if ("string" == typeof t) return [new o.a(t)];
          Object(a.a)(t) || (t = [t]);
          return Array.from(t).map((t) =>
            "string" == typeof t
              ? new o.a(t)
              : t instanceof r.a
              ? new o.a(t.data, t.getAttributes())
              : t
          );
        })(e);
        for (const t of n) null !== t.parent && t._remove(), (t.parent = this);
        this._children._insertNodes(t, n);
      }
      _removeChildren(t, e = 1) {
        const n = this._children._removeNodes(t, e);
        for (const t of n) t.parent = null;
        return n;
      }
      static fromJSON(t) {
        let e = null;
        if (t.children) {
          e = [];
          for (const n of t.children)
            n.name ? e.push(c.fromJSON(n)) : e.push(o.a.fromJSON(n));
        }
        return new c(t.name, t.attributes, e);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    const i = navigator.userAgent.toLowerCase(),
      s = {
        isMac: o(i),
        isWindows: (function (t) {
          return t.indexOf("windows") > -1;
        })(i),
        isGecko: (function (t) {
          return !!t.match(/gecko\/\d+/);
        })(i),
        isSafari: (function (t) {
          return t.indexOf(" applewebkit/") > -1 && -1 === t.indexOf("chrome");
        })(i),
        isiOS: (function (t) {
          return (
            !!t.match(/iphone|ipad/i) || (o(t) && navigator.maxTouchPoints > 0)
          );
        })(i),
        isAndroid: (function (t) {
          return t.indexOf("android") > -1;
        })(i),
        isBlink: (function (t) {
          return t.indexOf("chrome/") > -1 && t.indexOf("edge/") < 0;
        })(i),
        features: {
          isRegExpUnicodePropertySupported: (function () {
            let t = !1;
            try {
              t = 0 === "ć".search(new RegExp("[\\p{L}]", "u"));
            } catch (t) {}
            return t;
          })(),
        },
      };
    function o(t) {
      return t.indexOf("macintosh") > -1;
    }
    e.a = s;
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "e", function () {
      return o;
    }),
      n.d(e, "d", function () {
        return r;
      }),
      n.d(e, "a", function () {
        return a;
      }),
      n.d(e, "c", function () {
        return c;
      }),
      n.d(e, "b", function () {
        return l;
      }),
      n.d(e, "i", function () {
        return u;
      }),
      n.d(e, "h", function () {
        return d;
      }),
      n.d(e, "f", function () {
        return h;
      }),
      n.d(e, "g", function () {
        return f;
      });
    var i = n(12),
      s = n(42);
    const o = (t) => t.createTextNode(" "),
      r = (t) => {
        const e = t.createElement("span");
        return (e.dataset.ckeFiller = !0), (e.innerHTML = " "), e;
      },
      a = (t) => {
        const e = t.createElement("br");
        return (e.dataset.ckeFiller = !0), e;
      },
      c = 7,
      l = "⁠".repeat(c);
    function u(t) {
      return Object(s.a)(t) && t.data.substr(0, c) === l;
    }
    function d(t) {
      return t.data.length == c && u(t);
    }
    function h(t) {
      return u(t) ? t.data.slice(c) : t.data;
    }
    function f(t) {
      t.document.on("arrowKey", m, { priority: "low" });
    }
    function m(t, e) {
      if (e.keyCode == i.f.arrowleft) {
        const t = e.domTarget.ownerDocument.defaultView.getSelection();
        if (1 == t.rangeCount && t.getRangeAt(0).collapsed) {
          const e = t.getRangeAt(0).startContainer,
            n = t.getRangeAt(0).startOffset;
          u(e) && n <= c && t.collapse(e, 0);
        }
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return l;
    });
    var i = n(40),
      s = n(5),
      o = n(3),
      r = n(0),
      a = n(37),
      c = n(57);
    class l extends i.a {
      constructor(t, e, n, i) {
        super(i),
          (this.sourcePosition = t.clone()),
          (this.sourcePosition.stickiness = "toNext"),
          (this.howMany = e),
          (this.targetPosition = n.clone()),
          (this.targetPosition.stickiness = "toNone");
      }
      get type() {
        return "$graveyard" == this.targetPosition.root.rootName
          ? "remove"
          : "$graveyard" == this.sourcePosition.root.rootName
          ? "reinsert"
          : "move";
      }
      clone() {
        return new this.constructor(
          this.sourcePosition,
          this.howMany,
          this.targetPosition,
          this.baseVersion
        );
      }
      getMovedRangeStart() {
        return this.targetPosition._getTransformedByDeletion(
          this.sourcePosition,
          this.howMany
        );
      }
      getReversed() {
        const t = this.sourcePosition._getTransformedByInsertion(
          this.targetPosition,
          this.howMany
        );
        return new this.constructor(
          this.getMovedRangeStart(),
          this.howMany,
          t,
          this.baseVersion + 1
        );
      }
      _validate() {
        const t = this.sourcePosition.parent,
          e = this.targetPosition.parent,
          n = this.sourcePosition.offset,
          i = this.targetPosition.offset;
        if (n + this.howMany > t.maxOffset)
          throw new r.default("move-operation-nodes-do-not-exist", this);
        if (t === e && n < i && i < n + this.howMany)
          throw new r.default("move-operation-range-into-itself", this);
        if (
          this.sourcePosition.root == this.targetPosition.root &&
          "prefix" ==
            Object(a.a)(
              this.sourcePosition.getParentPath(),
              this.targetPosition.getParentPath()
            )
        ) {
          const t = this.sourcePosition.path.length - 1;
          if (
            this.targetPosition.path[t] >= n &&
            this.targetPosition.path[t] < n + this.howMany
          )
            throw new r.default("move-operation-node-into-itself", this);
        }
      }
      _execute() {
        Object(c.b)(
          o.a._createFromPositionAndShift(this.sourcePosition, this.howMany),
          this.targetPosition
        );
      }
      toJSON() {
        const t = super.toJSON();
        return (
          (t.sourcePosition = this.sourcePosition.toJSON()),
          (t.targetPosition = this.targetPosition.toJSON()),
          t
        );
      }
      static get className() {
        return "MoveOperation";
      }
      static fromJSON(t, e) {
        const n = s.a.fromJSON(t.sourcePosition, e),
          i = s.a.fromJSON(t.targetPosition, e);
        return new this(n, t.howMany, i, t.baseVersion);
      }
    }
  },
  ,
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(79);
    class s extends i.a {
      constructor(t, e) {
        super(t), (this._textData = e);
      }
      is(t) {
        return (
          "$text" === t ||
          "view:$text" === t ||
          "text" === t ||
          "view:text" === t ||
          "node" === t ||
          "view:node" === t
        );
      }
      get data() {
        return this._textData;
      }
      get _data() {
        return this.data;
      }
      set _data(t) {
        this._fireChange("text", this), (this._textData = t);
      }
      isSimilar(t) {
        return t instanceof s && (this === t || this.data === t.data);
      }
      _clone() {
        return new s(this.document, this.data);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(88);
    class s extends i.a {
      constructor(t, e) {
        super(e), (this._data = t || "");
      }
      get offsetSize() {
        return this.data.length;
      }
      get data() {
        return this._data;
      }
      is(t) {
        return (
          "$text" === t ||
          "model:$text" === t ||
          "text" === t ||
          "model:text" === t ||
          "node" === t ||
          "model:node" === t
        );
      }
      toJSON() {
        const t = super.toJSON();
        return (t.data = this.data), t;
      }
      _clone() {
        return new s(this.data, this.getAttributes());
      }
      static fromJSON(t) {
        return new s(t.data, t.attributes);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    e.a = { window: window, document: document };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return f;
    }),
      n.d(e, "d", function () {
        return m;
      }),
      n.d(e, "f", function () {
        return g;
      }),
      n.d(e, "e", function () {
        return w;
      }),
      n.d(e, "c", function () {
        return v;
      }),
      n.d(e, "g", function () {
        return _;
      }),
      n.d(e, "b", function () {
        return y;
      }),
      n.d(e, "h", function () {
        return k;
      });
    var i = n(0),
      s = n(35),
      o = n(11),
      r = n(6);
    class a {
      constructor() {
        this._stack = [];
      }
      add(t, e) {
        const n = this._stack,
          i = n[0];
        this._insertDescriptor(t);
        const s = n[0];
        i === s ||
          c(i, s) ||
          this.fire("change:top", {
            oldDescriptor: i,
            newDescriptor: s,
            writer: e,
          });
      }
      remove(t, e) {
        const n = this._stack,
          i = n[0];
        this._removeDescriptor(t);
        const s = n[0];
        i === s ||
          c(i, s) ||
          this.fire("change:top", {
            oldDescriptor: i,
            newDescriptor: s,
            writer: e,
          });
      }
      _insertDescriptor(t) {
        const e = this._stack,
          n = e.findIndex((e) => e.id === t.id);
        if (c(t, e[n])) return;
        n > -1 && e.splice(n, 1);
        let i = 0;
        for (; e[i] && l(e[i], t); ) i++;
        e.splice(i, 0, t);
      }
      _removeDescriptor(t) {
        const e = this._stack,
          n = e.findIndex((e) => e.id === t);
        n > -1 && e.splice(n, 1);
      }
    }
    function c(t, e) {
      return t && e && t.priority == e.priority && u(t.classes) == u(e.classes);
    }
    function l(t, e) {
      return (
        t.priority > e.priority ||
        (!(t.priority < e.priority) && u(t.classes) > u(e.classes))
      );
    }
    function u(t) {
      return Array.isArray(t) ? t.sort().join(",") : t;
    }
    Object(r.default)(a, o.default);
    var d = n(32),
      h = n(114);
    const f = "ck-widget_selected";
    function m(t) {
      return !!t.is("element") && !!t.getCustomProperty("widget");
    }
    function g(t, e, n = {}) {
      if (!t.is("containerElement"))
        throw new i.default("widget-to-widget-wrong-element-type", null, {
          element: t,
        });
      return (
        e.setAttribute("contenteditable", "false", t),
        e.addClass("ck-widget", t),
        e.setCustomProperty("widget", !0, t),
        (t.getFillerOffset = A),
        n.label &&
          (function (t, e, n) {
            n.setCustomProperty("widgetLabel", e, t);
          })(t, n.label, e),
        n.hasSelectionHandle &&
          (function (t, e) {
            const n = e.createUIElement(
              "div",
              { class: "ck ck-widget__selection-handle" },
              function (t) {
                const e = this.toDomElement(t),
                  n = new h.a();
                return (
                  n.set(
                    "content",
                    '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>'
                  ),
                  n.render(),
                  e.appendChild(n.element),
                  e
                );
              }
            );
            e.insert(e.createPositionAt(t, 0), n),
              e.addClass(["ck-widget_with-selection-handle"], t);
          })(t, e),
        w(t, e),
        t
      );
    }
    function p(t, e, n) {
      if ((e.classes && n.addClass(Object(s.a)(e.classes), t), e.attributes))
        for (const i in e.attributes) n.setAttribute(i, e.attributes[i], t);
    }
    function b(t, e, n) {
      if ((e.classes && n.removeClass(Object(s.a)(e.classes), t), e.attributes))
        for (const i in e.attributes) n.removeAttribute(i, t);
    }
    function w(t, e, n = p, i = b) {
      const s = new a();
      s.on("change:top", (e, s) => {
        s.oldDescriptor && i(t, s.oldDescriptor, s.writer),
          s.newDescriptor && n(t, s.newDescriptor, s.writer);
      }),
        e.setCustomProperty("addHighlight", (t, e, n) => s.add(e, n), t),
        e.setCustomProperty("removeHighlight", (t, e, n) => s.remove(e, n), t);
    }
    function v(t) {
      const e = t.getCustomProperty("widgetLabel");
      return e ? ("function" == typeof e ? e() : e) : "";
    }
    function _(t, e) {
      return (
        e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t),
        e.setAttribute("contenteditable", t.isReadOnly ? "false" : "true", t),
        t.on("change:isReadOnly", (n, i, s) => {
          e.setAttribute("contenteditable", s ? "false" : "true", t);
        }),
        t.on("change:isFocused", (n, i, s) => {
          s
            ? e.addClass("ck-editor__nested-editable_focused", t)
            : e.removeClass("ck-editor__nested-editable_focused", t);
        }),
        w(t, e),
        t
      );
    }
    function y(t, e) {
      const n = t.getSelectedElement();
      if (n) {
        const i = Object(d.e)(t);
        if (i) return e.createRange(e.createPositionAt(n, i));
        if (e.schema.isObject(n) && !e.schema.isInline(n))
          return e.createRangeOn(n);
      }
      const i = t.getSelectedBlocks().next().value;
      if (i) {
        if (i.isEmpty) return e.createRange(e.createPositionAt(i, 0));
        const n = e.createPositionAfter(i);
        return t.focus.isTouching(n)
          ? e.createRange(n)
          : e.createRange(e.createPositionBefore(i));
      }
      return e.createRange(t.focus);
    }
    function k(t, e) {
      return (n, i) => {
        const { mapper: s, viewPosition: o } = i,
          r = s.findMappedViewAncestor(o);
        if (!e(r)) return;
        const a = s.toModelElement(r);
        i.modelPosition = t.createPositionAt(
          a,
          o.isAtStart ? "before" : "after"
        );
      };
    }
    function A() {
      return null;
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return l;
    });
    var i = n(40),
      s = n(36),
      o = n(5),
      r = n(3),
      a = n(57),
      c = n(0);
    class l extends i.a {
      constructor(t, e, n, i, s) {
        super(s),
          (this.splitPosition = t.clone()),
          (this.splitPosition.stickiness = "toNext"),
          (this.howMany = e),
          (this.insertionPosition = n),
          (this.graveyardPosition = i ? i.clone() : null),
          this.graveyardPosition &&
            (this.graveyardPosition.stickiness = "toNext");
      }
      get type() {
        return "split";
      }
      get moveTargetPosition() {
        const t = this.insertionPosition.path.slice();
        return t.push(0), new o.a(this.insertionPosition.root, t);
      }
      get movedRange() {
        const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
        return new r.a(this.splitPosition, t);
      }
      clone() {
        return new this.constructor(
          this.splitPosition,
          this.howMany,
          this.insertionPosition,
          this.graveyardPosition,
          this.baseVersion
        );
      }
      getReversed() {
        const t = this.splitPosition.root.document.graveyard,
          e = new o.a(t, [0]);
        return new s.a(
          this.moveTargetPosition,
          this.howMany,
          this.splitPosition,
          e,
          this.baseVersion + 1
        );
      }
      _validate() {
        const t = this.splitPosition.parent,
          e = this.splitPosition.offset;
        if (!t || t.maxOffset < e)
          throw new c.default("split-operation-position-invalid", this);
        if (!t.parent)
          throw new c.default("split-operation-split-in-root", this);
        if (this.howMany != t.maxOffset - this.splitPosition.offset)
          throw new c.default("split-operation-how-many-invalid", this);
        if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
          throw new c.default(
            "split-operation-graveyard-position-invalid",
            this
          );
      }
      _execute() {
        const t = this.splitPosition.parent;
        if (this.graveyardPosition)
          Object(a.b)(
            r.a._createFromPositionAndShift(this.graveyardPosition, 1),
            this.insertionPosition
          );
        else {
          const e = t._clone();
          Object(a.a)(this.insertionPosition, e);
        }
        const e = new r.a(
          o.a._createAt(t, this.splitPosition.offset),
          o.a._createAt(t, t.maxOffset)
        );
        Object(a.b)(e, this.moveTargetPosition);
      }
      toJSON() {
        const t = super.toJSON();
        return (
          (t.splitPosition = this.splitPosition.toJSON()),
          (t.insertionPosition = this.insertionPosition.toJSON()),
          this.graveyardPosition &&
            (t.graveyardPosition = this.graveyardPosition.toJSON()),
          t
        );
      }
      static get className() {
        return "SplitOperation";
      }
      static getInsertionPosition(t) {
        const e = t.path.slice(0, -1);
        return e[e.length - 1]++, new o.a(t.root, e, "toPrevious");
      }
      static fromJSON(t, e) {
        const n = o.a.fromJSON(t.splitPosition, e),
          i = o.a.fromJSON(t.insertionPosition, e),
          s = t.graveyardPosition ? o.a.fromJSON(t.graveyardPosition, e) : null;
        return new this(n, t.howMany, i, s, t.baseVersion);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    e.a = function (t) {
      var e = typeof t;
      return null != t && ("object" == e || "function" == e);
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "c", function () {
      return o;
    }),
      n.d(e, "e", function () {
        return r;
      }),
      n.d(e, "i", function () {
        return a;
      }),
      n.d(e, "d", function () {
        return c;
      }),
      n.d(e, "j", function () {
        return l;
      }),
      n.d(e, "k", function () {
        return u;
      }),
      n.d(e, "f", function () {
        return d;
      }),
      n.d(e, "g", function () {
        return h;
      }),
      n.d(e, "h", function () {
        return f;
      }),
      n.d(e, "b", function () {
        return m;
      }),
      n.d(e, "a", function () {
        return g;
      });
    var i = n(16),
      s = n(17);
    function o(t, e, n) {
      const { startRow: o, startColumn: r, endRow: a, endColumn: c } = e,
        l = n.createElement("table"),
        d = a - o + 1;
      for (let t = 0; t < d; t++) n.insertElement("tableRow", l, "end");
      const h = [
        ...new i.a(t, {
          startRow: o,
          endRow: a,
          startColumn: r,
          endColumn: c,
          includeAllSlots: !0,
        }),
      ];
      for (const {
        row: t,
        column: e,
        cell: i,
        isAnchor: d,
        cellAnchorRow: f,
        cellAnchorColumn: m,
      } of h) {
        const h = t - o,
          g = l.getChild(h);
        if (d) {
          const s = n.cloneElement(i);
          n.append(s, g), u(s, t, e, a, c, n);
        } else (f < o || m < r) && Object(s.a)(n, n.createPositionAt(g, "end"));
      }
      return (
        (function (t, e, n, i, o) {
          const r = parseInt(e.getAttribute("headingRows") || 0);
          if (r > 0) {
            const e = r - n;
            Object(s.c)("headingRows", e, t, o, 0);
          }
          const a = parseInt(e.getAttribute("headingColumns") || 0);
          if (a > 0) {
            const e = a - i;
            Object(s.c)("headingColumns", e, t, o, 0);
          }
        })(l, t, o, r, n),
        l
      );
    }
    function r(t, e, n = 0) {
      const s = [],
        o = new i.a(t, { startRow: n, endRow: e - 1 });
      for (const t of o) {
        const { row: n, cellHeight: i } = t,
          o = n + i - 1;
        n < e && e <= o && s.push(t);
      }
      return s;
    }
    function a(t, e, n) {
      const o = t.parent,
        r = o.parent,
        a = o.index,
        c = e - a,
        l = {},
        u = parseInt(t.getAttribute("rowspan")) - c;
      u > 1 && (l.rowspan = u);
      const d = parseInt(t.getAttribute("colspan") || 1);
      d > 1 && (l.colspan = d);
      const h = a,
        f = h + c,
        m = [...new i.a(r, { startRow: h, endRow: f, includeAllSlots: !0 })];
      let g,
        p = null;
      for (const e of m) {
        const { row: i, column: o, cell: r } = e;
        r === t && void 0 === g && (g = o),
          void 0 !== g &&
            g === o &&
            i === f &&
            (p = Object(s.a)(n, e.getPositionBefore(), l));
      }
      return Object(s.c)("rowspan", c, t, n), p;
    }
    function c(t, e) {
      const n = [],
        s = new i.a(t);
      for (const t of s) {
        const { column: i, cellWidth: s } = t,
          o = i + s - 1;
        i < e && e <= o && n.push(t);
      }
      return n;
    }
    function l(t, e, n, i) {
      const o = n - e,
        r = {},
        a = parseInt(t.getAttribute("colspan")) - o;
      a > 1 && (r.colspan = a);
      const c = parseInt(t.getAttribute("rowspan") || 1);
      c > 1 && (r.rowspan = c);
      const l = Object(s.a)(i, i.createPositionAfter(t), r);
      return Object(s.c)("colspan", o, t, i), l;
    }
    function u(t, e, n, i, o, r) {
      const a = parseInt(t.getAttribute("colspan") || 1),
        c = parseInt(t.getAttribute("rowspan") || 1);
      if (n + a - 1 > o) {
        const e = o - n + 1;
        Object(s.c)("colspan", e, t, r, 1);
      }
      if (e + c - 1 > i) {
        const n = i - e + 1;
        Object(s.c)("rowspan", n, t, r, 1);
      }
    }
    function d(t, e) {
      const n = e.getColumns(t),
        s = new Array(n).fill(0);
      for (const { column: e } of new i.a(t)) s[e]++;
      const o = s.reduce((t, e, n) => (e ? t : [...t, n]), []);
      if (o.length > 0) {
        const n = o[o.length - 1];
        return e.removeColumns(t, { at: n }), !0;
      }
      return !1;
    }
    function h(t, e) {
      const n = [],
        i = e.getRows(t);
      for (let e = 0; e < i; e++) {
        t.getChild(e).isEmpty && n.push(e);
      }
      if (n.length > 0) {
        const i = n[n.length - 1];
        return e.removeRows(t, { at: i }), !0;
      }
      return !1;
    }
    function f(t, e) {
      d(t, e) || h(t, e);
    }
    function m(t, e) {
      const n = Array.from(
        new i.a(t, {
          startColumn: e.firstColumn,
          endColumn: e.lastColumn,
          row: e.lastRow,
        })
      );
      if (n.every(({ cellHeight: t }) => 1 === t)) return e.lastRow;
      const s = n[0].cellHeight - 1;
      return e.lastRow + s;
    }
    function g(t, e) {
      const n = Array.from(
        new i.a(t, {
          startRow: e.firstRow,
          endRow: e.lastRow,
          column: e.lastColumn,
        })
      );
      if (n.every(({ cellWidth: t }) => 1 === t)) return e.lastColumn;
      const s = n[0].cellWidth - 1;
      return e.lastColumn + s;
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    }),
      n.d(e, "f", function () {
        return o;
      }),
      n.d(e, "b", function () {
        return r;
      }),
      n.d(e, "d", function () {
        return a;
      }),
      n.d(e, "c", function () {
        return c;
      }),
      n.d(e, "e", function () {
        return l;
      });
    var i = n(28);
    const s = "widget-type-around";
    function o(t, e, n) {
      return t && Object(i.d)(t) && !n.isInline(e);
    }
    function r(t) {
      return t.closest(".ck-widget__type-around__button");
    }
    function a(t) {
      return t.classList.contains("ck-widget__type-around__button_before")
        ? "before"
        : "after";
    }
    function c(t, e) {
      const n = t.closest(".ck-widget");
      return e.mapDomToView(n);
    }
    function l(t) {
      return t.getAttribute(s);
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "e", function () {
      return i.a;
    }),
      n.d(e, "b", function () {
        return s.a;
      }),
      n.d(e, "a", function () {
        return o.a;
      }),
      n.d(e, "c", function () {
        return r.a;
      }),
      n.d(e, "d", function () {
        return l;
      }),
      n.d(e, "h", function () {
        return p;
      }),
      n.d(e, "f", function () {
        return m;
      }),
      n.d(e, "g", function () {
        return b.a;
      });
    var i = n(294),
      s = n(231),
      o = n(128),
      r = n(235),
      a = n(9),
      c = n(12);
    class l extends a.a {
      static get pluginName() {
        return "TwoStepCaretMovement";
      }
      constructor(t) {
        super(t), (this.attributes = new Set()), (this._overrideUid = null);
      }
      init() {
        const t = this.editor,
          e = t.model,
          n = t.editing.view,
          i = t.locale,
          s = e.document.selection;
        this.listenTo(
          n.document,
          "arrowKey",
          (t, e) => {
            if (!s.isCollapsed) return;
            if (e.shiftKey || e.altKey || e.ctrlKey) return;
            const n = e.keyCode == c.f.arrowright,
              o = e.keyCode == c.f.arrowleft;
            if (!n && !o) return;
            const r = i.contentLanguageDirection;
            let a = !1;
            (a =
              ("ltr" === r && n) || ("rtl" === r && o)
                ? this._handleForwardMovement(e)
                : this._handleBackwardMovement(e)),
              !0 === a && t.stop();
          },
          { context: "$text", priority: "highest" }
        ),
          (this._isNextGravityRestorationSkipped = !1),
          this.listenTo(s, "change:range", (t, e) => {
            this._isNextGravityRestorationSkipped
              ? (this._isNextGravityRestorationSkipped = !1)
              : this._isGravityOverridden &&
                ((!e.directChange &&
                  f(s.getFirstPosition(), this.attributes)) ||
                  this._restoreGravity());
          });
      }
      registerAttribute(t) {
        this.attributes.add(t);
      }
      _handleForwardMovement(t) {
        const e = this.attributes,
          n = this.editor.model.document.selection,
          i = n.getFirstPosition();
        return (
          !this._isGravityOverridden &&
          (!i.isAtStart || !u(n, e)) &&
          (f(i, e) ? (h(t), this._overrideGravity(), !0) : void 0)
        );
      }
      _handleBackwardMovement(t) {
        const e = this.attributes,
          n = this.editor.model,
          i = n.document.selection,
          s = i.getFirstPosition();
        return this._isGravityOverridden
          ? (h(t), this._restoreGravity(), d(n, e, s), !0)
          : s.isAtStart
          ? !!u(i, e) && (h(t), d(n, e, s), !0)
          : (function (t, e) {
              return f(t.getShiftedBy(-1), e);
            })(s, e)
          ? s.isAtEnd && !u(i, e) && f(s, e)
            ? (h(t), d(n, e, s), !0)
            : ((this._isNextGravityRestorationSkipped = !0),
              this._overrideGravity(),
              !1)
          : void 0;
      }
      get _isGravityOverridden() {
        return !!this._overrideUid;
      }
      _overrideGravity() {
        this._overrideUid = this.editor.model.change((t) =>
          t.overrideSelectionGravity()
        );
      }
      _restoreGravity() {
        this.editor.model.change((t) => {
          t.restoreSelectionGravity(this._overrideUid),
            (this._overrideUid = null);
        });
      }
    }
    function u(t, e) {
      for (const n of e) if (t.hasAttribute(n)) return !0;
      return !1;
    }
    function d(t, e, n) {
      const i = n.nodeBefore;
      t.change((t) => {
        i
          ? t.setSelectionAttribute(i.getAttributes())
          : t.removeSelectionAttribute(e);
      });
    }
    function h(t) {
      t.preventDefault();
    }
    function f(t, e) {
      const { nodeBefore: n, nodeAfter: i } = t;
      for (const t of e) {
        const e = n ? n.getAttribute(t) : void 0;
        if ((i ? i.getAttribute(t) : void 0) !== e) return !0;
      }
      return !1;
    }
    n(241);
    function m(t, e, n, i) {
      return i.createRange(g(t, e, n, !0, i), g(t, e, n, !1, i));
    }
    function g(t, e, n, i, s) {
      let o = t.textNode || (i ? t.nodeBefore : t.nodeAfter),
        r = null;
      for (; o && o.getAttribute(e) == n; )
        (r = o), (o = i ? o.previousSibling : o.nextSibling);
      return r ? s.createPositionAt(r, i ? "before" : "after") : t;
    }
    function p(t, e, n, i) {
      const s = t.editing.view,
        o = new Set();
      s.document.registerPostFixer((s) => {
        const r = t.model.document.selection;
        let a = !1;
        if (r.hasAttribute(e)) {
          const c = m(r.getFirstPosition(), e, r.getAttribute(e), t.model),
            l = t.editing.mapper.toViewRange(c);
          for (const t of l.getItems())
            t.is("element", n) &&
              !t.hasClass(i) &&
              (s.addClass(i, t), o.add(t), (a = !0));
        }
        return a;
      }),
        t.conversion.for("editingDowncast").add((t) => {
          function e() {
            s.change((t) => {
              for (const e of o.values()) t.removeClass(i, e), o.delete(e);
            });
          }
          t.on("insert", e, { priority: "highest" }),
            t.on("remove", e, { priority: "highest" }),
            t.on("attribute", e, { priority: "highest" }),
            t.on("selection", e, { priority: "highest" });
        });
    }
    var b = n(236);
    n(164);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return c;
    });
    var i = n(8),
      s = n(114),
      o = n(193),
      r = n(44),
      a = n(12);
    n(332);
    class c extends i.a {
      constructor(t) {
        super(t);
        const e = this.bindTemplate,
          n = Object(r.a)();
        this.set("class"),
          this.set("labelStyle"),
          this.set("icon"),
          this.set("isEnabled", !0),
          this.set("isOn", !1),
          this.set("isVisible", !0),
          this.set("isToggleable", !1),
          this.set("keystroke"),
          this.set("label"),
          this.set("tabindex", -1),
          this.set("tooltip"),
          this.set("tooltipPosition", "s"),
          this.set("type", "button"),
          this.set("withText", !1),
          this.set("withKeystroke", !1),
          (this.children = this.createCollection()),
          (this.tooltipView = this._createTooltipView()),
          (this.labelView = this._createLabelView(n)),
          (this.iconView = new s.a()),
          this.iconView.extendTemplate({
            attributes: { class: "ck-button__icon" },
          }),
          (this.keystrokeView = this._createKeystrokeView()),
          this.bind("_tooltipString").to(
            this,
            "tooltip",
            this,
            "label",
            this,
            "keystroke",
            this._getTooltipString.bind(this)
          ),
          this.setTemplate({
            tag: "button",
            attributes: {
              class: [
                "ck",
                "ck-button",
                e.to("class"),
                e.if("isEnabled", "ck-disabled", (t) => !t),
                e.if("isVisible", "ck-hidden", (t) => !t),
                e.to("isOn", (t) => (t ? "ck-on" : "ck-off")),
                e.if("withText", "ck-button_with-text"),
                e.if("withKeystroke", "ck-button_with-keystroke"),
              ],
              type: e.to("type", (t) => t || "button"),
              tabindex: e.to("tabindex"),
              "aria-labelledby": "ck-editor__aria-label_" + n,
              "aria-disabled": e.if("isEnabled", !0, (t) => !t),
              "aria-pressed": e.to(
                "isOn",
                (t) => !!this.isToggleable && String(t)
              ),
            },
            children: this.children,
            on: {
              mousedown: e.to((t) => {
                t.preventDefault();
              }),
              click: e.to((t) => {
                this.isEnabled ? this.fire("execute") : t.preventDefault();
              }),
            },
          });
      }
      render() {
        super.render(),
          this.icon &&
            (this.iconView.bind("content").to(this, "icon"),
            this.children.add(this.iconView)),
          this.children.add(this.tooltipView),
          this.children.add(this.labelView),
          this.withKeystroke &&
            this.keystroke &&
            this.children.add(this.keystrokeView);
      }
      focus() {
        this.element.focus();
      }
      _createTooltipView() {
        const t = new o.a();
        return (
          t.bind("text").to(this, "_tooltipString"),
          t.bind("position").to(this, "tooltipPosition"),
          t
        );
      }
      _createLabelView(t) {
        const e = new i.a(),
          n = this.bindTemplate;
        return (
          e.setTemplate({
            tag: "span",
            attributes: {
              class: ["ck", "ck-button__label"],
              style: n.to("labelStyle"),
              id: "ck-editor__aria-label_" + t,
            },
            children: [{ text: this.bindTemplate.to("label") }],
          }),
          e
        );
      }
      _createKeystrokeView() {
        const t = new i.a();
        return (
          t.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-button__keystroke"] },
            children: [
              {
                text: this.bindTemplate.to("keystroke", (t) => Object(a.b)(t)),
              },
            ],
          }),
          t
        );
      }
      _getTooltipString(t, e, n) {
        return t
          ? "string" == typeof t
            ? t
            : (n && (n = Object(a.b)(n)),
              t instanceof Function ? t(e, n) : `${e}${n ? ` (${n})` : ""}`)
          : "";
      }
    }
  },
  function (t, e, n) {
    "use strict";
    function i(t) {
      return Array.isArray(t) ? t : [t];
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return l;
    });
    var i = n(40),
      s = n(29),
      o = n(5),
      r = n(3),
      a = n(57),
      c = n(0);
    class l extends i.a {
      constructor(t, e, n, i, s) {
        super(s),
          (this.sourcePosition = t.clone()),
          (this.sourcePosition.stickiness = "toPrevious"),
          (this.howMany = e),
          (this.targetPosition = n.clone()),
          (this.targetPosition.stickiness = "toNext"),
          (this.graveyardPosition = i.clone());
      }
      get type() {
        return "merge";
      }
      get deletionPosition() {
        return new o.a(
          this.sourcePosition.root,
          this.sourcePosition.path.slice(0, -1)
        );
      }
      get movedRange() {
        const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
        return new r.a(this.sourcePosition, t);
      }
      clone() {
        return new this.constructor(
          this.sourcePosition,
          this.howMany,
          this.targetPosition,
          this.graveyardPosition,
          this.baseVersion
        );
      }
      getReversed() {
        const t = this.targetPosition._getTransformedByMergeOperation(this),
          e = this.sourcePosition.path.slice(0, -1),
          n = new o.a(
            this.sourcePosition.root,
            e
          )._getTransformedByMergeOperation(this);
        return new s.a(
          t,
          this.howMany,
          n,
          this.graveyardPosition,
          this.baseVersion + 1
        );
      }
      _validate() {
        const t = this.sourcePosition.parent,
          e = this.targetPosition.parent;
        if (!t.parent)
          throw new c.default("merge-operation-source-position-invalid", this);
        if (!e.parent)
          throw new c.default("merge-operation-target-position-invalid", this);
        if (this.howMany != t.maxOffset)
          throw new c.default("merge-operation-how-many-invalid", this);
      }
      _execute() {
        const t = this.sourcePosition.parent,
          e = r.a._createIn(t);
        Object(a.b)(e, this.targetPosition),
          Object(a.b)(r.a._createOn(t), this.graveyardPosition);
      }
      toJSON() {
        const t = super.toJSON();
        return (
          (t.sourcePosition = t.sourcePosition.toJSON()),
          (t.targetPosition = t.targetPosition.toJSON()),
          (t.graveyardPosition = t.graveyardPosition.toJSON()),
          t
        );
      }
      static get className() {
        return "MergeOperation";
      }
      static fromJSON(t, e) {
        const n = o.a.fromJSON(t.sourcePosition, e),
          i = o.a.fromJSON(t.targetPosition, e),
          s = o.a.fromJSON(t.graveyardPosition, e);
        return new this(n, t.howMany, i, s, t.baseVersion);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    function i(t, e) {
      const n = Math.min(t.length, e.length);
      for (let i = 0; i < n; i++) if (t[i] != e[i]) return i;
      return t.length == e.length
        ? "same"
        : t.length < e.length
        ? "prefix"
        : "extension";
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    e.a = function (t) {
      return null != t && "object" == typeof t;
    };
  },
  function (t, e, n) {
    "use strict";
    function i(t) {
      return !(!t || !t[Symbol.iterator]);
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return i;
    });
    class i {
      constructor(t) {
        (this.baseVersion = t),
          (this.isDocumentOperation = null !== this.baseVersion),
          (this.batch = null);
      }
      _validate() {}
      toJSON() {
        const t = Object.assign({}, this);
        return (
          (t.__className = this.constructor.className),
          delete t.batch,
          delete t.isDocumentOperation,
          t
        );
      }
      static get className() {
        return "Operation";
      }
      static fromJSON(t) {
        return new this(t.baseVersion);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(205),
      s = "object" == typeof self && self && self.Object === Object && self,
      o = i.a || s || Function("return this")();
    e.a = o;
  },
  function (t, e, n) {
    "use strict";
    function i(t) {
      return "[object Text]" == Object.prototype.toString.call(t);
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return O;
    }),
      n.d(e, "f", function () {
        return P;
      }),
      n.d(e, "c", function () {
        return T;
      }),
      n.d(e, "d", function () {
        return x;
      }),
      n.d(e, "e", function () {
        return S;
      }),
      n.d(e, "h", function () {
        return I;
      }),
      n.d(e, "g", function () {
        return R;
      }),
      n.d(e, "b", function () {
        return j;
      }),
      n.d(e, "i", function () {
        return M;
      });
    var i = n(237);
    var s = function (t, e, n) {
        var s = t.length;
        return (
          (n = void 0 === n ? s : n), !e && n >= s ? t : Object(i.a)(t, e, n)
        );
      },
      o = RegExp(
        "[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"
      );
    var r = function (t) {
      return o.test(t);
    };
    var a = function (t) {
        return t.split("");
      },
      c = "[\\ud800-\\udfff]",
      l = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
      u = "\\ud83c[\\udffb-\\udfff]",
      d = "[^\\ud800-\\udfff]",
      h = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      f = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      m = "(?:" + l + "|" + u + ")" + "?",
      g =
        "[\\ufe0e\\ufe0f]?" +
        m +
        ("(?:\\u200d(?:" +
          [d, h, f].join("|") +
          ")[\\ufe0e\\ufe0f]?" +
          m +
          ")*"),
      p = "(?:" + [d + l + "?", l, h, f, c].join("|") + ")",
      b = RegExp(u + "(?=" + u + ")|" + p + g, "g");
    var w = function (t) {
      return t.match(b) || [];
    };
    var v = function (t) {
        return r(t) ? w(t) : a(t);
      },
      _ = n(166);
    var y = (function (t) {
      return function (e) {
        e = Object(_.a)(e);
        var n = r(e) ? v(e) : void 0,
          i = n ? n[0] : e.charAt(0),
          o = n ? s(n, 1).join("") : e.slice(1);
        return i[t]() + o;
      };
    })("toUpperCase");
    const k = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
      A = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i,
      C =
        /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i,
      E = /^((\w+:(\/{2,})?)|(\W))/i,
      O = "Ctrl+K";
    function P(t) {
      return t.is("attributeElement") && !!t.getCustomProperty("link");
    }
    function T(t, { writer: e }) {
      const n = e.createAttributeElement("a", { href: t }, { priority: 5 });
      return e.setCustomProperty("link", !0, n), n;
    }
    function x(t) {
      return (function (t) {
        return t.replace(k, "").match(A);
      })((t = String(t)))
        ? t
        : "#";
    }
    function S(t, e) {
      const n = {
        "Open in a new tab": t("Open in a new tab"),
        Downloadable: t("Downloadable"),
      };
      return (
        e.forEach((t) => (t.label && n[t.label] && (t.label = n[t.label]), t)),
        e
      );
    }
    function I(t) {
      const e = [];
      if (t)
        for (const [n, i] of Object.entries(t)) {
          const t = Object.assign({}, i, { id: "link" + y(n) });
          e.push(t);
        }
      return e;
    }
    function R(t, e) {
      return !!t && e.checkAttribute(t.name, "linkHref");
    }
    function j(t, e) {
      const n = ((i = t), C.test(i) ? "mailto:" : e);
      var i;
      const s = !!n && !E.test(t);
      return t && s ? n + t : t;
    }
    function M(t) {
      window.open(t, "_blank", "noopener");
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    const i = new Array(256)
      .fill()
      .map((t, e) => ("0" + e.toString(16)).slice(-2));
    function s() {
      const t = (4294967296 * Math.random()) >>> 0,
        e = (4294967296 * Math.random()) >>> 0,
        n = (4294967296 * Math.random()) >>> 0,
        s = (4294967296 * Math.random()) >>> 0;
      return (
        "e" +
        i[(t >> 0) & 255] +
        i[(t >> 8) & 255] +
        i[(t >> 16) & 255] +
        i[(t >> 24) & 255] +
        i[(e >> 0) & 255] +
        i[(e >> 8) & 255] +
        i[(e >> 16) & 255] +
        i[(e >> 24) & 255] +
        i[(n >> 0) & 255] +
        i[(n >> 8) & 255] +
        i[(n >> 16) & 255] +
        i[(n >> 24) & 255] +
        i[(s >> 0) & 255] +
        i[(s >> 8) & 255] +
        i[(s >> 16) & 255] +
        i[(s >> 24) & 255]
      );
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(14),
      s = n(6);
    class o {
      constructor(t) {
        (this.editor = t),
          this.set("value", void 0),
          this.set("isEnabled", !1),
          (this.affectsData = !0),
          (this._disableStack = new Set()),
          this.decorate("execute"),
          this.listenTo(this.editor.model.document, "change", () => {
            this.refresh();
          }),
          this.on(
            "execute",
            (t) => {
              this.isEnabled || t.stop();
            },
            { priority: "high" }
          ),
          this.listenTo(t, "change:isReadOnly", (t, e, n) => {
            n && this.affectsData
              ? this.forceDisabled("readOnlyMode")
              : this.clearForceDisabled("readOnlyMode");
          });
      }
      refresh() {
        this.isEnabled = !0;
      }
      forceDisabled(t) {
        this._disableStack.add(t),
          1 == this._disableStack.size &&
            (this.on("set:isEnabled", r, { priority: "highest" }),
            (this.isEnabled = !1));
      }
      clearForceDisabled(t) {
        this._disableStack.delete(t),
          0 == this._disableStack.size &&
            (this.off("set:isEnabled", r), this.refresh());
      }
      execute() {}
      destroy() {
        this.stopListening();
      }
    }
    function r(t) {
      (t.return = !1), t.stop();
    }
    Object(s.default)(o, i.default);
  },
  function (t, e, n) {
    "use strict";
    var i = Array.isArray;
    e.a = i;
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return d;
    });
    var i = n(40),
      s = n(5),
      o = n(91),
      r = n(23),
      a = n(57),
      c = n(26),
      l = n(20),
      u = n(0);
    class d extends i.a {
      constructor(t, e, n) {
        super(n),
          (this.position = t.clone()),
          (this.position.stickiness = "toNone"),
          (this.nodes = new o.a(Object(a.c)(e))),
          (this.shouldReceiveAttributes = !1);
      }
      get type() {
        return "insert";
      }
      get howMany() {
        return this.nodes.maxOffset;
      }
      clone() {
        const t = new o.a([...this.nodes].map((t) => t._clone(!0))),
          e = new d(this.position, t, this.baseVersion);
        return (e.shouldReceiveAttributes = this.shouldReceiveAttributes), e;
      }
      getReversed() {
        const t = this.position.root.document.graveyard,
          e = new s.a(t, [0]);
        return new r.a(
          this.position,
          this.nodes.maxOffset,
          e,
          this.baseVersion + 1
        );
      }
      _validate() {
        const t = this.position.parent;
        if (!t || t.maxOffset < this.position.offset)
          throw new u.default("insert-operation-position-invalid", this);
      }
      _execute() {
        const t = this.nodes;
        (this.nodes = new o.a([...t].map((t) => t._clone(!0)))),
          Object(a.a)(this.position, t);
      }
      toJSON() {
        const t = super.toJSON();
        return (
          (t.position = this.position.toJSON()),
          (t.nodes = this.nodes.toJSON()),
          t
        );
      }
      static get className() {
        return "InsertOperation";
      }
      static fromJSON(t, e) {
        const n = [];
        for (const e of t.nodes)
          e.name ? n.push(l.a.fromJSON(e)) : n.push(c.a.fromJSON(e));
        const i = new d(s.a.fromJSON(t.position, e), n, t.baseVersion);
        return (i.shouldReceiveAttributes = t.shouldReceiveAttributes), i;
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return c;
    });
    var i = n(40),
      s = n(3),
      o = n(0),
      r = n(57),
      a = n(299);
    class c extends i.a {
      constructor(t, e, n, i, s) {
        super(s),
          (this.range = t.clone()),
          (this.key = e),
          (this.oldValue = void 0 === n ? null : n),
          (this.newValue = void 0 === i ? null : i);
      }
      get type() {
        return null === this.oldValue
          ? "addAttribute"
          : null === this.newValue
          ? "removeAttribute"
          : "changeAttribute";
      }
      clone() {
        return new c(
          this.range,
          this.key,
          this.oldValue,
          this.newValue,
          this.baseVersion
        );
      }
      getReversed() {
        return new c(
          this.range,
          this.key,
          this.newValue,
          this.oldValue,
          this.baseVersion + 1
        );
      }
      toJSON() {
        const t = super.toJSON();
        return (t.range = this.range.toJSON()), t;
      }
      _validate() {
        if (!this.range.isFlat)
          throw new o.default("attribute-operation-range-not-flat", this);
        for (const t of this.range.getItems({ shallow: !0 })) {
          if (
            null !== this.oldValue &&
            !Object(a.a)(t.getAttribute(this.key), this.oldValue)
          )
            throw new o.default("attribute-operation-wrong-old-value", this, {
              item: t,
              key: this.key,
              value: this.oldValue,
            });
          if (
            null === this.oldValue &&
            null !== this.newValue &&
            t.hasAttribute(this.key)
          )
            throw new o.default("attribute-operation-attribute-exists", this, {
              node: t,
              key: this.key,
            });
        }
      }
      _execute() {
        Object(a.a)(this.oldValue, this.newValue) ||
          Object(r.e)(this.range, this.key, this.newValue);
      }
      static get className() {
        return "AttributeOperation";
      }
      static fromJSON(t, e) {
        return new c(
          s.a.fromJSON(t.range, e),
          t.key,
          t.oldValue,
          t.newValue,
          t.baseVersion
        );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "c", function () {
      return o;
    }),
      n.d(e, "f", function () {
        return r;
      }),
      n.d(e, "g", function () {
        return a;
      }),
      n.d(e, "h", function () {
        return c;
      }),
      n.d(e, "d", function () {
        return l;
      }),
      n.d(e, "a", function () {
        return u;
      }),
      n.d(e, "b", function () {
        return d;
      }),
      n.d(e, "e", function () {
        return h;
      });
    var i = n(13),
      s = n(4);
    function o(t, e) {
      const n = e.mapper,
        i = e.writer,
        s = "numbered" == t.getAttribute("listType") ? "ol" : "ul",
        o = (function (t) {
          const e = t.createContainerElement("li");
          return (e.getFillerOffset = f), e;
        })(i),
        r = i.createContainerElement(s, null);
      return i.insert(i.createPositionAt(r, 0), o), n.bindElements(t, o), o;
    }
    function r(t, e, n, i) {
      const s = e.parent,
        o = n.mapper,
        r = n.writer;
      let u = o.toViewPosition(i.createPositionBefore(t));
      const h = l(t.previousSibling, {
          sameIndent: !0,
          smallerIndent: !0,
          listIndent: t.getAttribute("listIndent"),
        }),
        f = t.previousSibling;
      if (h && h.getAttribute("listIndent") == t.getAttribute("listIndent")) {
        const t = o.toViewElement(h);
        u = r.breakContainer(r.createPositionAfter(t));
      } else if (f && "listItem" == f.name) {
        u = o.toViewPosition(i.createPositionAt(f, "end"));
        const t = o.findMappedViewAncestor(u),
          e = d(t);
        u = e ? r.createPositionBefore(e) : r.createPositionAt(t, "end");
      } else u = o.toViewPosition(i.createPositionBefore(t));
      if (((u = c(u)), r.insert(u, s), f && "listItem" == f.name)) {
        const t = o.toViewElement(f),
          n = r
            .createRange(r.createPositionAt(t, 0), u)
            .getWalker({ ignoreElementEnd: !0 });
        for (const t of n)
          if (t.item.is("element", "li")) {
            const i = r.breakContainer(r.createPositionBefore(t.item)),
              s = t.item.parent,
              o = r.createPositionAt(e, "end");
            a(r, o.nodeBefore, o.nodeAfter),
              r.move(r.createRangeOn(s), o),
              (n.position = i);
          }
      } else {
        const n = s.nextSibling;
        if (n && (n.is("element", "ul") || n.is("element", "ol"))) {
          let i = null;
          for (const e of n.getChildren()) {
            const n = o.toModelElement(e);
            if (
              !(
                n && n.getAttribute("listIndent") > t.getAttribute("listIndent")
              )
            )
              break;
            i = e;
          }
          i &&
            (r.breakContainer(r.createPositionAfter(i)),
            r.move(r.createRangeOn(i.parent), r.createPositionAt(e, "end")));
        }
      }
      a(r, s, s.nextSibling), a(r, s.previousSibling, s);
    }
    function a(t, e, n) {
      return !e ||
        !n ||
        ("ul" != e.name && "ol" != e.name) ||
        e.name != n.name ||
        e.getAttribute("class") !== n.getAttribute("class")
        ? null
        : t.mergeContainers(t.createPositionAfter(e));
    }
    function c(t) {
      return t.getLastMatchingPosition((t) => t.item.is("uiElement"));
    }
    function l(t, e) {
      const n = !!e.sameIndent,
        i = !!e.smallerIndent,
        s = e.listIndent;
      let o = t;
      for (; o && "listItem" == o.name; ) {
        const t = o.getAttribute("listIndent");
        if ((n && s == t) || (i && s > t)) return o;
        o = "forward" === e.direction ? o.nextSibling : o.previousSibling;
      }
      return null;
    }
    function u(t, e, n, i) {
      t.ui.componentFactory.add(e, (o) => {
        const r = t.commands.get(e),
          a = new s.e(o);
        return (
          a.set({ label: n, icon: i, tooltip: !0, isToggleable: !0 }),
          a.bind("isOn", "isEnabled").to(r, "value", "isEnabled"),
          a.on("execute", () => {
            t.execute(e), t.editing.view.focus();
          }),
          a
        );
      });
    }
    function d(t) {
      for (const e of t.getChildren())
        if ("ul" == e.name || "ol" == e.name) return e;
      return null;
    }
    function h(t, e) {
      const n = [],
        s = t.parent,
        o = {
          ignoreElementEnd: !0,
          startPosition: t,
          shallow: !0,
          direction: e,
        },
        r = s.getAttribute("listIndent"),
        a = [...new i.p(o)]
          .filter((t) => t.item.is("element"))
          .map((t) => t.item);
      for (const t of a) {
        if (!t.is("element", "listItem")) break;
        if (t.getAttribute("listIndent") < r) break;
        if (!(t.getAttribute("listIndent") > r)) {
          if (t.getAttribute("listType") !== s.getAttribute("listType")) break;
          if (t.getAttribute("listStyle") !== s.getAttribute("listStyle"))
            break;
          "backward" === e ? n.unshift(t) : n.push(t);
        }
      }
      return n;
    }
    function f() {
      const t =
        !this.isEmpty &&
        ("ul" == this.getChild(0).name || "ol" == this.getChild(0).name);
      return this.isEmpty || t ? 0 : i.y.call(this);
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return d;
    });
    var i = n(79),
      s = n(25),
      o = n(81),
      r = n(73),
      a = n(35),
      c = n(39),
      l = n(101),
      u = n(143);
    class d extends i.a {
      constructor(t, e, n, i) {
        if (
          (super(t),
          (this.name = e),
          (this._attrs = (function (t) {
            t = Object(r.a)(t);
            for (const [e, n] of t)
              null === n
                ? t.delete(e)
                : "string" != typeof n && t.set(e, String(n));
            return t;
          })(n)),
          (this._children = []),
          i && this._insertChild(0, i),
          (this._classes = new Set()),
          this._attrs.has("class"))
        ) {
          const t = this._attrs.get("class");
          h(this._classes, t), this._attrs.delete("class");
        }
        (this._styles = new u.b(this.document.stylesProcessor)),
          this._attrs.has("style") &&
            (this._styles.setTo(this._attrs.get("style")),
            this._attrs.delete("style")),
          (this._customProperties = new Map()),
          (this._isAllowedInsideAttributeElement = !1),
          (this._unsafeAttributesToRender = []);
      }
      get childCount() {
        return this._children.length;
      }
      get isEmpty() {
        return 0 === this._children.length;
      }
      get isAllowedInsideAttributeElement() {
        return this._isAllowedInsideAttributeElement;
      }
      is(t, e = null) {
        return e
          ? e === this.name && ("element" === t || "view:element" === t)
          : "element" === t ||
              "view:element" === t ||
              "node" === t ||
              "view:node" === t;
      }
      getChild(t) {
        return this._children[t];
      }
      getChildIndex(t) {
        return this._children.indexOf(t);
      }
      getChildren() {
        return this._children[Symbol.iterator]();
      }
      *getAttributeKeys() {
        this._classes.size > 0 && (yield "class"),
          this._styles.isEmpty || (yield "style"),
          yield* this._attrs.keys();
      }
      *getAttributes() {
        yield* this._attrs.entries(),
          this._classes.size > 0 &&
            (yield ["class", this.getAttribute("class")]),
          this._styles.isEmpty || (yield ["style", this.getAttribute("style")]);
      }
      getAttribute(t) {
        if ("class" == t)
          return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
        if ("style" == t) {
          const t = this._styles.toString();
          return "" == t ? void 0 : t;
        }
        return this._attrs.get(t);
      }
      hasAttribute(t) {
        return "class" == t
          ? this._classes.size > 0
          : "style" == t
          ? !this._styles.isEmpty
          : this._attrs.has(t);
      }
      isSimilar(t) {
        if (!(t instanceof d)) return !1;
        if (this === t) return !0;
        if (this.name != t.name) return !1;
        if (
          this.isAllowedInsideAttributeElement !=
          t.isAllowedInsideAttributeElement
        )
          return !1;
        if (
          this._attrs.size !== t._attrs.size ||
          this._classes.size !== t._classes.size ||
          this._styles.size !== t._styles.size
        )
          return !1;
        for (const [e, n] of this._attrs)
          if (!t._attrs.has(e) || t._attrs.get(e) !== n) return !1;
        for (const e of this._classes) if (!t._classes.has(e)) return !1;
        for (const e of this._styles.getStyleNames())
          if (
            !t._styles.has(e) ||
            t._styles.getAsString(e) !== this._styles.getAsString(e)
          )
            return !1;
        return !0;
      }
      hasClass(...t) {
        for (const e of t) if (!this._classes.has(e)) return !1;
        return !0;
      }
      getClassNames() {
        return this._classes.keys();
      }
      getStyle(t) {
        return this._styles.getAsString(t);
      }
      getNormalizedStyle(t) {
        return this._styles.getNormalized(t);
      }
      getStyleNames(t = !1) {
        return this._styles.getStyleNames(t);
      }
      hasStyle(...t) {
        for (const e of t) if (!this._styles.has(e)) return !1;
        return !0;
      }
      findAncestor(...t) {
        const e = new l.a(...t);
        let n = this.parent;
        for (; n; ) {
          if (e.match(n)) return n;
          n = n.parent;
        }
        return null;
      }
      getCustomProperty(t) {
        return this._customProperties.get(t);
      }
      *getCustomProperties() {
        yield* this._customProperties.entries();
      }
      getIdentity() {
        const t = Array.from(this._classes).sort().join(","),
          e = this._styles.toString(),
          n = Array.from(this._attrs)
            .map((t) => `${t[0]}="${t[1]}"`)
            .sort()
            .join(" ");
        return (
          this.name +
          ("" == t ? "" : ` class="${t}"`) +
          (e ? ` style="${e}"` : "") +
          ("" == n ? "" : " " + n)
        );
      }
      shouldRenderUnsafeAttribute(t) {
        return this._unsafeAttributesToRender.includes(t);
      }
      _clone(t = !1) {
        const e = [];
        if (t) for (const n of this.getChildren()) e.push(n._clone(t));
        const n = new this.constructor(
          this.document,
          this.name,
          this._attrs,
          e
        );
        return (
          (n._classes = new Set(this._classes)),
          n._styles.set(this._styles.getNormalized()),
          (n._customProperties = new Map(this._customProperties)),
          (n.getFillerOffset = this.getFillerOffset),
          (n._isAllowedInsideAttributeElement =
            this.isAllowedInsideAttributeElement),
          n
        );
      }
      _appendChild(t) {
        return this._insertChild(this.childCount, t);
      }
      _insertChild(t, e) {
        this._fireChange("children", this);
        let n = 0;
        const i = (function (t, e) {
          if ("string" == typeof e) return [new s.a(t, e)];
          Object(c.a)(e) || (e = [e]);
          return Array.from(e).map((e) =>
            "string" == typeof e
              ? new s.a(t, e)
              : e instanceof o.a
              ? new s.a(t, e.data)
              : e
          );
        })(this.document, e);
        for (const e of i)
          null !== e.parent && e._remove(),
            (e.parent = this),
            (e.document = this.document),
            this._children.splice(t, 0, e),
            t++,
            n++;
        return n;
      }
      _removeChildren(t, e = 1) {
        this._fireChange("children", this);
        for (let n = t; n < t + e; n++) this._children[n].parent = null;
        return this._children.splice(t, e);
      }
      _setAttribute(t, e) {
        (e = String(e)),
          this._fireChange("attributes", this),
          "class" == t
            ? h(this._classes, e)
            : "style" == t
            ? this._styles.setTo(e)
            : this._attrs.set(t, e);
      }
      _removeAttribute(t) {
        return (
          this._fireChange("attributes", this),
          "class" == t
            ? this._classes.size > 0 && (this._classes.clear(), !0)
            : "style" == t
            ? !this._styles.isEmpty && (this._styles.clear(), !0)
            : this._attrs.delete(t)
        );
      }
      _addClass(t) {
        this._fireChange("attributes", this);
        for (const e of Object(a.a)(t)) this._classes.add(e);
      }
      _removeClass(t) {
        this._fireChange("attributes", this);
        for (const e of Object(a.a)(t)) this._classes.delete(e);
      }
      _setStyle(t, e) {
        this._fireChange("attributes", this), this._styles.set(t, e);
      }
      _removeStyle(t) {
        this._fireChange("attributes", this);
        for (const e of Object(a.a)(t)) this._styles.remove(e);
      }
      _setCustomProperty(t, e) {
        this._customProperties.set(t, e);
      }
      _removeCustomProperty(t) {
        return this._customProperties.delete(t);
      }
    }
    function h(t, e) {
      const n = e.split(/\s+/);
      t.clear(), n.forEach((e) => t.add(e));
    }
  },
  function (t, e, n) {
    "use strict";
    n.r(e),
      n.d(e, "default", function () {
        return c;
      });
    var i = n(11),
      s = n(0),
      o = n(44),
      r = n(39),
      a = n(6);
    class c {
      constructor(t = {}, e = {}) {
        const n = Object(r.a)(t);
        if (
          (n || (e = t),
          (this._items = []),
          (this._itemMap = new Map()),
          (this._idProperty = e.idProperty || "id"),
          (this._bindToExternalToInternalMap = new WeakMap()),
          (this._bindToInternalToExternalMap = new WeakMap()),
          (this._skippedIndexesFromExternal = []),
          n)
        )
          for (const e of t)
            this._items.push(e),
              this._itemMap.set(this._getItemIdBeforeAdding(e), e);
      }
      get length() {
        return this._items.length;
      }
      get first() {
        return this._items[0] || null;
      }
      get last() {
        return this._items[this.length - 1] || null;
      }
      add(t, e) {
        return this.addMany([t], e);
      }
      addMany(t, e) {
        if (void 0 === e) e = this._items.length;
        else if (e > this._items.length || e < 0)
          throw new s.default("collection-add-item-invalid-index", this);
        for (let n = 0; n < t.length; n++) {
          const i = t[n],
            s = this._getItemIdBeforeAdding(i),
            o = e + n;
          this._items.splice(o, 0, i),
            this._itemMap.set(s, i),
            this.fire("add", i, o);
        }
        return this.fire("change", { added: t, removed: [], index: e }), this;
      }
      get(t) {
        let e;
        if ("string" == typeof t) e = this._itemMap.get(t);
        else {
          if ("number" != typeof t)
            throw new s.default("collection-get-invalid-arg", this);
          e = this._items[t];
        }
        return e || null;
      }
      has(t) {
        if ("string" == typeof t) return this._itemMap.has(t);
        {
          const e = t[this._idProperty];
          return this._itemMap.has(e);
        }
      }
      getIndex(t) {
        let e;
        return (
          (e = "string" == typeof t ? this._itemMap.get(t) : t),
          this._items.indexOf(e)
        );
      }
      remove(t) {
        const [e, n] = this._remove(t);
        return this.fire("change", { added: [], removed: [e], index: n }), e;
      }
      map(t, e) {
        return this._items.map(t, e);
      }
      find(t, e) {
        return this._items.find(t, e);
      }
      filter(t, e) {
        return this._items.filter(t, e);
      }
      clear() {
        this._bindToCollection &&
          (this.stopListening(this._bindToCollection),
          (this._bindToCollection = null));
        const t = Array.from(this._items);
        for (; this.length; ) this._remove(0);
        this.fire("change", { added: [], removed: t, index: 0 });
      }
      bindTo(t) {
        if (this._bindToCollection)
          throw new s.default("collection-bind-to-rebind", this);
        return (
          (this._bindToCollection = t),
          {
            as: (t) => {
              this._setUpBindToBinding((e) => new t(e));
            },
            using: (t) => {
              "function" == typeof t
                ? this._setUpBindToBinding((e) => t(e))
                : this._setUpBindToBinding((e) => e[t]);
            },
          }
        );
      }
      _setUpBindToBinding(t) {
        const e = this._bindToCollection,
          n = (n, i, s) => {
            const o = e._bindToCollection == this,
              r = e._bindToInternalToExternalMap.get(i);
            if (o && r)
              this._bindToExternalToInternalMap.set(i, r),
                this._bindToInternalToExternalMap.set(r, i);
            else {
              const n = t(i);
              if (!n) return void this._skippedIndexesFromExternal.push(s);
              let o = s;
              for (const t of this._skippedIndexesFromExternal) s > t && o--;
              for (const t of e._skippedIndexesFromExternal) o >= t && o++;
              this._bindToExternalToInternalMap.set(i, n),
                this._bindToInternalToExternalMap.set(n, i),
                this.add(n, o);
              for (let t = 0; t < e._skippedIndexesFromExternal.length; t++)
                o <= e._skippedIndexesFromExternal[t] &&
                  e._skippedIndexesFromExternal[t]++;
            }
          };
        for (const t of e) n(0, t, e.getIndex(t));
        this.listenTo(e, "add", n),
          this.listenTo(e, "remove", (t, e, n) => {
            const i = this._bindToExternalToInternalMap.get(e);
            i && this.remove(i),
              (this._skippedIndexesFromExternal =
                this._skippedIndexesFromExternal.reduce(
                  (t, e) => (n < e && t.push(e - 1), n > e && t.push(e), t),
                  []
                ));
          });
      }
      _getItemIdBeforeAdding(t) {
        const e = this._idProperty;
        let n;
        if (e in t) {
          if (((n = t[e]), "string" != typeof n))
            throw new s.default("collection-add-invalid-id", this);
          if (this.get(n))
            throw new s.default("collection-add-item-already-exists", this);
        } else t[e] = n = Object(o.a)();
        return n;
      }
      _remove(t) {
        let e,
          n,
          i,
          o = !1;
        const r = this._idProperty;
        if (
          ("string" == typeof t
            ? ((n = t),
              (i = this._itemMap.get(n)),
              (o = !i),
              i && (e = this._items.indexOf(i)))
            : "number" == typeof t
            ? ((e = t), (i = this._items[e]), (o = !i), i && (n = i[r]))
            : ((i = t),
              (n = i[r]),
              (e = this._items.indexOf(i)),
              (o = -1 == e || !this._itemMap.get(n))),
          o)
        )
          throw new s.default("collection-remove-404", this);
        this._items.splice(e, 1), this._itemMap.delete(n);
        const a = this._bindToInternalToExternalMap.get(i);
        return (
          this._bindToInternalToExternalMap.delete(i),
          this._bindToExternalToInternalMap.delete(a),
          this.fire("remove", i, e),
          [i, e]
        );
      }
      [Symbol.iterator]() {
        return this._items[Symbol.iterator]();
      }
    }
    Object(a.default)(c, i.default);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(72),
      s = n(14),
      o = n(0),
      r = n(6);
    class a {
      constructor() {
        this.set("isFocused", !1),
          this.set("focusedElement", null),
          (this._elements = new Set()),
          (this._nextEventLoopTimeout = null);
      }
      add(t) {
        if (this._elements.has(t))
          throw new o.default("focustracker-add-element-already-exist", this);
        this.listenTo(t, "focus", () => this._focus(t), { useCapture: !0 }),
          this.listenTo(t, "blur", () => this._blur(), { useCapture: !0 }),
          this._elements.add(t);
      }
      remove(t) {
        t === this.focusedElement && this._blur(t),
          this._elements.has(t) &&
            (this.stopListening(t), this._elements.delete(t));
      }
      destroy() {
        this.stopListening();
      }
      _focus(t) {
        clearTimeout(this._nextEventLoopTimeout),
          (this.focusedElement = t),
          (this.isFocused = !0);
      }
      _blur() {
        clearTimeout(this._nextEventLoopTimeout),
          (this._nextEventLoopTimeout = setTimeout(() => {
            (this.focusedElement = null), (this.isFocused = !1);
          }, 0));
      }
    }
    Object(r.default)(a, i.a), Object(r.default)(a, s.default);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return f;
    });
    var i = n(6),
      s = n(11),
      o = n(92),
      r = n(89),
      a = n(26),
      c = n(60),
      l = n(73),
      u = n(51),
      d = n(0),
      h = n(44);
    class f {
      constructor(t) {
        (this._selection = new m(t)),
          this._selection.delegate("change:range").to(this),
          this._selection.delegate("change:attribute").to(this),
          this._selection.delegate("change:marker").to(this);
      }
      get isCollapsed() {
        return this._selection.isCollapsed;
      }
      get anchor() {
        return this._selection.anchor;
      }
      get focus() {
        return this._selection.focus;
      }
      get rangeCount() {
        return this._selection.rangeCount;
      }
      get hasOwnRange() {
        return this._selection.hasOwnRange;
      }
      get isBackward() {
        return this._selection.isBackward;
      }
      get isGravityOverridden() {
        return this._selection.isGravityOverridden;
      }
      get markers() {
        return this._selection.markers;
      }
      get _ranges() {
        return this._selection._ranges;
      }
      getRanges() {
        return this._selection.getRanges();
      }
      getFirstPosition() {
        return this._selection.getFirstPosition();
      }
      getLastPosition() {
        return this._selection.getLastPosition();
      }
      getFirstRange() {
        return this._selection.getFirstRange();
      }
      getLastRange() {
        return this._selection.getLastRange();
      }
      getSelectedBlocks() {
        return this._selection.getSelectedBlocks();
      }
      getSelectedElement() {
        return this._selection.getSelectedElement();
      }
      containsEntireContent(t) {
        return this._selection.containsEntireContent(t);
      }
      destroy() {
        this._selection.destroy();
      }
      getAttributeKeys() {
        return this._selection.getAttributeKeys();
      }
      getAttributes() {
        return this._selection.getAttributes();
      }
      getAttribute(t) {
        return this._selection.getAttribute(t);
      }
      hasAttribute(t) {
        return this._selection.hasAttribute(t);
      }
      refresh() {
        this._selection._updateMarkers(), this._selection._updateAttributes(!1);
      }
      observeMarkers(t) {
        this._selection.observeMarkers(t);
      }
      is(t) {
        return (
          "selection" === t ||
          "model:selection" == t ||
          "documentSelection" == t ||
          "model:documentSelection" == t
        );
      }
      _setFocus(t, e) {
        this._selection.setFocus(t, e);
      }
      _setTo(t, e, n) {
        this._selection.setTo(t, e, n);
      }
      _setAttribute(t, e) {
        this._selection.setAttribute(t, e);
      }
      _removeAttribute(t) {
        this._selection.removeAttribute(t);
      }
      _getStoredAttributes() {
        return this._selection._getStoredAttributes();
      }
      _overrideGravity() {
        return this._selection.overrideGravity();
      }
      _restoreGravity(t) {
        this._selection.restoreGravity(t);
      }
      static _getStoreAttributeKey(t) {
        return "selection:" + t;
      }
      static _isStoreAttributeKey(t) {
        return t.startsWith("selection:");
      }
    }
    Object(i.default)(f, s.default);
    class m extends o.a {
      constructor(t) {
        super(),
          (this.markers = new u.default({ idProperty: "name" })),
          (this._model = t.model),
          (this._document = t),
          (this._attributePriority = new Map()),
          (this._selectionRestorePosition = null),
          (this._hasChangedRange = !1),
          (this._overriddenGravityRegister = new Set()),
          (this._observedMarkers = new Set()),
          this.listenTo(
            this._model,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              n.isDocumentOperation &&
                "marker" != n.type &&
                "rename" != n.type &&
                "noop" != n.type &&
                (0 == this._ranges.length &&
                  this._selectionRestorePosition &&
                  this._fixGraveyardSelection(this._selectionRestorePosition),
                (this._selectionRestorePosition = null),
                this._hasChangedRange &&
                  ((this._hasChangedRange = !1),
                  this.fire("change:range", { directChange: !1 })));
            },
            { priority: "lowest" }
          ),
          this.on("change:range", () => {
            for (const t of this.getRanges())
              if (!this._document._validateSelectionRange(t))
                throw new d.default("document-selection-wrong-position", this, {
                  range: t,
                });
          }),
          this.listenTo(this._model.markers, "update", (t, e, n, i) => {
            this._updateMarker(e, i);
          }),
          this.listenTo(this._document, "change", (t, e) => {
            !(function (t, e) {
              const n = t.document.differ;
              for (const i of n.getChanges()) {
                if ("insert" != i.type) continue;
                const n = i.position.parent;
                i.length === n.maxOffset &&
                  t.enqueueChange(e, (t) => {
                    const e = Array.from(n.getAttributeKeys()).filter((t) =>
                      t.startsWith("selection:")
                    );
                    for (const i of e) t.removeAttribute(i, n);
                  });
              }
            })(this._model, e);
          });
      }
      get isCollapsed() {
        return 0 === this._ranges.length
          ? this._document._getDefaultRange().isCollapsed
          : super.isCollapsed;
      }
      get anchor() {
        return super.anchor || this._document._getDefaultRange().start;
      }
      get focus() {
        return super.focus || this._document._getDefaultRange().end;
      }
      get rangeCount() {
        return this._ranges.length ? this._ranges.length : 1;
      }
      get hasOwnRange() {
        return this._ranges.length > 0;
      }
      get isGravityOverridden() {
        return !!this._overriddenGravityRegister.size;
      }
      destroy() {
        for (let t = 0; t < this._ranges.length; t++) this._ranges[t].detach();
        this.stopListening();
      }
      *getRanges() {
        this._ranges.length
          ? yield* super.getRanges()
          : yield this._document._getDefaultRange();
      }
      getFirstRange() {
        return super.getFirstRange() || this._document._getDefaultRange();
      }
      getLastRange() {
        return super.getLastRange() || this._document._getDefaultRange();
      }
      setTo(t, e, n) {
        super.setTo(t, e, n), this._updateAttributes(!0), this._updateMarkers();
      }
      setFocus(t, e) {
        super.setFocus(t, e), this._updateAttributes(!0), this._updateMarkers();
      }
      setAttribute(t, e) {
        if (this._setAttribute(t, e)) {
          const e = [t];
          this.fire("change:attribute", { attributeKeys: e, directChange: !0 });
        }
      }
      removeAttribute(t) {
        if (this._removeAttribute(t)) {
          const e = [t];
          this.fire("change:attribute", { attributeKeys: e, directChange: !0 });
        }
      }
      overrideGravity() {
        const t = Object(h.a)();
        return (
          this._overriddenGravityRegister.add(t),
          1 === this._overriddenGravityRegister.size &&
            this._updateAttributes(!0),
          t
        );
      }
      restoreGravity(t) {
        if (!this._overriddenGravityRegister.has(t))
          throw new d.default(
            "document-selection-gravity-wrong-restore",
            this,
            { uid: t }
          );
        this._overriddenGravityRegister.delete(t),
          this.isGravityOverridden || this._updateAttributes(!0);
      }
      observeMarkers(t) {
        this._observedMarkers.add(t), this._updateMarkers();
      }
      _popRange() {
        this._ranges.pop().detach();
      }
      _pushRange(t) {
        const e = this._prepareRange(t);
        e && this._ranges.push(e);
      }
      _prepareRange(t) {
        if ((this._checkRange(t), t.root == this._document.graveyard)) return;
        const e = r.a.fromRange(t);
        return (
          e.on("change:range", (t, n, i) => {
            if (
              ((this._hasChangedRange = !0), e.root == this._document.graveyard)
            ) {
              this._selectionRestorePosition = i.deletionPosition;
              const t = this._ranges.indexOf(e);
              this._ranges.splice(t, 1), e.detach();
            }
          }),
          e
        );
      }
      _updateMarkers() {
        if (!this._observedMarkers.size) return;
        const t = [];
        let e = !1;
        for (const e of this._model.markers) {
          const n = e.name.split(":", 1)[0];
          if (!this._observedMarkers.has(n)) continue;
          const i = e.getRange();
          for (const n of this.getRanges())
            i.containsRange(n, !n.isCollapsed) && t.push(e);
        }
        const n = Array.from(this.markers);
        for (const n of t)
          this.markers.has(n) || (this.markers.add(n), (e = !0));
        for (const n of Array.from(this.markers))
          t.includes(n) || (this.markers.remove(n), (e = !0));
        e && this.fire("change:marker", { oldMarkers: n, directChange: !1 });
      }
      _updateMarker(t, e) {
        const n = t.name.split(":", 1)[0];
        if (!this._observedMarkers.has(n)) return;
        let i = !1;
        const s = Array.from(this.markers),
          o = this.markers.has(t);
        if (e) {
          let n = !1;
          for (const t of this.getRanges())
            if (e.containsRange(t, !t.isCollapsed)) {
              n = !0;
              break;
            }
          n && !o
            ? (this.markers.add(t), (i = !0))
            : !n && o && (this.markers.remove(t), (i = !0));
        } else o && (this.markers.remove(t), (i = !0));
        i && this.fire("change:marker", { oldMarkers: s, directChange: !1 });
      }
      _updateAttributes(t) {
        const e = Object(l.a)(this._getSurroundingAttributes()),
          n = Object(l.a)(this.getAttributes());
        if (t) (this._attributePriority = new Map()), (this._attrs = new Map());
        else
          for (const [t, e] of this._attributePriority)
            "low" == e &&
              (this._attrs.delete(t), this._attributePriority.delete(t));
        this._setAttributesTo(e);
        const i = [];
        for (const [t, e] of this.getAttributes())
          (n.has(t) && n.get(t) === e) || i.push(t);
        for (const [t] of n) this.hasAttribute(t) || i.push(t);
        i.length > 0 &&
          this.fire("change:attribute", { attributeKeys: i, directChange: !1 });
      }
      _setAttribute(t, e, n = !0) {
        const i = n ? "normal" : "low";
        if ("low" == i && "normal" == this._attributePriority.get(t)) return !1;
        return (
          super.getAttribute(t) !== e &&
          (this._attrs.set(t, e), this._attributePriority.set(t, i), !0)
        );
      }
      _removeAttribute(t, e = !0) {
        const n = e ? "normal" : "low";
        return (
          ("low" != n || "normal" != this._attributePriority.get(t)) &&
          (this._attributePriority.set(t, n),
          !!super.hasAttribute(t) && (this._attrs.delete(t), !0))
        );
      }
      _setAttributesTo(t) {
        const e = new Set();
        for (const [e, n] of this.getAttributes())
          t.get(e) !== n && this._removeAttribute(e, !1);
        for (const [n, i] of t) {
          this._setAttribute(n, i, !1) && e.add(n);
        }
        return e;
      }
      *_getStoredAttributes() {
        const t = this.getFirstPosition().parent;
        if (this.isCollapsed && t.isEmpty)
          for (const e of t.getAttributeKeys())
            if (e.startsWith("selection:")) {
              const n = e.substr("selection:".length);
              yield [n, t.getAttribute(e)];
            }
      }
      _getSurroundingAttributes() {
        const t = this.getFirstPosition(),
          e = this._model.schema;
        let n = null;
        if (this.isCollapsed) {
          const i = t.textNode ? t.textNode : t.nodeBefore,
            s = t.textNode ? t.textNode : t.nodeAfter;
          if (
            (this.isGravityOverridden || (n = g(i)),
            n || (n = g(s)),
            !this.isGravityOverridden && !n)
          ) {
            let t = i;
            for (; t && !e.isInline(t) && !n; )
              (t = t.previousSibling), (n = g(t));
          }
          if (!n) {
            let t = s;
            for (; t && !e.isInline(t) && !n; ) (t = t.nextSibling), (n = g(t));
          }
          n || (n = this._getStoredAttributes());
        } else {
          const t = this.getFirstRange();
          for (const i of t) {
            if (i.item.is("element") && e.isObject(i.item)) break;
            if ("text" == i.type) {
              n = i.item.getAttributes();
              break;
            }
          }
        }
        return n;
      }
      _fixGraveyardSelection(t) {
        const e = this._model.schema.getNearestSelectionRange(t);
        e && this._pushRange(e);
      }
    }
    function g(t) {
      return t instanceof c.a || t instanceof a.a ? t.getAttributes() : null;
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(1),
      s = n(19),
      o = n(85);
    class r extends i.j {
      static get pluginName() {
        return "ImageUtils";
      }
      isImage(t) {
        return this.isInlineImage(t) || this.isBlockImage(t);
      }
      isInlineImageView(t) {
        return !!t && t.is("element", "img");
      }
      isBlockImageView(t) {
        return !!t && t.is("element", "figure") && t.hasClass("image");
      }
      insertImage(t = {}, e = null, n = null) {
        const i = this.editor,
          o = i.model,
          r = o.document.selection;
        (n = a(i, e || r, n)),
          (t = { ...Object.fromEntries(r.getAttributes()), ...t });
        for (const e in t) o.schema.checkAttribute(n, e) || delete t[e];
        return o.change((i) => {
          const a = i.createElement(n, t);
          return (
            e || "imageInline" == n || (e = Object(s.d)(r, o)),
            o.insertContent(a, e),
            a.parent ? (i.setSelection(a, "on"), a) : null
          );
        });
      }
      getClosestSelectedImageWidget(t) {
        const e = t.getSelectedElement();
        if (e && this.isImageWidget(e)) return e;
        let n = t.getFirstPosition().parent;
        for (; n; ) {
          if (n.is("element") && this.isImageWidget(n)) return n;
          n = n.parent;
        }
        return null;
      }
      getClosestSelectedImageElement(t) {
        const e = t.getSelectedElement();
        return this.isImage(e)
          ? e
          : t.getFirstPosition().findAncestor("imageBlock");
      }
      isImageAllowed() {
        const t = this.editor.model.document.selection;
        return (
          (function (t, e) {
            if ("imageBlock" == a(t, e)) {
              const n = (function (t, e) {
                const n = Object(s.d)(t, e).start.parent;
                if (n.isEmpty && !n.is("element", "$root")) return n.parent;
                return n;
              })(e, t.model);
              if (t.model.schema.checkChild(n, "imageBlock")) return !0;
            } else if (t.model.schema.checkChild(e.focus, "imageInline"))
              return !0;
            return !1;
          })(this.editor, t) &&
          (function (t) {
            return [...t.focus.getAncestors()].every(
              (t) => !t.is("element", "imageBlock")
            );
          })(t)
        );
      }
      toImageWidget(t, e, n) {
        e.setCustomProperty("image", !0, t);
        return Object(s.g)(t, e, {
          label: () => {
            const e = this.findViewImgElement(t).getAttribute("alt");
            return e ? `${e} ${n}` : n;
          },
        });
      }
      isImageWidget(t) {
        return !!t.getCustomProperty("image") && Object(s.e)(t);
      }
      isBlockImage(t) {
        return !!t && t.is("element", "imageBlock");
      }
      isInlineImage(t) {
        return !!t && t.is("element", "imageInline");
      }
      findViewImgElement(t) {
        if (this.isInlineImageView(t)) return t;
        const e = this.editor.editing.view;
        for (const { item: n } of e.createRangeIn(t))
          if (this.isInlineImageView(n)) return n;
      }
    }
    function a(t, e, n) {
      const i = t.model.schema,
        s = t.config.get("image.insert.type");
      return t.plugins.has("ImageBlockEditing")
        ? t.plugins.has("ImageInlineEditing")
          ? n ||
            ("inline" === s
              ? "imageInline"
              : "block" === s
              ? "imageBlock"
              : e.is("selection")
              ? Object(o.b)(i, e)
              : i.checkChild(e, "imageInline")
              ? "imageInline"
              : "imageBlock")
          : "imageBlock"
        : "imageInline";
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(5),
      s = n(11),
      o = n(6),
      r = n(0);
    class a extends i.a {
      constructor(t, e, n = "toNone") {
        if ((super(t, e, n), !this.root.is("rootElement")))
          throw new r.default("model-liveposition-root-not-rootelement", t);
        c.call(this);
      }
      detach() {
        this.stopListening();
      }
      is(t) {
        return (
          "livePosition" === t ||
          "model:livePosition" === t ||
          "position" == t ||
          "model:position" === t
        );
      }
      toPosition() {
        return new i.a(this.root, this.path.slice(), this.stickiness);
      }
      static fromPosition(t, e) {
        return new this(t.root, t.path.slice(), e || t.stickiness);
      }
    }
    function c() {
      this.listenTo(
        this.root.document.model,
        "applyOperation",
        (t, e) => {
          const n = e[0];
          n.isDocumentOperation && l.call(this, n);
        },
        { priority: "low" }
      );
    }
    function l(t) {
      const e = this.getTransformedByOperation(t);
      if (!this.isEqual(e)) {
        const t = this.toPosition();
        (this.path = e.path), (this.root = e.root), this.fire("change", t);
      }
    }
    Object(o.default)(a, s.default);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(40);
    class s extends i.a {
      get type() {
        return "noop";
      }
      clone() {
        return new s(this.baseVersion);
      }
      getReversed() {
        return new s(this.baseVersion + 1);
      }
      _execute() {}
      static get className() {
        return "NoOperation";
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return u;
    }),
      n.d(e, "d", function () {
        return d;
      }),
      n.d(e, "b", function () {
        return h;
      }),
      n.d(e, "e", function () {
        return f;
      }),
      n.d(e, "c", function () {
        return m;
      });
    var i = n(88),
      s = n(26),
      o = n(60),
      r = n(3),
      a = n(100),
      c = n(91),
      l = n(0);
    function u(t, e) {
      const n = (e = m(e)).reduce((t, e) => t + e.offsetSize, 0),
        i = t.parent;
      p(t);
      const s = t.index;
      return (
        i._insertChild(s, e),
        g(i, s + e.length),
        g(i, s),
        new r.a(t, t.getShiftedBy(n))
      );
    }
    function d(t) {
      if (!t.isFlat)
        throw new l.default("operation-utils-remove-range-not-flat", this);
      const e = t.start.parent;
      p(t.start), p(t.end);
      const n = e._removeChildren(t.start.index, t.end.index - t.start.index);
      return g(e, t.start.index), n;
    }
    function h(t, e) {
      if (!t.isFlat)
        throw new l.default("operation-utils-move-range-not-flat", this);
      const n = d(t);
      return u(
        (e = e._getTransformedByDeletion(
          t.start,
          t.end.offset - t.start.offset
        )),
        n
      );
    }
    function f(t, e, n) {
      p(t.start), p(t.end);
      for (const i of t.getItems({ shallow: !0 })) {
        const t = i.is("$textProxy") ? i.textNode : i;
        null !== n ? t._setAttribute(e, n) : t._removeAttribute(e),
          g(t.parent, t.index);
      }
      g(t.end.parent, t.end.index);
    }
    function m(t) {
      const e = [];
      t instanceof Array || (t = [t]);
      for (let n = 0; n < t.length; n++)
        if ("string" == typeof t[n]) e.push(new s.a(t[n]));
        else if (t[n] instanceof o.a)
          e.push(new s.a(t[n].data, t[n].getAttributes()));
        else if (t[n] instanceof a.a || t[n] instanceof c.a)
          for (const i of t[n]) e.push(i);
        else t[n] instanceof i.a && e.push(t[n]);
      for (let t = 1; t < e.length; t++) {
        const n = e[t],
          i = e[t - 1];
        n instanceof s.a &&
          i instanceof s.a &&
          b(n, i) &&
          (e.splice(t - 1, 2, new s.a(i.data + n.data, i.getAttributes())),
          t--);
      }
      return e;
    }
    function g(t, e) {
      const n = t.getChild(e - 1),
        i = t.getChild(e);
      if (n && i && n.is("$text") && i.is("$text") && b(n, i)) {
        const o = new s.a(n.data + i.data, n.getAttributes());
        t._removeChildren(e - 1, 2), t._insertChild(e - 1, o);
      }
    }
    function p(t) {
      const e = t.textNode,
        n = t.parent;
      if (e) {
        const i = t.offset - e.startOffset,
          o = e.index;
        n._removeChildren(o, 1);
        const r = new s.a(e.data.substr(0, i), e.getAttributes()),
          a = new s.a(e.data.substr(i), e.getAttributes());
        n._insertChild(o, [r, a]);
      }
    }
    function b(t, e) {
      const n = t.getAttributes(),
        i = e.getAttributes();
      for (const t of n) {
        if (t[1] !== e.getAttribute(t[0])) return !1;
        i.next();
      }
      return i.next().done;
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(72),
      s = n(6);
    class o {
      constructor(t) {
        (this.view = t), (this.document = t.document), (this.isEnabled = !1);
      }
      enable() {
        this.isEnabled = !0;
      }
      disable() {
        this.isEnabled = !1;
      }
      destroy() {
        this.disable(), this.stopListening();
      }
      checkShouldIgnoreEventFromTarget(t) {
        return (
          t && 3 === t.nodeType && (t = t.parentNode),
          !(!t || 1 !== t.nodeType) &&
            t.matches("[data-cke-ignore-events], [data-cke-ignore-events] *")
        );
      }
    }
    Object(s.default)(o, i.a);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(58),
      s = n(111);
    class o extends i.a {
      constructor(t) {
        super(t), (this.useCapture = !1);
      }
      observe(t) {
        ("string" == typeof this.domEventType
          ? [this.domEventType]
          : this.domEventType
        ).forEach((e) => {
          this.listenTo(
            t,
            e,
            (t, e) => {
              this.isEnabled &&
                !this.checkShouldIgnoreEventFromTarget(e.target) &&
                this.onDomEvent(e);
            },
            { useCapture: this.useCapture }
          );
        });
      }
      fire(t, e, n) {
        this.isEnabled && this.document.fire(t, new s.a(this.view, e, n));
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(0);
    class s {
      constructor(t, e, n) {
        if (((this.textNode = t), e < 0 || e > t.offsetSize))
          throw new i.default("model-textproxy-wrong-offsetintext", this);
        if (n < 0 || e + n > t.offsetSize)
          throw new i.default("model-textproxy-wrong-length", this);
        (this.data = t.data.substring(e, e + n)), (this.offsetInText = e);
      }
      get startOffset() {
        return null !== this.textNode.startOffset
          ? this.textNode.startOffset + this.offsetInText
          : null;
      }
      get offsetSize() {
        return this.data.length;
      }
      get endOffset() {
        return null !== this.startOffset
          ? this.startOffset + this.offsetSize
          : null;
      }
      get isPartial() {
        return this.offsetSize !== this.textNode.offsetSize;
      }
      get parent() {
        return this.textNode.parent;
      }
      get root() {
        return this.textNode.root;
      }
      is(t) {
        return (
          "$textProxy" === t ||
          "model:$textProxy" === t ||
          "textProxy" === t ||
          "model:textProxy" === t
        );
      }
      getPath() {
        const t = this.textNode.getPath();
        return t.length > 0 && (t[t.length - 1] += this.offsetInText), t;
      }
      getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
        const e = [];
        let n = t.includeSelf ? this : this.parent;
        for (; n; ) e[t.parentFirst ? "push" : "unshift"](n), (n = n.parent);
        return e;
      }
      hasAttribute(t) {
        return this.textNode.hasAttribute(t);
      }
      getAttribute(t) {
        return this.textNode.getAttribute(t);
      }
      getAttributes() {
        return this.textNode.getAttributes();
      }
      getAttributeKeys() {
        return this.textNode.getAttributeKeys();
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return h;
    });
    var i = n(0),
      s = n(6),
      o = n(11),
      r = n(8),
      a = n(113),
      c = n(105),
      l = n(30),
      u = n(267),
      d = n(35);
    class h {
      constructor(t) {
        Object.assign(this, k(y(t))),
          (this._isRendered = !1),
          (this._revertData = null);
      }
      render() {
        const t = this._renderNode({ intoFragment: !0 });
        return (this._isRendered = !0), t;
      }
      apply(t) {
        return (
          (this._revertData = { children: [], bindings: [], attributes: {} }),
          this._renderNode({
            node: t,
            isApplying: !0,
            revertData: this._revertData,
          }),
          t
        );
      }
      revert(t) {
        if (!this._revertData)
          throw new i.default("ui-template-revert-not-applied", [this, t]);
        this._revertTemplateFromNode(t, this._revertData);
      }
      *getViews() {
        yield* (function* t(e) {
          if (e.children)
            for (const n of e.children) P(n) ? yield n : T(n) && (yield* t(n));
        })(this);
      }
      static bind(t, e) {
        return {
          to: (n, i) =>
            new m({
              eventNameOrFunction: n,
              attribute: n,
              observable: t,
              emitter: e,
              callback: i,
            }),
          if: (n, i, s) =>
            new g({
              observable: t,
              emitter: e,
              attribute: n,
              valueIfTrue: i,
              callback: s,
            }),
        };
      }
      static extend(t, e) {
        if (t._isRendered)
          throw new i.default("template-extend-render", [this, t]);
        !(function t(e, n) {
          n.attributes &&
            (e.attributes || (e.attributes = {}),
            E(e.attributes, n.attributes));
          n.eventListeners &&
            (e.eventListeners || (e.eventListeners = {}),
            E(e.eventListeners, n.eventListeners));
          n.text && e.text.push(...n.text);
          if (n.children && n.children.length) {
            if (e.children.length != n.children.length)
              throw new i.default("ui-template-extend-children-mismatch", e);
            let s = 0;
            for (const i of n.children) t(e.children[s++], i);
          }
        })(t, k(y(e)));
      }
      _renderNode(t) {
        let e;
        if (
          ((e = t.node
            ? this.tag && this.text
            : this.tag
            ? this.text
            : !this.text),
          e)
        )
          throw new i.default("ui-template-wrong-syntax", this);
        return this.text ? this._renderText(t) : this._renderElement(t);
      }
      _renderElement(t) {
        let e = t.node;
        return (
          e ||
            (e = t.node =
              document.createElementNS(
                this.ns || "http://www.w3.org/1999/xhtml",
                this.tag
              )),
          this._renderAttributes(t),
          this._renderElementChildren(t),
          this._setUpListeners(t),
          e
        );
      }
      _renderText(t) {
        let e = t.node;
        return (
          e
            ? (t.revertData.text = e.textContent)
            : (e = t.node = document.createTextNode("")),
          p(this.text)
            ? this._bindToObservable({
                schema: this.text,
                updater: w(e),
                data: t,
              })
            : (e.textContent = this.text.join("")),
          e
        );
      }
      _renderAttributes(t) {
        let e, n, i, s;
        if (!this.attributes) return;
        const o = t.node,
          r = t.revertData;
        for (e in this.attributes)
          if (
            ((i = o.getAttribute(e)),
            (n = this.attributes[e]),
            r && (r.attributes[e] = i),
            (s = Object(l.a)(n[0]) && n[0].ns ? n[0].ns : null),
            p(n))
          ) {
            const a = s ? n[0].value : n;
            r && S(e) && a.unshift(i),
              this._bindToObservable({
                schema: a,
                updater: v(o, e, s),
                data: t,
              });
          } else
            "style" == e && "string" != typeof n[0]
              ? this._renderStyleAttribute(n[0], t)
              : (r && i && S(e) && n.unshift(i),
                (n = n
                  .map((t) => (t && t.value) || t)
                  .reduce((t, e) => t.concat(e), [])
                  .reduce(C, "")),
                O(n) || o.setAttributeNS(s, e, n));
      }
      _renderStyleAttribute(t, e) {
        const n = e.node;
        for (const i in t) {
          const s = t[i];
          p(s)
            ? this._bindToObservable({ schema: [s], updater: _(n, i), data: e })
            : (n.style[i] = s);
        }
      }
      _renderElementChildren(t) {
        const e = t.node,
          n = t.intoFragment ? document.createDocumentFragment() : e,
          i = t.isApplying;
        let s = 0;
        for (const o of this.children)
          if (x(o)) {
            if (!i) {
              o.setParent(e);
              for (const t of o) n.appendChild(t.element);
            }
          } else if (P(o))
            i || (o.isRendered || o.render(), n.appendChild(o.element));
          else if (Object(c.a)(o)) n.appendChild(o);
          else if (i) {
            const e = { children: [], bindings: [], attributes: {} };
            t.revertData.children.push(e),
              o._renderNode({
                node: n.childNodes[s++],
                isApplying: !0,
                revertData: e,
              });
          } else n.appendChild(o.render());
        t.intoFragment && e.appendChild(n);
      }
      _setUpListeners(t) {
        if (this.eventListeners)
          for (const e in this.eventListeners) {
            const n = this.eventListeners[e].map((n) => {
              const [i, s] = e.split("@");
              return n.activateDomEventListener(i, s, t);
            });
            t.revertData && t.revertData.bindings.push(n);
          }
      }
      _bindToObservable({ schema: t, updater: e, data: n }) {
        const i = n.revertData;
        b(t, e, n);
        const s = t
          .filter((t) => !O(t))
          .filter((t) => t.observable)
          .map((i) => i.activateAttributeListener(t, e, n));
        i && i.bindings.push(s);
      }
      _revertTemplateFromNode(t, e) {
        for (const t of e.bindings) for (const e of t) e();
        if (e.text) t.textContent = e.text;
        else {
          for (const n in e.attributes) {
            const i = e.attributes[n];
            null === i ? t.removeAttribute(n) : t.setAttribute(n, i);
          }
          for (let n = 0; n < e.children.length; ++n)
            this._revertTemplateFromNode(t.childNodes[n], e.children[n]);
        }
      }
    }
    Object(s.default)(h, o.default);
    class f {
      constructor(t) {
        Object.assign(this, t);
      }
      getValue(t) {
        const e = this.observable[this.attribute];
        return this.callback ? this.callback(e, t) : e;
      }
      activateAttributeListener(t, e, n) {
        const i = () => b(t, e, n);
        return (
          this.emitter.listenTo(this.observable, "change:" + this.attribute, i),
          () => {
            this.emitter.stopListening(
              this.observable,
              "change:" + this.attribute,
              i
            );
          }
        );
      }
    }
    class m extends f {
      activateDomEventListener(t, e, n) {
        const i = (t, n) => {
          (e && !n.target.matches(e)) ||
            ("function" == typeof this.eventNameOrFunction
              ? this.eventNameOrFunction(n)
              : this.observable.fire(this.eventNameOrFunction, n));
        };
        return (
          this.emitter.listenTo(n.node, t, i),
          () => {
            this.emitter.stopListening(n.node, t, i);
          }
        );
      }
    }
    class g extends f {
      getValue(t) {
        return !O(super.getValue(t)) && (this.valueIfTrue || !0);
      }
    }
    function p(t) {
      return (
        !!t &&
        (t.value && (t = t.value),
        Array.isArray(t) ? t.some(p) : t instanceof f)
      );
    }
    function b(t, e, { node: n }) {
      let i = (function (t, e) {
        return t.map((t) => (t instanceof f ? t.getValue(e) : t));
      })(t, n);
      (i = 1 == t.length && t[0] instanceof g ? i[0] : i.reduce(C, "")),
        O(i) ? e.remove() : e.set(i);
    }
    function w(t) {
      return {
        set(e) {
          t.textContent = e;
        },
        remove() {
          t.textContent = "";
        },
      };
    }
    function v(t, e, n) {
      return {
        set(i) {
          t.setAttributeNS(n, e, i);
        },
        remove() {
          t.removeAttributeNS(n, e);
        },
      };
    }
    function _(t, e) {
      return {
        set(n) {
          t.style[e] = n;
        },
        remove() {
          t.style[e] = null;
        },
      };
    }
    function y(t) {
      return Object(u.a)(t, (t) => {
        if (t && (t instanceof f || T(t) || P(t) || x(t))) return t;
      });
    }
    function k(t) {
      if (
        ("string" == typeof t
          ? (t = (function (t) {
              return { text: [t] };
            })(t))
          : t.text &&
            (function (t) {
              t.text = Object(d.a)(t.text);
            })(t),
        t.on &&
          ((t.eventListeners = (function (t) {
            for (const e in t) A(t, e);
            return t;
          })(t.on)),
          delete t.on),
        !t.text)
      ) {
        t.attributes &&
          (function (t) {
            for (const e in t)
              t[e].value && (t[e].value = Object(d.a)(t[e].value)), A(t, e);
          })(t.attributes);
        const e = [];
        if (t.children)
          if (x(t.children)) e.push(t.children);
          else
            for (const n of t.children)
              T(n) || P(n) || Object(c.a)(n) ? e.push(n) : e.push(new h(n));
        t.children = e;
      }
      return t;
    }
    function A(t, e) {
      t[e] = Object(d.a)(t[e]);
    }
    function C(t, e) {
      return O(e) ? t : O(t) ? e : `${t} ${e}`;
    }
    function E(t, e) {
      for (const n in e) t[n] ? t[n].push(...e[n]) : (t[n] = e[n]);
    }
    function O(t) {
      return !t && 0 !== t;
    }
    function P(t) {
      return t instanceof r.a;
    }
    function T(t) {
      return t instanceof h;
    }
    function x(t) {
      return t instanceof a.a;
    }
    function S(t) {
      return "class" == t || "style" == t;
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return h;
    });
    var i = n(0),
      s = n(15),
      o = n(7),
      r = n(6),
      a = n(11),
      c = n(79),
      l = n(172),
      u = n(39),
      d = n(217);
    class h {
      constructor(t = null, e, n) {
        (this._ranges = []),
          (this._lastRangeBackward = !1),
          (this._isFake = !1),
          (this._fakeSelectionLabel = ""),
          this.setTo(t, e, n);
      }
      get isFake() {
        return this._isFake;
      }
      get fakeSelectionLabel() {
        return this._fakeSelectionLabel;
      }
      get anchor() {
        if (!this._ranges.length) return null;
        const t = this._ranges[this._ranges.length - 1];
        return (this._lastRangeBackward ? t.end : t.start).clone();
      }
      get focus() {
        if (!this._ranges.length) return null;
        const t = this._ranges[this._ranges.length - 1];
        return (this._lastRangeBackward ? t.start : t.end).clone();
      }
      get isCollapsed() {
        return 1 === this.rangeCount && this._ranges[0].isCollapsed;
      }
      get rangeCount() {
        return this._ranges.length;
      }
      get isBackward() {
        return !this.isCollapsed && this._lastRangeBackward;
      }
      get editableElement() {
        return this.anchor ? this.anchor.editableElement : null;
      }
      *getRanges() {
        for (const t of this._ranges) yield t.clone();
      }
      getFirstRange() {
        let t = null;
        for (const e of this._ranges)
          (t && !e.start.isBefore(t.start)) || (t = e);
        return t ? t.clone() : null;
      }
      getLastRange() {
        let t = null;
        for (const e of this._ranges) (t && !e.end.isAfter(t.end)) || (t = e);
        return t ? t.clone() : null;
      }
      getFirstPosition() {
        const t = this.getFirstRange();
        return t ? t.start.clone() : null;
      }
      getLastPosition() {
        const t = this.getLastRange();
        return t ? t.end.clone() : null;
      }
      isEqual(t) {
        if (this.isFake != t.isFake) return !1;
        if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel)
          return !1;
        if (this.rangeCount != t.rangeCount) return !1;
        if (0 === this.rangeCount) return !0;
        if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus))
          return !1;
        for (const e of this._ranges) {
          let n = !1;
          for (const i of t._ranges)
            if (e.isEqual(i)) {
              n = !0;
              break;
            }
          if (!n) return !1;
        }
        return !0;
      }
      isSimilar(t) {
        if (this.isBackward != t.isBackward) return !1;
        const e = Object(l.a)(this.getRanges());
        if (e != Object(l.a)(t.getRanges())) return !1;
        if (0 == e) return !0;
        for (let e of this.getRanges()) {
          e = e.getTrimmed();
          let n = !1;
          for (let i of t.getRanges())
            if (
              ((i = i.getTrimmed()),
              e.start.isEqual(i.start) && e.end.isEqual(i.end))
            ) {
              n = !0;
              break;
            }
          if (!n) return !1;
        }
        return !0;
      }
      getSelectedElement() {
        return 1 !== this.rangeCount
          ? null
          : this.getFirstRange().getContainedElement();
      }
      setTo(t, e, n) {
        if (null === t) this._setRanges([]), this._setFakeOptions(e);
        else if (t instanceof h || t instanceof d.a)
          this._setRanges(t.getRanges(), t.isBackward),
            this._setFakeOptions({
              fake: t.isFake,
              label: t.fakeSelectionLabel,
            });
        else if (t instanceof s.a)
          this._setRanges([t], e && e.backward), this._setFakeOptions(e);
        else if (t instanceof o.a)
          this._setRanges([new s.a(t)]), this._setFakeOptions(e);
        else if (t instanceof c.a) {
          const r = !!n && !!n.backward;
          let a;
          if (void 0 === e)
            throw new i.default(
              "view-selection-setto-required-second-parameter",
              this
            );
          (a =
            "in" == e
              ? s.a._createIn(t)
              : "on" == e
              ? s.a._createOn(t)
              : new s.a(o.a._createAt(t, e))),
            this._setRanges([a], r),
            this._setFakeOptions(n);
        } else {
          if (!Object(u.a)(t))
            throw new i.default("view-selection-setto-not-selectable", this);
          this._setRanges(t, e && e.backward), this._setFakeOptions(e);
        }
        this.fire("change");
      }
      setFocus(t, e) {
        if (null === this.anchor)
          throw new i.default("view-selection-setfocus-no-ranges", this);
        const n = o.a._createAt(t, e);
        if ("same" == n.compareWith(this.focus)) return;
        const r = this.anchor;
        this._ranges.pop(),
          "before" == n.compareWith(r)
            ? this._addRange(new s.a(n, r), !0)
            : this._addRange(new s.a(r, n)),
          this.fire("change");
      }
      is(t) {
        return "selection" === t || "view:selection" === t;
      }
      _setRanges(t, e = !1) {
        (t = Array.from(t)), (this._ranges = []);
        for (const e of t) this._addRange(e);
        this._lastRangeBackward = !!e;
      }
      _setFakeOptions(t = {}) {
        (this._isFake = !!t.fake),
          (this._fakeSelectionLabel = (t.fake && t.label) || "");
      }
      _addRange(t, e = !1) {
        if (!(t instanceof s.a))
          throw new i.default("view-selection-add-range-not-range", this);
        this._pushRange(t), (this._lastRangeBackward = !!e);
      }
      _pushRange(t) {
        for (const e of this._ranges)
          if (t.isIntersecting(e))
            throw new i.default("view-selection-range-intersects", this, {
              addedRange: t,
              intersectingRange: e,
            });
        this._ranges.push(new s.a(t.start, t.end));
      }
    }
    Object(r.default)(h, a.default);
  },
  function (t, e, n) {
    "use strict";
    var i = n(64),
      s = Object.prototype,
      o = s.hasOwnProperty,
      r = s.toString,
      a = i.a ? i.a.toStringTag : void 0;
    var c = function (t) {
        var e = o.call(t, a),
          n = t[a];
        try {
          t[a] = void 0;
          var i = !0;
        } catch (t) {}
        var s = r.call(t);
        return i && (e ? (t[a] = n) : delete t[a]), s;
      },
      l = Object.prototype.toString;
    var u = function (t) {
        return l.call(t);
      },
      d = i.a ? i.a.toStringTag : void 0;
    e.a = function (t) {
      return null == t
        ? void 0 === t
          ? "[object Undefined]"
          : "[object Null]"
        : d && d in Object(t)
        ? c(t)
        : u(t);
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(41).a.Symbol;
    e.a = i;
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(40),
      s = n(3);
    class o extends i.a {
      constructor(t, e, n, i, s, o) {
        super(o),
          (this.name = t),
          (this.oldRange = e ? e.clone() : null),
          (this.newRange = n ? n.clone() : null),
          (this.affectsData = s),
          (this._markers = i);
      }
      get type() {
        return "marker";
      }
      clone() {
        return new o(
          this.name,
          this.oldRange,
          this.newRange,
          this._markers,
          this.affectsData,
          this.baseVersion
        );
      }
      getReversed() {
        return new o(
          this.name,
          this.newRange,
          this.oldRange,
          this._markers,
          this.affectsData,
          this.baseVersion + 1
        );
      }
      _execute() {
        const t = this.newRange ? "_set" : "_remove";
        this._markers[t](this.name, this.newRange, !0, this.affectsData);
      }
      toJSON() {
        const t = super.toJSON();
        return (
          this.oldRange && (t.oldRange = this.oldRange.toJSON()),
          this.newRange && (t.newRange = this.newRange.toJSON()),
          delete t._markers,
          t
        );
      }
      static get className() {
        return "MarkerOperation";
      }
      static fromJSON(t, e) {
        return new o(
          t.name,
          t.oldRange ? s.a.fromJSON(t.oldRange, e) : null,
          t.newRange ? s.a.fromJSON(t.newRange, e) : null,
          e.model.markers,
          t.affectsData,
          t.baseVersion
        );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "b", function () {
      return i.a;
    }),
      n.d(e, "a", function () {
        return r;
      });
    var i = n(131),
      s = n(34),
      o = n(8);
    class r extends o.a {
      constructor(t) {
        super(t),
          (this.buttonView = new s.a(t)),
          (this._fileInputView = new a(t)),
          this._fileInputView.bind("acceptedType").to(this),
          this._fileInputView.bind("allowMultipleFiles").to(this),
          this._fileInputView.delegate("done").to(this),
          this.setTemplate({
            tag: "span",
            attributes: { class: "ck-file-dialog-button" },
            children: [this.buttonView, this._fileInputView],
          }),
          this.buttonView.on("execute", () => {
            this._fileInputView.open();
          });
      }
      focus() {
        this.buttonView.focus();
      }
    }
    class a extends o.a {
      constructor(t) {
        super(t), this.set("acceptedType"), this.set("allowMultipleFiles", !1);
        const e = this.bindTemplate;
        this.setTemplate({
          tag: "input",
          attributes: {
            class: ["ck-hidden"],
            type: "file",
            tabindex: "-1",
            accept: e.to("acceptedType"),
            multiple: e.to("allowMultipleFiles"),
          },
          on: {
            change: e.to(() => {
              this.element &&
                this.element.files &&
                this.element.files.length &&
                this.fire("done", this.element.files),
                (this.element.value = "");
            }),
          },
        });
      }
      open() {
        this.element.click();
      }
    }
    n(318);
    var c = n(9);
    n(0);
    c.a;
  },
  ,
  function (t, e, n) {
    "use strict";
    function i(t) {
      return (e) => e + t;
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(72),
      s = n(12);
    class o {
      constructor() {
        this._listener = Object.create(i.a);
      }
      listenTo(t) {
        this._listener.listenTo(t, "keydown", (t, e) => {
          this._listener.fire("_keydown:" + Object(s.a)(e), e);
        });
      }
      set(t, e, n = {}) {
        const i = Object(s.g)(t),
          o = n.priority;
        this._listener.listenTo(
          this._listener,
          "_keydown:" + i,
          (t, n) => {
            e(n, () => {
              n.preventDefault(), n.stopPropagation(), t.stop();
            }),
              (t.return = !0);
          },
          { priority: o }
        );
      }
      press(t) {
        return !!this._listener.fire("_keydown:" + Object(s.a)(t), t);
      }
      destroy() {
        this._listener.stopListening();
      }
    }
  },
  function (t, e, n) {
    "use strict";
    var i,
      s = n(123),
      o = n(41).a["__core-js_shared__"],
      r = (i = /[^.]+$/.exec((o && o.keys && o.keys.IE_PROTO) || ""))
        ? "Symbol(src)_1." + i
        : "";
    var a = function (t) {
        return !!r && r in t;
      },
      c = n(30),
      l = n(106),
      u = /^\[object .+?Constructor\]$/,
      d = Function.prototype,
      h = Object.prototype,
      f = d.toString,
      m = h.hasOwnProperty,
      g = RegExp(
        "^" +
          f
            .call(m)
            .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
            .replace(
              /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
              "$1.*?"
            ) +
          "$"
      );
    var p = function (t) {
      return (
        !(!Object(c.a)(t) || a(t)) &&
        (Object(s.a)(t) ? g : u).test(Object(l.a)(t))
      );
    };
    var b = function (t, e) {
      return null == t ? void 0 : t[e];
    };
    e.a = function (t, e) {
      var n = b(t, e);
      return p(n) ? n : void 0;
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return c;
    });
    var i = n(26),
      s = n(60),
      o = n(20),
      r = n(5),
      a = n(0);
    class c {
      constructor(t = {}) {
        if (!t.boundaries && !t.startPosition)
          throw new a.default("model-tree-walker-no-start-position", null);
        const e = t.direction || "forward";
        if ("forward" != e && "backward" != e)
          throw new a.default("model-tree-walker-unknown-direction", t, {
            direction: e,
          });
        (this.direction = e),
          (this.boundaries = t.boundaries || null),
          t.startPosition
            ? (this.position = t.startPosition.clone())
            : (this.position = r.a._createAt(
                this.boundaries["backward" == this.direction ? "end" : "start"]
              )),
          (this.position.stickiness = "toNone"),
          (this.singleCharacters = !!t.singleCharacters),
          (this.shallow = !!t.shallow),
          (this.ignoreElementEnd = !!t.ignoreElementEnd),
          (this._boundaryStartParent = this.boundaries
            ? this.boundaries.start.parent
            : null),
          (this._boundaryEndParent = this.boundaries
            ? this.boundaries.end.parent
            : null),
          (this._visitedParent = this.position.parent);
      }
      [Symbol.iterator]() {
        return this;
      }
      skip(t) {
        let e, n, i, s;
        do {
          (i = this.position),
            (s = this._visitedParent),
            ({ done: e, value: n } = this.next());
        } while (!e && t(n));
        e || ((this.position = i), (this._visitedParent = s));
      }
      next() {
        return "forward" == this.direction ? this._next() : this._previous();
      }
      _next() {
        const t = this.position,
          e = this.position.clone(),
          n = this._visitedParent;
        if (null === n.parent && e.offset === n.maxOffset) return { done: !0 };
        if (
          n === this._boundaryEndParent &&
          e.offset == this.boundaries.end.offset
        )
          return { done: !0 };
        const a = e.parent,
          c = Object(r.d)(e, a),
          u = c || Object(r.b)(e, a, c);
        if (u instanceof o.a)
          return (
            this.shallow
              ? e.offset++
              : (e.path.push(0), (this._visitedParent = u)),
            (this.position = e),
            l("elementStart", u, t, e, 1)
          );
        if (u instanceof i.a) {
          let i;
          if (this.singleCharacters) i = 1;
          else {
            let t = u.endOffset;
            this._boundaryEndParent == n &&
              this.boundaries.end.offset < t &&
              (t = this.boundaries.end.offset),
              (i = t - e.offset);
          }
          const o = e.offset - u.startOffset,
            r = new s.a(u, o, i);
          return (e.offset += i), (this.position = e), l("text", r, t, e, i);
        }
        return (
          e.path.pop(),
          e.offset++,
          (this.position = e),
          (this._visitedParent = n.parent),
          this.ignoreElementEnd ? this._next() : l("elementEnd", n, t, e)
        );
      }
      _previous() {
        const t = this.position,
          e = this.position.clone(),
          n = this._visitedParent;
        if (null === n.parent && 0 === e.offset) return { done: !0 };
        if (
          n == this._boundaryStartParent &&
          e.offset == this.boundaries.start.offset
        )
          return { done: !0 };
        const a = e.parent,
          c = Object(r.d)(e, a),
          u = c || Object(r.c)(e, a, c);
        if (u instanceof o.a)
          return (
            e.offset--,
            this.shallow
              ? ((this.position = e), l("elementStart", u, t, e, 1))
              : (e.path.push(u.maxOffset),
                (this.position = e),
                (this._visitedParent = u),
                this.ignoreElementEnd
                  ? this._previous()
                  : l("elementEnd", u, t, e))
          );
        if (u instanceof i.a) {
          let i;
          if (this.singleCharacters) i = 1;
          else {
            let t = u.startOffset;
            this._boundaryStartParent == n &&
              this.boundaries.start.offset > t &&
              (t = this.boundaries.start.offset),
              (i = e.offset - t);
          }
          const o = e.offset - u.startOffset,
            r = new s.a(u, o - i, i);
          return (e.offset -= i), (this.position = e), l("text", r, t, e, i);
        }
        return (
          e.path.pop(),
          (this.position = e),
          (this._visitedParent = n.parent),
          l("elementStart", n, t, e, 1)
        );
      }
    }
    function l(t, e, n, i, s) {
      return {
        done: !1,
        value: {
          type: t,
          item: e,
          previousPosition: n,
          nextPosition: i,
          length: s,
        },
      };
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(11),
      s = n(44),
      o = n(105),
      r = n(163),
      a = n(174);
    const c = Object(a.a)({}, i.default, {
      listenTo(t, e, n, s = {}) {
        if (Object(o.a)(t) || Object(r.a)(t)) {
          const i = { capture: !!s.useCapture, passive: !!s.usePassive },
            o = this._getProxyEmitter(t, i) || new l(t, i);
          this.listenTo(o, e, n, s);
        } else i.default.listenTo.call(this, t, e, n, s);
      },
      stopListening(t, e, n) {
        if (Object(o.a)(t) || Object(r.a)(t)) {
          const i = this._getAllProxyEmitters(t);
          for (const t of i) this.stopListening(t, e, n);
        } else i.default.stopListening.call(this, t, e, n);
      },
      _getProxyEmitter(t, e) {
        return Object(i._getEmitterListenedTo)(this, u(t, e));
      },
      _getAllProxyEmitters(t) {
        return [
          { capture: !1, passive: !1 },
          { capture: !1, passive: !0 },
          { capture: !0, passive: !1 },
          { capture: !0, passive: !0 },
        ]
          .map((e) => this._getProxyEmitter(t, e))
          .filter((t) => !!t);
      },
    });
    e.a = c;
    class l {
      constructor(t, e) {
        Object(i._setEmitterId)(this, u(t, e)),
          (this._domNode = t),
          (this._options = e);
      }
    }
    function u(t, e) {
      let n = (function (t) {
        return t["data-ck-expando"] || (t["data-ck-expando"] = Object(s.a)());
      })(t);
      for (const t of Object.keys(e).sort()) e[t] && (n += "-" + t);
      return n;
    }
    Object(a.a)(l.prototype, i.default, {
      attach(t) {
        if (this._domListeners && this._domListeners[t]) return;
        const e = this._createDomListener(t);
        this._domNode.addEventListener(t, e, this._options),
          this._domListeners || (this._domListeners = {}),
          (this._domListeners[t] = e);
      },
      detach(t) {
        let e;
        !this._domListeners[t] ||
          ((e = this._events[t]) && e.callbacks.length) ||
          this._domListeners[t].removeListener();
      },
      _addEventListener(t, e, n) {
        this.attach(t), i.default._addEventListener.call(this, t, e, n);
      },
      _removeEventListener(t, e) {
        i.default._removeEventListener.call(this, t, e), this.detach(t);
      },
      _createDomListener(t) {
        const e = (e) => {
          this.fire(t, e);
        };
        return (
          (e.removeListener = () => {
            this._domNode.removeEventListener(t, e, this._options),
              delete this._domListeners[t];
          }),
          e
        );
      },
    });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(39);
    function s(t) {
      return Object(i.a)(t)
        ? new Map(t)
        : (function (t) {
            const e = new Map();
            for (const n in t) e.set(n, t[n]);
            return e;
          })(t);
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = function () {
      return function t() {
        t.called = !0;
      };
    };
    class s {
      constructor(t, e) {
        (this.source = t),
          (this.name = e),
          (this.path = []),
          (this.stop = i()),
          (this.off = i());
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(40),
      s = n(20),
      o = n(0),
      r = n(5);
    class a extends i.a {
      constructor(t, e, n, i) {
        super(i),
          (this.position = t),
          (this.position.stickiness = "toNext"),
          (this.oldName = e),
          (this.newName = n);
      }
      get type() {
        return "rename";
      }
      clone() {
        return new a(
          this.position.clone(),
          this.oldName,
          this.newName,
          this.baseVersion
        );
      }
      getReversed() {
        return new a(
          this.position.clone(),
          this.newName,
          this.oldName,
          this.baseVersion + 1
        );
      }
      _validate() {
        const t = this.position.nodeAfter;
        if (!(t instanceof s.a))
          throw new o.default("rename-operation-wrong-position", this);
        if (t.name !== this.oldName)
          throw new o.default("rename-operation-wrong-name", this);
      }
      _execute() {
        this.position.nodeAfter.name = this.newName;
      }
      toJSON() {
        const t = super.toJSON();
        return (t.position = this.position.toJSON()), t;
      }
      static get className() {
        return "RenameOperation";
      }
      static fromJSON(t, e) {
        return new a(
          r.a.fromJSON(t.position, e),
          t.oldName,
          t.newName,
          t.baseVersion
        );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(63),
      s = n(150),
      o = n(38),
      r = Function.prototype,
      a = Object.prototype,
      c = r.toString,
      l = a.hasOwnProperty,
      u = c.call(Object);
    e.a = function (t) {
      if (!Object(o.a)(t) || "[object Object]" != Object(i.a)(t)) return !1;
      var e = Object(s.a)(t);
      if (null === e) return !0;
      var n = l.call(e, "constructor") && e.constructor;
      return "function" == typeof n && n instanceof n && c.call(n) == u;
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return i.a;
    }),
      n.d(e, "b", function () {
        return s.a;
      });
    var i = n(285),
      s = n(90);
    n(197), n(198);
  },
  function (t, e, n) {
    "use strict";
    var i = n(148),
      s = n(147);
    e.a = function (t, e, n, o) {
      var r = !n;
      n || (n = {});
      for (var a = -1, c = e.length; ++a < c; ) {
        var l = e[a],
          u = o ? o(n[l], t[l], l, n, t) : void 0;
        void 0 === u && (u = t[l]),
          r ? Object(s.a)(n, l, u) : Object(i.a)(n, l, u);
      }
      return n;
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return c;
    });
    var i = n(0),
      s = n(11),
      o = n(6),
      r = n(37),
      a = n(355);
    n(133);
    class c {
      constructor(t) {
        (this.document = t), (this.parent = null);
      }
      get index() {
        let t;
        if (!this.parent) return null;
        if (-1 == (t = this.parent.getChildIndex(this)))
          throw new i.default("view-node-not-found-in-parent", this);
        return t;
      }
      get nextSibling() {
        const t = this.index;
        return (null !== t && this.parent.getChild(t + 1)) || null;
      }
      get previousSibling() {
        const t = this.index;
        return (null !== t && this.parent.getChild(t - 1)) || null;
      }
      get root() {
        let t = this;
        for (; t.parent; ) t = t.parent;
        return t;
      }
      isAttached() {
        return this.root.is("rootElement");
      }
      getPath() {
        const t = [];
        let e = this;
        for (; e.parent; ) t.unshift(e.index), (e = e.parent);
        return t;
      }
      getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
        const e = [];
        let n = t.includeSelf ? this : this.parent;
        for (; n; ) e[t.parentFirst ? "push" : "unshift"](n), (n = n.parent);
        return e;
      }
      getCommonAncestor(t, e = {}) {
        const n = this.getAncestors(e),
          i = t.getAncestors(e);
        let s = 0;
        for (; n[s] == i[s] && n[s]; ) s++;
        return 0 === s ? null : n[s - 1];
      }
      isBefore(t) {
        if (this == t) return !1;
        if (this.root !== t.root) return !1;
        const e = this.getPath(),
          n = t.getPath(),
          i = Object(r.a)(e, n);
        switch (i) {
          case "prefix":
            return !0;
          case "extension":
            return !1;
          default:
            return e[i] < n[i];
        }
      }
      isAfter(t) {
        return this != t && this.root === t.root && !this.isBefore(t);
      }
      _remove() {
        this.parent._removeChildren(this.index);
      }
      _fireChange(t, e) {
        this.fire("change:" + t, e),
          this.parent && this.parent._fireChange(t, e);
      }
      toJSON() {
        const t = Object(a.a)(this);
        return delete t.parent, t;
      }
      is(t) {
        return "node" === t || "view:node" === t;
      }
    }
    Object(o.default)(c, s.default);
  },
  function (t, e, n) {
    "use strict";
    var i = n(228),
      s = n(30),
      o = n(149);
    var r = function (t) {
        var e = [];
        if (null != t) for (var n in Object(t)) e.push(n);
        return e;
      },
      a = Object.prototype.hasOwnProperty;
    var c = function (t) {
        if (!Object(s.a)(t)) return r(t);
        var e = Object(o.a)(t),
          n = [];
        for (var i in t)
          ("constructor" != i || (!e && a.call(t, i))) && n.push(i);
        return n;
      },
      l = n(117);
    e.a = function (t) {
      return Object(l.a)(t) ? Object(i.a)(t, !0) : c(t);
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(0);
    class s {
      constructor(t, e, n) {
        if (((this.textNode = t), e < 0 || e > t.data.length))
          throw new i.default("view-textproxy-wrong-offsetintext", this);
        if (n < 0 || e + n > t.data.length)
          throw new i.default("view-textproxy-wrong-length", this);
        (this.data = t.data.substring(e, e + n)), (this.offsetInText = e);
      }
      get offsetSize() {
        return this.data.length;
      }
      get isPartial() {
        return this.data.length !== this.textNode.data.length;
      }
      get parent() {
        return this.textNode.parent;
      }
      get root() {
        return this.textNode.root;
      }
      get document() {
        return this.textNode.document;
      }
      is(t) {
        return (
          "$textProxy" === t ||
          "view:$textProxy" === t ||
          "textProxy" === t ||
          "view:textProxy" === t
        );
      }
      getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
        const e = [];
        let n = t.includeSelf ? this.textNode : this.parent;
        for (; null !== n; )
          e[t.parentFirst ? "push" : "unshift"](n), (n = n.parent);
        return e;
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return d;
    }),
      n.d(e, "b", function () {
        return f;
      });
    var i = n(8),
      s = n(157),
      o = n(135),
      r = n(68),
      a = n(27),
      c = n(179);
    n(346);
    const l = Object(r.a)("px"),
      u = a.a.document.body;
    class d extends i.a {
      constructor(t) {
        super(t);
        const e = this.bindTemplate;
        this.set("top", 0),
          this.set("left", 0),
          this.set("position", "arrow_nw"),
          this.set("isVisible", !1),
          this.set("withArrow", !0),
          this.set("class"),
          (this.content = this.createCollection()),
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-balloon-panel",
                e.to("position", (t) => "ck-balloon-panel_" + t),
                e.if("isVisible", "ck-balloon-panel_visible"),
                e.if("withArrow", "ck-balloon-panel_with-arrow"),
                e.to("class"),
              ],
              style: { top: e.to("top", l), left: e.to("left", l) },
            },
            children: this.content,
          });
      }
      show() {
        this.isVisible = !0;
      }
      hide() {
        this.isVisible = !1;
      }
      attachTo(t) {
        this.show();
        const e = d.defaultPositions,
          n = Object.assign(
            {},
            {
              element: this.element,
              positions: [
                e.southArrowNorth,
                e.southArrowNorthMiddleWest,
                e.southArrowNorthMiddleEast,
                e.southArrowNorthWest,
                e.southArrowNorthEast,
                e.northArrowSouth,
                e.northArrowSouthMiddleWest,
                e.northArrowSouthMiddleEast,
                e.northArrowSouthWest,
                e.northArrowSouthEast,
                e.viewportStickyNorth,
              ],
              limiter: u,
              fitInViewport: !0,
            },
            t
          ),
          i = d._getOptimalPosition(n),
          s = parseInt(i.left),
          o = parseInt(i.top),
          { name: r, config: a = {} } = i,
          { withArrow: c = !0 } = a;
        Object.assign(this, { top: o, left: s, position: r, withArrow: c });
      }
      pin(t) {
        this.unpin(),
          (this._pinWhenIsVisibleCallback = () => {
            this.isVisible ? this._startPinning(t) : this._stopPinning();
          }),
          this._startPinning(t),
          this.listenTo(
            this,
            "change:isVisible",
            this._pinWhenIsVisibleCallback
          );
      }
      unpin() {
        this._pinWhenIsVisibleCallback &&
          (this._stopPinning(),
          this.stopListening(
            this,
            "change:isVisible",
            this._pinWhenIsVisibleCallback
          ),
          (this._pinWhenIsVisibleCallback = null),
          this.hide());
      }
      _startPinning(t) {
        this.attachTo(t);
        const e = h(t.target),
          n = t.limiter ? h(t.limiter) : u;
        this.listenTo(
          a.a.document,
          "scroll",
          (i, s) => {
            const o = s.target,
              r = e && o.contains(e),
              a = n && o.contains(n);
            (!r && !a && e && n) || this.attachTo(t);
          },
          { useCapture: !0 }
        ),
          this.listenTo(a.a.window, "resize", () => {
            this.attachTo(t);
          });
      }
      _stopPinning() {
        this.stopListening(a.a.document, "scroll"),
          this.stopListening(a.a.window, "resize");
      }
    }
    function h(t) {
      return Object(c.a)(t)
        ? t
        : Object(o.a)(t)
        ? t.commonAncestorContainer
        : "function" == typeof t
        ? h(t())
        : null;
    }
    function f({
      horizontalOffset: t = d.arrowHorizontalOffset,
      verticalOffset: e = d.arrowVerticalOffset,
      stickyVerticalOffset: n = d.stickyVerticalOffset,
      config: i,
    } = {}) {
      return {
        northWestArrowSouthWest: (e, n) => ({
          top: s(e, n),
          left: e.left - t,
          name: "arrow_sw",
          ...(i && { config: i }),
        }),
        northWestArrowSouthMiddleWest: (e, n) => ({
          top: s(e, n),
          left: e.left - 0.25 * n.width - t,
          name: "arrow_smw",
          ...(i && { config: i }),
        }),
        northWestArrowSouth: (t, e) => ({
          top: s(t, e),
          left: t.left - e.width / 2,
          name: "arrow_s",
          ...(i && { config: i }),
        }),
        northWestArrowSouthMiddleEast: (e, n) => ({
          top: s(e, n),
          left: e.left - 0.75 * n.width + t,
          name: "arrow_sme",
          ...(i && { config: i }),
        }),
        northWestArrowSouthEast: (e, n) => ({
          top: s(e, n),
          left: e.left - n.width + t,
          name: "arrow_se",
          ...(i && { config: i }),
        }),
        northArrowSouthWest: (e, n) => ({
          top: s(e, n),
          left: e.left + e.width / 2 - t,
          name: "arrow_sw",
          ...(i && { config: i }),
        }),
        northArrowSouthMiddleWest: (e, n) => ({
          top: s(e, n),
          left: e.left + e.width / 2 - 0.25 * n.width - t,
          name: "arrow_smw",
          ...(i && { config: i }),
        }),
        northArrowSouth: (t, e) => ({
          top: s(t, e),
          left: t.left + t.width / 2 - e.width / 2,
          name: "arrow_s",
          ...(i && { config: i }),
        }),
        northArrowSouthMiddleEast: (e, n) => ({
          top: s(e, n),
          left: e.left + e.width / 2 - 0.75 * n.width + t,
          name: "arrow_sme",
          ...(i && { config: i }),
        }),
        northArrowSouthEast: (e, n) => ({
          top: s(e, n),
          left: e.left + e.width / 2 - n.width + t,
          name: "arrow_se",
          ...(i && { config: i }),
        }),
        northEastArrowSouthWest: (e, n) => ({
          top: s(e, n),
          left: e.right - t,
          name: "arrow_sw",
          ...(i && { config: i }),
        }),
        northEastArrowSouthMiddleWest: (e, n) => ({
          top: s(e, n),
          left: e.right - 0.25 * n.width - t,
          name: "arrow_smw",
          ...(i && { config: i }),
        }),
        northEastArrowSouth: (t, e) => ({
          top: s(t, e),
          left: t.right - e.width / 2,
          name: "arrow_s",
          ...(i && { config: i }),
        }),
        northEastArrowSouthMiddleEast: (e, n) => ({
          top: s(e, n),
          left: e.right - 0.75 * n.width + t,
          name: "arrow_sme",
          ...(i && { config: i }),
        }),
        northEastArrowSouthEast: (e, n) => ({
          top: s(e, n),
          left: e.right - n.width + t,
          name: "arrow_se",
          ...(i && { config: i }),
        }),
        southWestArrowNorthWest: (e, n) => ({
          top: o(e),
          left: e.left - t,
          name: "arrow_nw",
          ...(i && { config: i }),
        }),
        southWestArrowNorthMiddleWest: (e, n) => ({
          top: o(e),
          left: e.left - 0.25 * n.width - t,
          name: "arrow_nmw",
          ...(i && { config: i }),
        }),
        southWestArrowNorth: (t, e) => ({
          top: o(t),
          left: t.left - e.width / 2,
          name: "arrow_n",
          ...(i && { config: i }),
        }),
        southWestArrowNorthMiddleEast: (e, n) => ({
          top: o(e),
          left: e.left - 0.75 * n.width + t,
          name: "arrow_nme",
          ...(i && { config: i }),
        }),
        southWestArrowNorthEast: (e, n) => ({
          top: o(e),
          left: e.left - n.width + t,
          name: "arrow_ne",
          ...(i && { config: i }),
        }),
        southArrowNorthWest: (e, n) => ({
          top: o(e),
          left: e.left + e.width / 2 - t,
          name: "arrow_nw",
          ...(i && { config: i }),
        }),
        southArrowNorthMiddleWest: (e, n) => ({
          top: o(e),
          left: e.left + e.width / 2 - 0.25 * n.width - t,
          name: "arrow_nmw",
          ...(i && { config: i }),
        }),
        southArrowNorth: (t, e) => ({
          top: o(t),
          left: t.left + t.width / 2 - e.width / 2,
          name: "arrow_n",
          ...(i && { config: i }),
        }),
        southArrowNorthMiddleEast: (e, n) => ({
          top: o(e),
          left: e.left + e.width / 2 - 0.75 * n.width + t,
          name: "arrow_nme",
          ...(i && { config: i }),
        }),
        southArrowNorthEast: (e, n) => ({
          top: o(e),
          left: e.left + e.width / 2 - n.width + t,
          name: "arrow_ne",
          ...(i && { config: i }),
        }),
        southEastArrowNorthWest: (e, n) => ({
          top: o(e),
          left: e.right - t,
          name: "arrow_nw",
          ...(i && { config: i }),
        }),
        southEastArrowNorthMiddleWest: (e, n) => ({
          top: o(e),
          left: e.right - 0.25 * n.width - t,
          name: "arrow_nmw",
          ...(i && { config: i }),
        }),
        southEastArrowNorth: (t, e) => ({
          top: o(t),
          left: t.right - e.width / 2,
          name: "arrow_n",
          ...(i && { config: i }),
        }),
        southEastArrowNorthMiddleEast: (e, n) => ({
          top: o(e),
          left: e.right - 0.75 * n.width + t,
          name: "arrow_nme",
          ...(i && { config: i }),
        }),
        southEastArrowNorthEast: (e, n) => ({
          top: o(e),
          left: e.right - n.width + t,
          name: "arrow_ne",
          ...(i && { config: i }),
        }),
        viewportStickyNorth: (t, e, s) =>
          t.getIntersection(s)
            ? {
                top: s.top + n,
                left: t.left + t.width / 2 - e.width / 2,
                name: "arrowless",
                config: { withArrow: !1, ...i },
              }
            : null,
      };
      function s(t, n) {
        return t.top - n.height - e;
      }
      function o(t) {
        return t.bottom + e;
      }
    }
    (d.arrowHorizontalOffset = 25),
      (d.arrowVerticalOffset = 10),
      (d.stickyVerticalOffset = 20),
      (d._getOptimalPosition = s.a),
      (d.defaultPositions = f());
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(218);
    function s(t, e, n) {
      n =
        n ||
        function (t, e) {
          return t === e;
        };
      const i = t.length,
        o = e.length;
      if (i > 200 || o > 200 || i + o > 300) return s.fastDiff(t, e, n, !0);
      let r, a;
      if (o < i) {
        const n = t;
        (t = e), (e = n), (r = "delete"), (a = "insert");
      } else (r = "insert"), (a = "delete");
      const c = t.length,
        l = e.length,
        u = l - c,
        d = {},
        h = {};
      function f(i) {
        const s = (void 0 !== h[i - 1] ? h[i - 1] : -1) + 1,
          o = void 0 !== h[i + 1] ? h[i + 1] : -1,
          u = s > o ? -1 : 1;
        d[i + u] && (d[i] = d[i + u].slice(0)),
          d[i] || (d[i] = []),
          d[i].push(s > o ? r : a);
        let f = Math.max(s, o),
          m = f - i;
        for (; m < c && f < l && n(t[m], e[f]); ) m++, f++, d[i].push("equal");
        return f;
      }
      let m,
        g = 0;
      do {
        for (m = -g; m < u; m++) h[m] = f(m);
        for (m = u + g; m > u; m--) h[m] = f(m);
        (h[u] = f(u)), g++;
      } while (h[u] !== l);
      return d[u].slice(1);
    }
    s.fastDiff = i.a;
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return l;
    });
    var i = n(1),
      s = n(2),
      o = n(16),
      r = n(98),
      a = n(31),
      c = n(10);
    n(359);
    class l extends i.j {
      static get pluginName() {
        return "TableSelection";
      }
      static get requires() {
        return [r.a];
      }
      init() {
        const t = this.editor.model;
        this.listenTo(
          t,
          "deleteContent",
          (t, e) => this._handleDeleteContent(t, e),
          { priority: "high" }
        ),
          this._defineSelectionConverter(),
          this._enablePluginDisabling();
      }
      getSelectedTableCells() {
        const t = this.editor.model.document.selection,
          e = Object(c.c)(t);
        return 0 == e.length ? null : e;
      }
      getSelectionAsFragment() {
        const t = this.getSelectedTableCells();
        return t
          ? this.editor.model.change((e) => {
              const n = e.createDocumentFragment(),
                i = this.editor.plugins.get("TableUtils"),
                { first: s, last: o } = Object(c.a)(t),
                { first: r, last: l } = Object(c.b)(t),
                u = t[0].findAncestor("table");
              let d = l,
                h = o;
              if (Object(c.f)(t, i)) {
                const t = {
                  firstColumn: s,
                  lastColumn: o,
                  firstRow: r,
                  lastRow: l,
                };
                (d = Object(a.b)(u, t)), (h = Object(a.a)(u, t));
              }
              const f = {
                  startRow: r,
                  startColumn: s,
                  endRow: d,
                  endColumn: h,
                },
                m = Object(a.c)(u, f, e);
              return e.insert(m, n, 0), n;
            })
          : null;
      }
      setCellSelection(t, e) {
        const n = this._getCellsToSelect(t, e);
        this.editor.model.change((t) => {
          t.setSelection(
            n.cells.map((e) => t.createRangeOn(e)),
            { backward: n.backward }
          );
        });
      }
      getFocusCell() {
        const t = [...this.editor.model.document.selection.getRanges()]
          .pop()
          .getContainedElement();
        return t && t.is("element", "tableCell") ? t : null;
      }
      getAnchorCell() {
        const t = this.editor.model.document.selection,
          e = Object(s.n)(t.getRanges()).getContainedElement();
        return e && e.is("element", "tableCell") ? e : null;
      }
      _defineSelectionConverter() {
        const t = this.editor,
          e = new Set();
        t.conversion.for("editingDowncast").add((t) =>
          t.on(
            "selection",
            (t, n, i) => {
              const s = i.writer;
              !(function (t) {
                for (const n of e)
                  t.removeClass("ck-editor__editable_selected", n);
                e.clear();
              })(s);
              const o = this.getSelectedTableCells();
              if (!o) return;
              for (const t of o) {
                const n = i.mapper.toViewElement(t);
                s.addClass("ck-editor__editable_selected", n), e.add(n);
              }
              const r = i.mapper.toViewElement(o[o.length - 1]);
              s.setSelection(r, 0);
            },
            { priority: "lowest" }
          )
        );
      }
      _enablePluginDisabling() {
        const t = this.editor;
        this.on("change:isEnabled", () => {
          if (!this.isEnabled) {
            const e = this.getSelectedTableCells();
            if (!e) return;
            t.model.change((n) => {
              const i = n.createPositionAt(e[0], 0),
                s = t.model.schema.getNearestSelectionRange(i);
              n.setSelection(s);
            });
          }
        });
      }
      _handleDeleteContent(t, e) {
        const [n, i] = e,
          s = this.editor.model,
          o = !i || "backward" == i.direction,
          r = Object(c.c)(n);
        r.length &&
          (t.stop(),
          s.change((t) => {
            const e = r[o ? r.length - 1 : 0];
            s.change((t) => {
              for (const e of r) s.deleteContent(t.createSelection(e, "in"));
            });
            const i = s.schema.getNearestSelectionRange(
              t.createPositionAt(e, 0)
            );
            n.is("documentSelection") ? t.setSelection(i) : n.setTo(i);
          }));
      }
      _getCellsToSelect(t, e) {
        const n = this.editor.plugins.get("TableUtils"),
          i = n.getCellLocation(t),
          s = n.getCellLocation(e),
          r = Math.min(i.row, s.row),
          a = Math.max(i.row, s.row),
          c = Math.min(i.column, s.column),
          l = Math.max(i.column, s.column),
          u = new Array(a - r + 1).fill(null).map(() => []),
          d = { startRow: r, endRow: a, startColumn: c, endColumn: l };
        for (const { row: e, cell: n } of new o.a(t.findAncestor("table"), d))
          u[e - r].push(n);
        const h = s.row < i.row,
          f = s.column < i.column;
        return (
          h && u.reverse(),
          f && u.forEach((t) => t.reverse()),
          { cells: u.flat(), backward: h || f }
        );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    }),
      n.d(e, "c", function () {
        return o;
      }),
      n.d(e, "b", function () {
        return r;
      });
    var i = n(2);
    function s(t, e) {
      const n = t.createEmptyElement("img"),
        i =
          "imageBlock" === e
            ? t.createContainerElement("figure", { class: "image" })
            : t.createContainerElement(
                "span",
                { class: "image-inline" },
                { isAllowedInsideAttributeElement: !0 }
              );
      return t.insert(t.createPositionAt(i, 0), n), i;
    }
    function o(t, e) {
      if (
        t.plugins.has("ImageInlineEditing") !==
        t.plugins.has("ImageBlockEditing")
      )
        return { name: "img" };
      const n = t.plugins.get("ImageUtils");
      return (t) => {
        if (!n.isInlineImageView(t)) return null;
        return (t.findAncestor(n.isBlockImageView)
          ? "imageBlock"
          : "imageInline") !== e
          ? null
          : { name: !0 };
      };
    }
    function r(t, e) {
      const n = Object(i.n)(e.getSelectedBlocks());
      return !n || t.isObject(n) || (n.isEmpty && "listItem" != n.name)
        ? "imageBlock"
        : "imageInline";
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return c;
    });
    var i = n(25),
      s = n(81),
      o = n(6),
      r = n(39),
      a = n(11);
    class c {
      constructor(t, e) {
        (this.document = t),
          (this._children = []),
          e && this._insertChild(0, e);
      }
      [Symbol.iterator]() {
        return this._children[Symbol.iterator]();
      }
      get childCount() {
        return this._children.length;
      }
      get isEmpty() {
        return 0 === this.childCount;
      }
      get root() {
        return this;
      }
      get parent() {
        return null;
      }
      is(t) {
        return "documentFragment" === t || "view:documentFragment" === t;
      }
      _appendChild(t) {
        return this._insertChild(this.childCount, t);
      }
      getChild(t) {
        return this._children[t];
      }
      getChildIndex(t) {
        return this._children.indexOf(t);
      }
      getChildren() {
        return this._children[Symbol.iterator]();
      }
      _insertChild(t, e) {
        this._fireChange("children", this);
        let n = 0;
        const o = (function (t, e) {
          if ("string" == typeof e) return [new i.a(t, e)];
          Object(r.a)(e) || (e = [e]);
          return Array.from(e).map((e) =>
            "string" == typeof e
              ? new i.a(t, e)
              : e instanceof s.a
              ? new i.a(t, e.data)
              : e
          );
        })(this.document, e);
        for (const e of o)
          null !== e.parent && e._remove(),
            (e.parent = this),
            this._children.splice(t, 0, e),
            t++,
            n++;
        return n;
      }
      _removeChildren(t, e = 1) {
        this._fireChange("children", this);
        for (let n = t; n < t + e; n++) this._children[n].parent = null;
        return this._children.splice(t, e);
      }
      _fireChange(t, e) {
        this.fire("change:" + t, e);
      }
    }
    Object(o.default)(c, a.default);
  },
  function (t, e, n) {
    "use strict";
    e.a = function (t, e) {
      return t === e || (t != t && e != e);
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(73),
      s = n(0),
      o = n(37);
    n(133);
    class r {
      constructor(t) {
        (this.parent = null), (this._attrs = Object(i.a)(t));
      }
      get index() {
        let t;
        if (!this.parent) return null;
        if (null === (t = this.parent.getChildIndex(this)))
          throw new s.default("model-node-not-found-in-parent", this);
        return t;
      }
      get startOffset() {
        let t;
        if (!this.parent) return null;
        if (null === (t = this.parent.getChildStartOffset(this)))
          throw new s.default("model-node-not-found-in-parent", this);
        return t;
      }
      get offsetSize() {
        return 1;
      }
      get endOffset() {
        return this.parent ? this.startOffset + this.offsetSize : null;
      }
      get nextSibling() {
        const t = this.index;
        return (null !== t && this.parent.getChild(t + 1)) || null;
      }
      get previousSibling() {
        const t = this.index;
        return (null !== t && this.parent.getChild(t - 1)) || null;
      }
      get root() {
        let t = this;
        for (; t.parent; ) t = t.parent;
        return t;
      }
      isAttached() {
        return this.root.is("rootElement");
      }
      getPath() {
        const t = [];
        let e = this;
        for (; e.parent; ) t.unshift(e.startOffset), (e = e.parent);
        return t;
      }
      getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
        const e = [];
        let n = t.includeSelf ? this : this.parent;
        for (; n; ) e[t.parentFirst ? "push" : "unshift"](n), (n = n.parent);
        return e;
      }
      getCommonAncestor(t, e = {}) {
        const n = this.getAncestors(e),
          i = t.getAncestors(e);
        let s = 0;
        for (; n[s] == i[s] && n[s]; ) s++;
        return 0 === s ? null : n[s - 1];
      }
      isBefore(t) {
        if (this == t) return !1;
        if (this.root !== t.root) return !1;
        const e = this.getPath(),
          n = t.getPath(),
          i = Object(o.a)(e, n);
        switch (i) {
          case "prefix":
            return !0;
          case "extension":
            return !1;
          default:
            return e[i] < n[i];
        }
      }
      isAfter(t) {
        return this != t && this.root === t.root && !this.isBefore(t);
      }
      hasAttribute(t) {
        return this._attrs.has(t);
      }
      getAttribute(t) {
        return this._attrs.get(t);
      }
      getAttributes() {
        return this._attrs.entries();
      }
      getAttributeKeys() {
        return this._attrs.keys();
      }
      toJSON() {
        const t = {};
        return (
          this._attrs.size &&
            (t.attributes = Array.from(this._attrs).reduce(
              (t, e) => ((t[e[0]] = e[1]), t),
              {}
            )),
          t
        );
      }
      is(t) {
        return "node" === t || "model:node" === t;
      }
      _clone() {
        return new r(this._attrs);
      }
      _remove() {
        this.parent._removeChildren(this.index);
      }
      _setAttribute(t, e) {
        this._attrs.set(t, e);
      }
      _setAttributesTo(t) {
        this._attrs = Object(i.a)(t);
      }
      _removeAttribute(t) {
        return this._attrs.delete(t);
      }
      _clearAttributes() {
        this._attrs.clear();
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(3),
      s = n(11),
      o = n(6);
    class r extends i.a {
      constructor(t, e) {
        super(t, e), a.call(this);
      }
      detach() {
        this.stopListening();
      }
      is(t) {
        return (
          "liveRange" === t ||
          "model:liveRange" === t ||
          "range" == t ||
          "model:range" === t
        );
      }
      toRange() {
        return new i.a(this.start, this.end);
      }
      static fromRange(t) {
        return new r(t.start, t.end);
      }
    }
    function a() {
      this.listenTo(
        this.root.document.model,
        "applyOperation",
        (t, e) => {
          const n = e[0];
          n.isDocumentOperation && c.call(this, n);
        },
        { priority: "low" }
      );
    }
    function c(t) {
      const e = this.getTransformedByOperation(t),
        n = i.a._createFromRanges(e),
        s = !n.isEqual(this),
        o = (function (t, e) {
          switch (e.type) {
            case "insert":
              return t.containsPosition(e.position);
            case "move":
            case "remove":
            case "reinsert":
            case "merge":
              return (
                t.containsPosition(e.sourcePosition) ||
                t.start.isEqual(e.sourcePosition) ||
                t.containsPosition(e.targetPosition)
              );
            case "split":
              return (
                t.containsPosition(e.splitPosition) ||
                t.containsPosition(e.insertionPosition)
              );
          }
          return !1;
        })(this, t);
      let r = null;
      if (s) {
        "$graveyard" == n.root.rootName &&
          (r = "remove" == t.type ? t.sourcePosition : t.deletionPosition);
        const e = this.toRange();
        (this.start = n.start),
          (this.end = n.end),
          this.fire("change:range", e, { deletionPosition: r });
      } else
        o &&
          this.fire("change:content", this.toRange(), { deletionPosition: r });
    }
    Object(o.default)(r, s.default);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(9),
      s = n(74),
      o = n(159);
    const r = ["figcaption", "li"];
    class a extends i.a {
      static get pluginName() {
        return "ClipboardPipeline";
      }
      init() {
        this.editor.editing.view.addObserver(o.a),
          this._setupPasteDrop(),
          this._setupCopyCut();
      }
      _setupPasteDrop() {
        const t = this.editor,
          e = t.model,
          n = t.editing.view,
          i = n.document;
        this.listenTo(
          i,
          "clipboardInput",
          (e) => {
            t.isReadOnly && e.stop();
          },
          { priority: "highest" }
        ),
          this.listenTo(
            i,
            "clipboardInput",
            (t, e) => {
              const i = e.dataTransfer;
              let o = e.content || "";
              var r;
              o ||
                (i.getData("text/html")
                  ? (o = (function (t) {
                      return t
                        .replace(
                          /<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g,
                          (t, e) => (1 == e.length ? " " : e)
                        )
                        .replace(/<!--[\s\S]*?-->/g, "");
                    })(i.getData("text/html")))
                  : i.getData("text/plain") &&
                    (((r = (r = i.getData("text/plain"))
                      .replace(/</g, "&lt;")
                      .replace(/>/g, "&gt;")
                      .replace(/\r?\n\r?\n/g, "</p><p>")
                      .replace(/\r?\n/g, "<br>")
                      .replace(/^\s/, "&nbsp;")
                      .replace(/\s$/, "&nbsp;")
                      .replace(/\s\s/g, " &nbsp;")).includes("</p><p>") ||
                      r.includes("<br>")) &&
                      (r = `<p>${r}</p>`),
                    (o = r)),
                (o = this.editor.data.htmlProcessor.toView(o)));
              const a = new s.a(this, "inputTransformation");
              this.fire(a, {
                content: o,
                dataTransfer: i,
                targetRanges: e.targetRanges,
                method: e.method,
              }),
                a.stop.called && t.stop(),
                n.scrollToTheSelection();
            },
            { priority: "low" }
          ),
          this.listenTo(
            this,
            "inputTransformation",
            (t, n) => {
              if (n.content.isEmpty) return;
              const i = this.editor.data.toModel(n.content, "$clipboardHolder");
              0 != i.childCount &&
                (t.stop(),
                e.change(() => {
                  this.fire("contentInsertion", {
                    content: i,
                    method: n.method,
                    dataTransfer: n.dataTransfer,
                    targetRanges: n.targetRanges,
                  });
                }));
            },
            { priority: "low" }
          ),
          this.listenTo(
            this,
            "contentInsertion",
            (t, n) => {
              n.resultRange = e.insertContent(n.content);
            },
            { priority: "low" }
          );
      }
      _setupCopyCut() {
        const t = this.editor,
          e = t.model.document,
          n = t.editing.view.document;
        function i(i, s) {
          const o = s.dataTransfer;
          s.preventDefault();
          const r = t.data.toView(t.model.getSelectedContent(e.selection));
          n.fire("clipboardOutput", {
            dataTransfer: o,
            content: r,
            method: i.name,
          });
        }
        this.listenTo(n, "copy", i, { priority: "low" }),
          this.listenTo(
            n,
            "cut",
            (e, n) => {
              t.isReadOnly ? n.preventDefault() : i(e, n);
            },
            { priority: "low" }
          ),
          this.listenTo(
            n,
            "clipboardOutput",
            (n, i) => {
              i.content.isEmpty ||
                (i.dataTransfer.setData(
                  "text/html",
                  this.editor.data.htmlProcessor.toData(i.content)
                ),
                i.dataTransfer.setData(
                  "text/plain",
                  (function t(e) {
                    let n = "";
                    if (e.is("$text") || e.is("$textProxy")) n = e.data;
                    else if (e.is("element", "img") && e.hasAttribute("alt"))
                      n = e.getAttribute("alt");
                    else if (e.is("element", "br")) n = "\n";
                    else {
                      let i = null;
                      for (const s of e.getChildren()) {
                        const e = t(s);
                        i &&
                          (i.is("containerElement") ||
                            s.is("containerElement")) &&
                          (r.includes(i.name) || r.includes(s.name)
                            ? (n += "\n")
                            : (n += "\n\n")),
                          (n += e),
                          (i = s);
                      }
                    }
                    return n;
                  })(i.content)
                )),
                "cut" == i.method && t.model.deleteContent(e.selection);
            },
            { priority: "low" }
          );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(88),
      s = n(0);
    class o {
      constructor(t) {
        (this._nodes = []), t && this._insertNodes(0, t);
      }
      [Symbol.iterator]() {
        return this._nodes[Symbol.iterator]();
      }
      get length() {
        return this._nodes.length;
      }
      get maxOffset() {
        return this._nodes.reduce((t, e) => t + e.offsetSize, 0);
      }
      getNode(t) {
        return this._nodes[t] || null;
      }
      getNodeIndex(t) {
        const e = this._nodes.indexOf(t);
        return -1 == e ? null : e;
      }
      getNodeStartOffset(t) {
        const e = this.getNodeIndex(t);
        return null === e
          ? null
          : this._nodes.slice(0, e).reduce((t, e) => t + e.offsetSize, 0);
      }
      indexToOffset(t) {
        if (t == this._nodes.length) return this.maxOffset;
        const e = this._nodes[t];
        if (!e) throw new s.default("model-nodelist-index-out-of-bounds", this);
        return this.getNodeStartOffset(e);
      }
      offsetToIndex(t) {
        let e = 0;
        for (const n of this._nodes) {
          if (t >= e && t < e + n.offsetSize) return this.getNodeIndex(n);
          e += n.offsetSize;
        }
        if (e != t)
          throw new s.default("model-nodelist-offset-out-of-bounds", this, {
            offset: t,
            nodeList: this,
          });
        return this.length;
      }
      _insertNodes(t, e) {
        for (const t of e)
          if (!(t instanceof i.a))
            throw new s.default("model-nodelist-insertnodes-not-node", this);
        this._nodes.splice(t, 0, ...e);
      }
      _removeNodes(t, e = 1) {
        return this._nodes.splice(t, e);
      }
      toJSON() {
        return this._nodes.map((t) => t.toJSON());
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return u;
    });
    var i = n(5),
      s = n(88),
      o = n(3),
      r = n(11),
      a = n(0),
      c = n(6),
      l = n(39);
    class u {
      constructor(t, e, n) {
        (this._lastRangeBackward = !1),
          (this._ranges = []),
          (this._attrs = new Map()),
          t && this.setTo(t, e, n);
      }
      get anchor() {
        if (this._ranges.length > 0) {
          const t = this._ranges[this._ranges.length - 1];
          return this._lastRangeBackward ? t.end : t.start;
        }
        return null;
      }
      get focus() {
        if (this._ranges.length > 0) {
          const t = this._ranges[this._ranges.length - 1];
          return this._lastRangeBackward ? t.start : t.end;
        }
        return null;
      }
      get isCollapsed() {
        return 1 === this._ranges.length && this._ranges[0].isCollapsed;
      }
      get rangeCount() {
        return this._ranges.length;
      }
      get isBackward() {
        return !this.isCollapsed && this._lastRangeBackward;
      }
      isEqual(t) {
        if (this.rangeCount != t.rangeCount) return !1;
        if (0 === this.rangeCount) return !0;
        if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus))
          return !1;
        for (const e of this._ranges) {
          let n = !1;
          for (const i of t._ranges)
            if (e.isEqual(i)) {
              n = !0;
              break;
            }
          if (!n) return !1;
        }
        return !0;
      }
      *getRanges() {
        for (const t of this._ranges) yield new o.a(t.start, t.end);
      }
      getFirstRange() {
        let t = null;
        for (const e of this._ranges)
          (t && !e.start.isBefore(t.start)) || (t = e);
        return t ? new o.a(t.start, t.end) : null;
      }
      getLastRange() {
        let t = null;
        for (const e of this._ranges) (t && !e.end.isAfter(t.end)) || (t = e);
        return t ? new o.a(t.start, t.end) : null;
      }
      getFirstPosition() {
        const t = this.getFirstRange();
        return t ? t.start.clone() : null;
      }
      getLastPosition() {
        const t = this.getLastRange();
        return t ? t.end.clone() : null;
      }
      setTo(t, e, n) {
        if (null === t) this._setRanges([]);
        else if (t instanceof u) this._setRanges(t.getRanges(), t.isBackward);
        else if (t && "function" == typeof t.getRanges)
          this._setRanges(t.getRanges(), t.isBackward);
        else if (t instanceof o.a) this._setRanges([t], !!e && !!e.backward);
        else if (t instanceof i.a) this._setRanges([new o.a(t)]);
        else if (t instanceof s.a) {
          const s = !!n && !!n.backward;
          let r;
          if ("in" == e) r = o.a._createIn(t);
          else if ("on" == e) r = o.a._createOn(t);
          else {
            if (void 0 === e)
              throw new a.default(
                "model-selection-setto-required-second-parameter",
                [this, t]
              );
            r = new o.a(i.a._createAt(t, e));
          }
          this._setRanges([r], s);
        } else {
          if (!Object(l.a)(t))
            throw new a.default("model-selection-setto-not-selectable", [
              this,
              t,
            ]);
          this._setRanges(t, e && !!e.backward);
        }
      }
      _setRanges(t, e = !1) {
        const n = (t = Array.from(t)).some((e) => {
          if (!(e instanceof o.a))
            throw new a.default("model-selection-set-ranges-not-range", [
              this,
              t,
            ]);
          return this._ranges.every((t) => !t.isEqual(e));
        });
        if (t.length !== this._ranges.length || n) {
          this._removeAllRanges();
          for (const e of t) this._pushRange(e);
          (this._lastRangeBackward = !!e),
            this.fire("change:range", { directChange: !0 });
        }
      }
      setFocus(t, e) {
        if (null === this.anchor)
          throw new a.default("model-selection-setfocus-no-ranges", [this, t]);
        const n = i.a._createAt(t, e);
        if ("same" == n.compareWith(this.focus)) return;
        const s = this.anchor;
        this._ranges.length && this._popRange(),
          "before" == n.compareWith(s)
            ? (this._pushRange(new o.a(n, s)), (this._lastRangeBackward = !0))
            : (this._pushRange(new o.a(s, n)), (this._lastRangeBackward = !1)),
          this.fire("change:range", { directChange: !0 });
      }
      getAttribute(t) {
        return this._attrs.get(t);
      }
      getAttributes() {
        return this._attrs.entries();
      }
      getAttributeKeys() {
        return this._attrs.keys();
      }
      hasAttribute(t) {
        return this._attrs.has(t);
      }
      removeAttribute(t) {
        this.hasAttribute(t) &&
          (this._attrs.delete(t),
          this.fire("change:attribute", {
            attributeKeys: [t],
            directChange: !0,
          }));
      }
      setAttribute(t, e) {
        this.getAttribute(t) !== e &&
          (this._attrs.set(t, e),
          this.fire("change:attribute", {
            attributeKeys: [t],
            directChange: !0,
          }));
      }
      getSelectedElement() {
        return 1 !== this.rangeCount
          ? null
          : this.getFirstRange().getContainedElement();
      }
      is(t) {
        return "selection" === t || "model:selection" === t;
      }
      *getSelectedBlocks() {
        const t = new WeakSet();
        for (const e of this.getRanges()) {
          const n = f(e.start, t);
          n && m(n, e) && (yield n);
          for (const n of e.getWalker()) {
            const i = n.item;
            "elementEnd" == n.type && h(i, t, e) && (yield i);
          }
          const s = f(e.end, t);
          s && !e.end.isTouching(i.a._createAt(s, 0)) && m(s, e) && (yield s);
        }
      }
      containsEntireContent(t = this.anchor.root) {
        const e = i.a._createAt(t, 0),
          n = i.a._createAt(t, "end");
        return (
          e.isTouching(this.getFirstPosition()) &&
          n.isTouching(this.getLastPosition())
        );
      }
      _pushRange(t) {
        this._checkRange(t), this._ranges.push(new o.a(t.start, t.end));
      }
      _checkRange(t) {
        for (let e = 0; e < this._ranges.length; e++)
          if (t.isIntersecting(this._ranges[e]))
            throw new a.default("model-selection-range-intersects", [this, t], {
              addedRange: t,
              intersectingRange: this._ranges[e],
            });
      }
      _removeAllRanges() {
        for (; this._ranges.length > 0; ) this._popRange();
      }
      _popRange() {
        this._ranges.pop();
      }
    }
    function d(t, e) {
      return (
        !e.has(t) &&
        (e.add(t), t.root.document.model.schema.isBlock(t) && t.parent)
      );
    }
    function h(t, e, n) {
      return d(t, e) && m(t, n);
    }
    function f(t, e) {
      const n = t.parent.root.document.model.schema,
        i = t.parent.getAncestors({ parentFirst: !0, includeSelf: !0 });
      let s = !1;
      const o = i.find((t) => !s && ((s = n.isLimit(t)), !s && d(t, e)));
      return i.forEach((t) => e.add(t)), o;
    }
    function m(t, e) {
      const n = (function (t) {
        const e = t.root.document.model.schema;
        let n = t.parent;
        for (; n; ) {
          if (e.isBlock(n)) return n;
          n = n.parent;
        }
      })(t);
      if (!n) return !0;
      return !e.containsRange(o.a._createOn(n), !0);
    }
    Object(c.default)(u, r.default);
  },
  function (t, e, n) {
    "use strict";
    function i(t) {
      const { schema: e, document: n } = t.model;
      for (const i of n.getRootNames()) {
        const s = n.getRoot(i);
        if (
          s.isEmpty &&
          !e.checkChild(s, "$text") &&
          e.checkChild(s, "paragraph")
        )
          return t.insertElement("paragraph", s), !0;
      }
      return !1;
    }
    function s(t, e, n) {
      const i = n.createContext(t);
      return (
        !!n.checkChild(i, "paragraph") && !!n.checkChild(i.push("paragraph"), e)
      );
    }
    function o(t, e) {
      const n = e.createElement("paragraph");
      return e.insert(n, t), e.createPositionAt(n, 0);
    }
    n.d(e, "a", function () {
      return i;
    }),
      n.d(e, "b", function () {
        return s;
      }),
      n.d(e, "c", function () {
        return o;
      });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return c;
    });
    var i = n(50),
      s = n(25),
      o = n(81),
      r = n(7),
      a = n(0);
    class c {
      constructor(t = {}) {
        if (!t.boundaries && !t.startPosition)
          throw new a.default("view-tree-walker-no-start-position", null);
        if (
          t.direction &&
          "forward" != t.direction &&
          "backward" != t.direction
        )
          throw new a.default(
            "view-tree-walker-unknown-direction",
            t.startPosition,
            { direction: t.direction }
          );
        (this.boundaries = t.boundaries || null),
          t.startPosition
            ? (this.position = r.a._createAt(t.startPosition))
            : (this.position = r.a._createAt(
                t.boundaries["backward" == t.direction ? "end" : "start"]
              )),
          (this.direction = t.direction || "forward"),
          (this.singleCharacters = !!t.singleCharacters),
          (this.shallow = !!t.shallow),
          (this.ignoreElementEnd = !!t.ignoreElementEnd),
          (this._boundaryStartParent = this.boundaries
            ? this.boundaries.start.parent
            : null),
          (this._boundaryEndParent = this.boundaries
            ? this.boundaries.end.parent
            : null);
      }
      [Symbol.iterator]() {
        return this;
      }
      skip(t) {
        let e, n, i;
        do {
          (i = this.position), ({ done: e, value: n } = this.next());
        } while (!e && t(n));
        e || (this.position = i);
      }
      next() {
        return "forward" == this.direction ? this._next() : this._previous();
      }
      _next() {
        let t = this.position.clone();
        const e = this.position,
          n = t.parent;
        if (null === n.parent && t.offset === n.childCount) return { done: !0 };
        if (
          n === this._boundaryEndParent &&
          t.offset == this.boundaries.end.offset
        )
          return { done: !0 };
        let a;
        if (n instanceof s.a) {
          if (t.isAtEnd)
            return (this.position = r.a._createAfter(n)), this._next();
          a = n.data[t.offset];
        } else a = n.getChild(t.offset);
        if (a instanceof i.a)
          return (
            this.shallow ? t.offset++ : (t = new r.a(a, 0)),
            (this.position = t),
            this._formatReturnValue("elementStart", a, e, t, 1)
          );
        if (a instanceof s.a) {
          if (this.singleCharacters)
            return (t = new r.a(a, 0)), (this.position = t), this._next();
          {
            let n,
              i = a.data.length;
            return (
              a == this._boundaryEndParent
                ? ((i = this.boundaries.end.offset),
                  (n = new o.a(a, 0, i)),
                  (t = r.a._createAfter(n)))
                : ((n = new o.a(a, 0, a.data.length)), t.offset++),
              (this.position = t),
              this._formatReturnValue("text", n, e, t, i)
            );
          }
        }
        if ("string" == typeof a) {
          let i;
          if (this.singleCharacters) i = 1;
          else {
            i =
              (n === this._boundaryEndParent
                ? this.boundaries.end.offset
                : n.data.length) - t.offset;
          }
          const s = new o.a(n, t.offset, i);
          return (
            (t.offset += i),
            (this.position = t),
            this._formatReturnValue("text", s, e, t, i)
          );
        }
        return (
          (t = r.a._createAfter(n)),
          (this.position = t),
          this.ignoreElementEnd
            ? this._next()
            : this._formatReturnValue("elementEnd", n, e, t)
        );
      }
      _previous() {
        let t = this.position.clone();
        const e = this.position,
          n = t.parent;
        if (null === n.parent && 0 === t.offset) return { done: !0 };
        if (
          n == this._boundaryStartParent &&
          t.offset == this.boundaries.start.offset
        )
          return { done: !0 };
        let a;
        if (n instanceof s.a) {
          if (t.isAtStart)
            return (this.position = r.a._createBefore(n)), this._previous();
          a = n.data[t.offset - 1];
        } else a = n.getChild(t.offset - 1);
        if (a instanceof i.a)
          return this.shallow
            ? (t.offset--,
              (this.position = t),
              this._formatReturnValue("elementStart", a, e, t, 1))
            : ((t = new r.a(a, a.childCount)),
              (this.position = t),
              this.ignoreElementEnd
                ? this._previous()
                : this._formatReturnValue("elementEnd", a, e, t));
        if (a instanceof s.a) {
          if (this.singleCharacters)
            return (
              (t = new r.a(a, a.data.length)),
              (this.position = t),
              this._previous()
            );
          {
            let n,
              i = a.data.length;
            if (a == this._boundaryStartParent) {
              const e = this.boundaries.start.offset;
              (n = new o.a(a, e, a.data.length - e)),
                (i = n.data.length),
                (t = r.a._createBefore(n));
            } else (n = new o.a(a, 0, a.data.length)), t.offset--;
            return (
              (this.position = t), this._formatReturnValue("text", n, e, t, i)
            );
          }
        }
        if ("string" == typeof a) {
          let i;
          if (this.singleCharacters) i = 1;
          else {
            const e =
              n === this._boundaryStartParent
                ? this.boundaries.start.offset
                : 0;
            i = t.offset - e;
          }
          t.offset -= i;
          const s = new o.a(n, t.offset, i);
          return (
            (this.position = t), this._formatReturnValue("text", s, e, t, i)
          );
        }
        return (
          (t = r.a._createBefore(n)),
          (this.position = t),
          this._formatReturnValue("elementStart", n, e, t, 1)
        );
      }
      _formatReturnValue(t, e, n, i, s) {
        return (
          e instanceof o.a &&
            (e.offsetInText + e.data.length == e.textNode.data.length &&
              ("forward" != this.direction ||
              (this.boundaries && this.boundaries.end.isEqual(this.position))
                ? (n = r.a._createAfter(e.textNode))
                : ((i = r.a._createAfter(e.textNode)), (this.position = i))),
            0 === e.offsetInText &&
              ("backward" != this.direction ||
              (this.boundaries && this.boundaries.start.isEqual(this.position))
                ? (n = r.a._createBefore(e.textNode))
                : ((i = r.a._createBefore(e.textNode)), (this.position = i)))),
          {
            done: !1,
            value: {
              type: t,
              item: e,
              previousPosition: n,
              nextPosition: i,
              length: s,
            },
          }
        );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "d", function () {
      return h;
    }),
      n.d(e, "e", function () {
        return f;
      }),
      n.d(e, "f", function () {
        return m;
      }),
      n.d(e, "c", function () {
        return p;
      }),
      n.d(e, "b", function () {
        return b;
      }),
      n.d(e, "a", function () {
        return w;
      });
    var i = n(3),
      s = n(92),
      o = n(20),
      r = n(138),
      a = n(53),
      c = n(221),
      l = n(96),
      u = n(0),
      d = n(35);
    class h extends c.a {
      elementToElement(t) {
        return this.add(
          (function (t) {
            return (
              ((t = Object(l.a)(t)).view = _(t.view, "container")),
              (e) => {
                var n;
                if (
                  (e.on(
                    "insert:" + t.model,
                    ((n = t.view),
                    (t, e, i) => {
                      const s = n(e.item, i);
                      if (!s) return;
                      if (!i.consumable.consume(e.item, "insert")) return;
                      const o = i.mapper.toViewPosition(e.range.start);
                      i.mapper.bindElements(e.item, s), i.writer.insert(o, s);
                    }),
                    { priority: t.converterPriority || "normal" }
                  ),
                  t.triggerBy)
                ) {
                  if (t.triggerBy.attributes)
                    for (const n of t.triggerBy.attributes)
                      e._mapReconversionTriggerEvent(
                        t.model,
                        `attribute:${n}:${t.model}`
                      );
                  if (t.triggerBy.children)
                    for (const n of t.triggerBy.children)
                      e._mapReconversionTriggerEvent(t.model, "insert:" + n),
                        e._mapReconversionTriggerEvent(t.model, "remove:" + n);
                }
              }
            );
          })(t)
        );
      }
      attributeToElement(t) {
        return this.add(
          (function (t) {
            t = Object(l.a)(t);
            let e = "attribute:" + (t.model.key ? t.model.key : t.model);
            t.model.name && (e += ":" + t.model.name);
            if (t.model.values)
              for (const e of t.model.values)
                t.view[e] = _(t.view[e], "attribute");
            else t.view = _(t.view, "attribute");
            const n = y(t);
            return (i) => {
              i.on(
                e,
                (function (t) {
                  return (e, n, i) => {
                    const o = t(n.attributeOldValue, i),
                      r = t(n.attributeNewValue, i);
                    if (!o && !r) return;
                    if (!i.consumable.consume(n.item, e.name)) return;
                    const c = i.writer,
                      l = c.document.selection;
                    if (n.item instanceof s.a || n.item instanceof a.a)
                      c.wrap(l.getFirstRange(), r);
                    else {
                      let t = i.mapper.toViewRange(n.range);
                      null !== n.attributeOldValue && o && (t = c.unwrap(t, o)),
                        null !== n.attributeNewValue && r && c.wrap(t, r);
                    }
                  };
                })(n),
                { priority: t.converterPriority || "normal" }
              );
            };
          })(t)
        );
      }
      attributeToAttribute(t) {
        return this.add(
          (function (t) {
            t = Object(l.a)(t);
            let e = "attribute:" + (t.model.key ? t.model.key : t.model);
            t.model.name && (e += ":" + t.model.name);
            if (t.model.values)
              for (const e of t.model.values) t.view[e] = k(t.view[e]);
            else t.view = k(t.view);
            const n = y(t);
            return (i) => {
              var s;
              i.on(
                e,
                ((s = n),
                (t, e, n) => {
                  const i = s(e.attributeOldValue, n),
                    o = s(e.attributeNewValue, n);
                  if (!i && !o) return;
                  if (!n.consumable.consume(e.item, t.name)) return;
                  const r = n.mapper.toViewElement(e.item),
                    a = n.writer;
                  if (!r)
                    throw new u.default(
                      "conversion-attribute-to-attribute-on-text",
                      [e, n]
                    );
                  if (null !== e.attributeOldValue && i)
                    if ("class" == i.key) {
                      const t = Object(d.a)(i.value);
                      for (const e of t) a.removeClass(e, r);
                    } else if ("style" == i.key) {
                      const t = Object.keys(i.value);
                      for (const e of t) a.removeStyle(e, r);
                    } else a.removeAttribute(i.key, r);
                  if (null !== e.attributeNewValue && o)
                    if ("class" == o.key) {
                      const t = Object(d.a)(o.value);
                      for (const e of t) a.addClass(e, r);
                    } else if ("style" == o.key) {
                      const t = Object.keys(o.value);
                      for (const e of t) a.setStyle(e, o.value[e], r);
                    } else a.setAttribute(o.key, o.value, r);
                }),
                { priority: t.converterPriority || "normal" }
              );
            };
          })(t)
        );
      }
      markerToElement(t) {
        return this.add(
          (function (t) {
            return (
              ((t = Object(l.a)(t)).view = _(t.view, "ui")),
              (e) => {
                var n;
                e.on(
                  "addMarker:" + t.model,
                  ((n = t.view),
                  (t, e, i) => {
                    e.isOpening = !0;
                    const s = n(e, i);
                    e.isOpening = !1;
                    const o = n(e, i);
                    if (!s || !o) return;
                    const r = e.markerRange;
                    if (r.isCollapsed && !i.consumable.consume(r, t.name))
                      return;
                    for (const e of r)
                      if (!i.consumable.consume(e.item, t.name)) return;
                    const a = i.mapper,
                      c = i.writer;
                    c.insert(a.toViewPosition(r.start), s),
                      i.mapper.bindElementToMarker(s, e.markerName),
                      r.isCollapsed ||
                        (c.insert(a.toViewPosition(r.end), o),
                        i.mapper.bindElementToMarker(o, e.markerName)),
                      t.stop();
                  }),
                  { priority: t.converterPriority || "normal" }
                ),
                  e.on(
                    "removeMarker:" + t.model,
                    (t.view,
                    (t, e, n) => {
                      const i = n.mapper.markerNameToElements(e.markerName);
                      if (i) {
                        for (const t of i)
                          n.mapper.unbindElementFromMarkerName(t, e.markerName),
                            n.writer.clear(n.writer.createRangeOn(t), t);
                        n.writer.clearClonedElementsGroup(e.markerName),
                          t.stop();
                      }
                    }),
                    { priority: t.converterPriority || "normal" }
                  );
              }
            );
          })(t)
        );
      }
      markerToHighlight(t) {
        return this.add(
          (function (t) {
            return (e) => {
              var n;
              e.on(
                "addMarker:" + t.model,
                ((n = t.view),
                (t, e, i) => {
                  if (!e.item) return;
                  if (
                    !(
                      e.item instanceof s.a ||
                      e.item instanceof a.a ||
                      e.item.is("$textProxy")
                    )
                  )
                    return;
                  const o = A(n, e, i);
                  if (!o) return;
                  if (!i.consumable.consume(e.item, t.name)) return;
                  const r = i.writer,
                    c = g(r, o),
                    l = r.document.selection;
                  if (e.item instanceof s.a || e.item instanceof a.a)
                    r.wrap(l.getFirstRange(), c, l);
                  else {
                    const t = i.mapper.toViewRange(e.range),
                      n = r.wrap(t, c);
                    for (const t of n.getItems())
                      if (t.is("attributeElement") && t.isSimilar(c)) {
                        i.mapper.bindElementToMarker(t, e.markerName);
                        break;
                      }
                  }
                }),
                { priority: t.converterPriority || "normal" }
              ),
                e.on(
                  "addMarker:" + t.model,
                  (function (t) {
                    return (e, n, s) => {
                      if (!n.item) return;
                      if (!(n.item instanceof o.a)) return;
                      const r = A(t, n, s);
                      if (!r) return;
                      if (!s.consumable.test(n.item, e.name)) return;
                      const a = s.mapper.toViewElement(n.item);
                      if (a && a.getCustomProperty("addHighlight")) {
                        s.consumable.consume(n.item, e.name);
                        for (const t of i.a._createIn(n.item))
                          s.consumable.consume(t.item, e.name);
                        a.getCustomProperty("addHighlight")(a, r, s.writer),
                          s.mapper.bindElementToMarker(a, n.markerName);
                      }
                    };
                  })(t.view),
                  { priority: t.converterPriority || "normal" }
                ),
                e.on(
                  "removeMarker:" + t.model,
                  (function (t) {
                    return (e, n, i) => {
                      if (n.markerRange.isCollapsed) return;
                      const s = A(t, n, i);
                      if (!s) return;
                      const o = g(i.writer, s),
                        r = i.mapper.markerNameToElements(n.markerName);
                      if (r) {
                        for (const t of r)
                          i.mapper.unbindElementFromMarkerName(t, n.markerName),
                            t.is("attributeElement")
                              ? i.writer.unwrap(i.writer.createRangeOn(t), o)
                              : t.getCustomProperty("removeHighlight")(
                                  t,
                                  s.id,
                                  i.writer
                                );
                        i.writer.clearClonedElementsGroup(n.markerName),
                          e.stop();
                      }
                    };
                  })(t.view),
                  { priority: t.converterPriority || "normal" }
                );
            };
          })(t)
        );
      }
      markerToData(t) {
        return this.add(
          (function (t) {
            const e = (t = Object(l.a)(t)).model;
            t.view ||
              (t.view = (n) => ({
                group: e,
                name: n.substr(t.model.length + 1),
              }));
            return (n) => {
              var i;
              n.on(
                "addMarker:" + e,
                ((i = t.view),
                (t, e, n) => {
                  const s = i(e.markerName, n);
                  if (!s) return;
                  const o = e.markerRange;
                  n.consumable.consume(o, t.name) &&
                    (v(o, !1, n, e, s), v(o, !0, n, e, s), t.stop());
                }),
                { priority: t.converterPriority || "normal" }
              ),
                n.on(
                  "removeMarker:" + e,
                  (function (t) {
                    return (e, n, i) => {
                      const s = t(n.markerName, i);
                      if (!s) return;
                      const o = i.mapper.markerNameToElements(n.markerName);
                      if (o) {
                        for (const t of o)
                          i.mapper.unbindElementFromMarkerName(t, n.markerName),
                            t.is("containerElement")
                              ? (r(`data-${s.group}-start-before`, t),
                                r(`data-${s.group}-start-after`, t),
                                r(`data-${s.group}-end-before`, t),
                                r(`data-${s.group}-end-after`, t))
                              : i.writer.clear(i.writer.createRangeOn(t), t);
                        i.writer.clearClonedElementsGroup(n.markerName),
                          e.stop();
                      }
                      function r(t, e) {
                        if (e.hasAttribute(t)) {
                          const n = new Set(e.getAttribute(t).split(","));
                          n.delete(s.name),
                            0 == n.size
                              ? i.writer.removeAttribute(t, e)
                              : i.writer.setAttribute(
                                  t,
                                  Array.from(n).join(","),
                                  e
                                );
                        }
                      }
                    };
                  })(t.view),
                  { priority: t.converterPriority || "normal" }
                );
            };
          })(t)
        );
      }
    }
    function f() {
      return (t, e, n) => {
        if (!n.consumable.consume(e.item, "insert")) return;
        const i = n.writer,
          s = n.mapper.toViewPosition(e.range.start),
          o = i.createText(e.item.data);
        i.insert(s, o);
      };
    }
    function m() {
      return (t, e, n) => {
        const i = n.mapper.toViewPosition(e.position),
          s = e.position.getShiftedBy(e.length),
          o = n.mapper.toViewPosition(s, { isPhantom: !0 }),
          r = n.writer.createRange(i, o),
          a = n.writer.remove(r.getTrimmed());
        for (const t of n.writer.createRangeIn(a).getItems())
          n.mapper.unbindViewElement(t);
      };
    }
    function g(t, e) {
      const n = t.createAttributeElement("span", e.attributes);
      return (
        e.classes && n._addClass(e.classes),
        "number" == typeof e.priority && (n._priority = e.priority),
        (n._id = e.id),
        n
      );
    }
    function p() {
      return (t, e, n) => {
        const i = e.selection;
        if (i.isCollapsed) return;
        if (!n.consumable.consume(i, "selection")) return;
        const s = [];
        for (const t of i.getRanges()) {
          const e = n.mapper.toViewRange(t);
          s.push(e);
        }
        n.writer.setSelection(s, { backward: i.isBackward });
      };
    }
    function b() {
      return (t, e, n) => {
        const i = e.selection;
        if (!i.isCollapsed) return;
        if (!n.consumable.consume(i, "selection")) return;
        const s = n.writer,
          o = i.getFirstPosition(),
          r = n.mapper.toViewPosition(o),
          a = s.breakAttributes(r);
        s.setSelection(a);
      };
    }
    function w() {
      return (t, e, n) => {
        const i = n.writer,
          s = i.document.selection;
        for (const t of s.getRanges())
          t.isCollapsed &&
            t.end.parent.isAttached() &&
            n.writer.mergeAttributes(t.start);
        i.setSelection(null);
      };
    }
    function v(t, e, n, i, s) {
      const o = e ? t.start : t.end,
        r = o.nodeAfter && o.nodeAfter.is("element") ? o.nodeAfter : null,
        a = o.nodeBefore && o.nodeBefore.is("element") ? o.nodeBefore : null;
      if (r || a) {
        let t, o;
        (e && r) || (!e && !a) ? ((t = r), (o = !0)) : ((t = a), (o = !1));
        const c = n.mapper.toViewElement(t);
        if (c)
          return void (function (t, e, n, i, s, o) {
            const r = `data-${o.group}-${e ? "start" : "end"}-${
                n ? "before" : "after"
              }`,
              a = t.hasAttribute(r) ? t.getAttribute(r).split(",") : [];
            a.unshift(o.name),
              i.writer.setAttribute(r, a.join(","), t),
              i.mapper.bindElementToMarker(t, s.markerName);
          })(c, e, o, n, i, s);
      }
      !(function (t, e, n, i, s) {
        const o = `${s.group}-${e ? "start" : "end"}`,
          r = s.name ? { name: s.name } : null,
          a = n.writer.createUIElement(o, r);
        n.writer.insert(t, a), n.mapper.bindElementToMarker(a, i.markerName);
      })(n.mapper.toViewPosition(o), e, n, i, s);
    }
    function _(t, e) {
      return "function" == typeof t
        ? t
        : (n, i) =>
            (function (t, e, n) {
              "string" == typeof t && (t = { name: t });
              let i;
              const s = e.writer,
                o = Object.assign({}, t.attributes);
              if ("container" == n) i = s.createContainerElement(t.name, o);
              else if ("attribute" == n) {
                const e = { priority: t.priority || r.a.DEFAULT_PRIORITY };
                i = s.createAttributeElement(t.name, o, e);
              } else i = s.createUIElement(t.name, o);
              if (t.styles) {
                const e = Object.keys(t.styles);
                for (const n of e) s.setStyle(n, t.styles[n], i);
              }
              if (t.classes) {
                const e = t.classes;
                if ("string" == typeof e) s.addClass(e, i);
                else for (const t of e) s.addClass(t, i);
              }
              return i;
            })(t, i, e);
    }
    function y(t) {
      return t.model.values
        ? (e, n) => {
            const i = t.view[e];
            return i ? i(e, n) : null;
          }
        : t.view;
    }
    function k(t) {
      return "string" == typeof t
        ? (e) => ({ key: t, value: e })
        : "object" == typeof t
        ? t.value
          ? () => t
          : (e) => ({ key: t.key, value: e })
        : t;
    }
    function A(t, e, n) {
      const i = "function" == typeof t ? t(e, n) : t;
      return i
        ? (i.priority || (i.priority = 10), i.id || (i.id = e.markerName), i)
        : null;
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(154);
    e.a = function (t) {
      return Object(i.a)(t, 5);
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return b;
    });
    var i = n(8),
      s = n(52),
      o = n(115),
      r = n(69),
      a = n(170);
    class c extends i.a {
      constructor(t) {
        super(t),
          this.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-toolbar__line-break"] },
          });
      }
    }
    var l = n(112);
    function u(t) {
      return t.bindTemplate.to((e) => {
        e.target === t.element && e.preventDefault();
      });
    }
    var d = n(18),
      h = n(27),
      f = n(132),
      m = n(0),
      g = n(116),
      p = n(189);
    n(337);
    class b extends i.a {
      constructor(t, e) {
        super(t);
        const n = this.bindTemplate,
          i = this.t;
        (this.options = e || {}),
          this.set("ariaLabel", i("Editor toolbar")),
          this.set("maxWidth", "auto"),
          (this.items = this.createCollection()),
          (this.focusTracker = new s.a()),
          (this.keystrokes = new r.a()),
          this.set("class"),
          this.set("isCompact", !1),
          (this.itemsView = new w(t)),
          (this.children = this.createCollection()),
          this.children.add(this.itemsView),
          (this.focusables = this.createCollection());
        const a = "rtl" === t.uiLanguageDirection;
        this._focusCycler = new o.a({
          focusables: this.focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            focusPrevious: [a ? "arrowright" : "arrowleft", "arrowup"],
            focusNext: [a ? "arrowleft" : "arrowright", "arrowdown"],
          },
        });
        const c = [
          "ck",
          "ck-toolbar",
          n.to("class"),
          n.if("isCompact", "ck-toolbar_compact"),
        ];
        this.options.shouldGroupWhenFull &&
          this.options.isFloating &&
          c.push("ck-toolbar_floating"),
          this.setTemplate({
            tag: "div",
            attributes: {
              class: c,
              role: "toolbar",
              "aria-label": n.to("ariaLabel"),
              style: { maxWidth: n.to("maxWidth") },
            },
            children: this.children,
            on: { mousedown: u(this) },
          }),
          (this._behavior = this.options.shouldGroupWhenFull
            ? new _(this)
            : new v(this));
      }
      render() {
        super.render();
        for (const t of this.items) this.focusTracker.add(t.element);
        this.items.on("add", (t, e) => {
          this.focusTracker.add(e.element);
        }),
          this.items.on("remove", (t, e) => {
            this.focusTracker.remove(e.element);
          }),
          this.keystrokes.listenTo(this.element),
          this._behavior.render(this);
      }
      destroy() {
        return (
          this._behavior.destroy(),
          this.focusTracker.destroy(),
          this.keystrokes.destroy(),
          super.destroy()
        );
      }
      focus() {
        this._focusCycler.focusFirst();
      }
      focusLast() {
        this._focusCycler.focusLast();
      }
      fillFromConfig(t, e) {
        const n = Object(g.a)(t),
          i = n.items.filter(
            (t, i, s) =>
              "|" === t ||
              (-1 === n.removeItems.indexOf(t) &&
                ("-" === t
                  ? !this.options.shouldGroupWhenFull ||
                    (Object(m.logWarning)(
                      "toolbarview-line-break-ignored-when-grouping-items",
                      s
                    ),
                    !1)
                  : !!e.has(t) ||
                    (Object(m.logWarning)("toolbarview-item-unavailable", {
                      name: t,
                    }),
                    !1)))
          ),
          s = this._cleanSeparators(i).map((t) =>
            "|" === t ? new a.a() : "-" === t ? new c() : e.create(t)
          );
        this.items.addMany(s);
      }
      _cleanSeparators(t) {
        const e = (t) => "-" !== t && "|" !== t,
          n = t.length,
          i = t.findIndex(e),
          s = n - t.slice().reverse().findIndex(e);
        return t.slice(i, s).filter((t, n, i) => {
          if (e(t)) return !0;
          return !(n > 0 && i[n - 1] === t);
        });
      }
    }
    class w extends i.a {
      constructor(t) {
        super(t),
          (this.children = this.createCollection()),
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-toolbar__items"] },
            children: this.children,
          });
      }
    }
    class v {
      constructor(t) {
        const e = t.bindTemplate;
        t.set("isVertical", !1),
          t.itemsView.children.bindTo(t.items).using((t) => t),
          t.focusables.bindTo(t.items).using((t) => t),
          t.extendTemplate({
            attributes: { class: [e.if("isVertical", "ck-toolbar_vertical")] },
          });
      }
      render() {}
      destroy() {}
    }
    class _ {
      constructor(t) {
        (this.view = t),
          (this.viewChildren = t.children),
          (this.viewFocusables = t.focusables),
          (this.viewItemsView = t.itemsView),
          (this.viewFocusTracker = t.focusTracker),
          (this.viewLocale = t.locale),
          (this.ungroupedItems = t.createCollection()),
          (this.groupedItems = t.createCollection()),
          (this.groupedItemsDropdown = this._createGroupedItemsDropdown()),
          (this.resizeObserver = null),
          (this.cachedPadding = null),
          (this.shouldUpdateGroupingOnNextResize = !1),
          t.itemsView.children.bindTo(this.ungroupedItems).using((t) => t),
          this.ungroupedItems.on(
            "add",
            this._updateFocusCycleableItems.bind(this)
          ),
          this.ungroupedItems.on(
            "remove",
            this._updateFocusCycleableItems.bind(this)
          ),
          t.children.on("add", this._updateFocusCycleableItems.bind(this)),
          t.children.on("remove", this._updateFocusCycleableItems.bind(this)),
          t.items.on("change", (t, e) => {
            const n = e.index;
            for (const t of e.removed)
              n >= this.ungroupedItems.length
                ? this.groupedItems.remove(t)
                : this.ungroupedItems.remove(t);
            for (let t = n; t < n + e.added.length; t++) {
              const i = e.added[t - n];
              t > this.ungroupedItems.length
                ? this.groupedItems.add(i, t - this.ungroupedItems.length)
                : this.ungroupedItems.add(i, t);
            }
            this._updateGrouping();
          }),
          t.extendTemplate({ attributes: { class: ["ck-toolbar_grouping"] } });
      }
      render(t) {
        (this.viewElement = t.element),
          this._enableGroupingOnResize(),
          this._enableGroupingOnMaxWidthChange(t);
      }
      destroy() {
        this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy();
      }
      _updateGrouping() {
        if (!this.viewElement.ownerDocument.body.contains(this.viewElement))
          return;
        if (!this.viewElement.offsetParent)
          return void (this.shouldUpdateGroupingOnNextResize = !0);
        const t = this.groupedItems.length;
        let e;
        for (; this._areItemsOverflowing; ) this._groupLastItem(), (e = !0);
        if (!e && this.groupedItems.length) {
          for (; this.groupedItems.length && !this._areItemsOverflowing; )
            this._ungroupFirstItem();
          this._areItemsOverflowing && this._groupLastItem();
        }
        this.groupedItems.length !== t && this.view.fire("groupedItemsUpdate");
      }
      get _areItemsOverflowing() {
        if (!this.ungroupedItems.length) return !1;
        const t = this.viewElement,
          e = this.viewLocale.uiLanguageDirection,
          n = new d.a(t.lastChild),
          i = new d.a(t);
        if (!this.cachedPadding) {
          const n = h.a.window.getComputedStyle(t),
            i = "ltr" === e ? "paddingRight" : "paddingLeft";
          this.cachedPadding = Number.parseInt(n[i]);
        }
        return "ltr" === e
          ? n.right > i.right - this.cachedPadding
          : n.left < i.left + this.cachedPadding;
      }
      _enableGroupingOnResize() {
        let t;
        (this.resizeObserver = new l.a(this.viewElement, (e) => {
          (t &&
            t === e.contentRect.width &&
            !this.shouldUpdateGroupingOnNextResize) ||
            ((this.shouldUpdateGroupingOnNextResize = !1),
            this._updateGrouping(),
            (t = e.contentRect.width));
        })),
          this._updateGrouping();
      }
      _enableGroupingOnMaxWidthChange(t) {
        t.on("change:maxWidth", () => {
          this._updateGrouping();
        });
      }
      _groupLastItem() {
        this.groupedItems.length ||
          (this.viewChildren.add(new a.a()),
          this.viewChildren.add(this.groupedItemsDropdown),
          this.viewFocusTracker.add(this.groupedItemsDropdown.element)),
          this.groupedItems.add(
            this.ungroupedItems.remove(this.ungroupedItems.last),
            0
          );
      }
      _ungroupFirstItem() {
        this.ungroupedItems.add(
          this.groupedItems.remove(this.groupedItems.first)
        ),
          this.groupedItems.length ||
            (this.viewChildren.remove(this.groupedItemsDropdown),
            this.viewChildren.remove(this.viewChildren.last),
            this.viewFocusTracker.remove(this.groupedItemsDropdown.element));
      }
      _createGroupedItemsDropdown() {
        const t = this.viewLocale,
          e = t.t,
          n = Object(f.c)(t);
        return (
          (n.class = "ck-toolbar__grouped-dropdown"),
          (n.panelPosition = "ltr" === t.uiLanguageDirection ? "sw" : "se"),
          Object(f.b)(n, []),
          n.buttonView.set({
            label: e("Show more items"),
            tooltip: !0,
            tooltipPosition: "rtl" === t.uiLanguageDirection ? "se" : "sw",
            icon: p.a,
          }),
          n.toolbarView.items.bindTo(this.groupedItems).using((t) => t),
          n
        );
      }
      _updateFocusCycleableItems() {
        this.viewFocusables.clear(),
          this.ungroupedItems.map((t) => {
            this.viewFocusables.add(t);
          }),
          this.groupedItems.length &&
            this.viewFocusables.add(this.groupedItemsDropdown);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return c;
    });
    var i = n(2),
      s = n(1),
      o = n(16),
      r = n(17),
      a = n(31);
    class c extends s.j {
      static get pluginName() {
        return "TableUtils";
      }
      init() {
        this.decorate("insertColumns"), this.decorate("insertRows");
      }
      getCellLocation(t) {
        const e = t.parent,
          n = e.parent,
          i = n.getChildIndex(e),
          s = new o.a(n, { row: i });
        for (const { cell: e, row: n, column: i } of s)
          if (e === t) return { row: n, column: i };
      }
      createTable(t, e) {
        const n = t.createElement("table"),
          i = parseInt(e.rows) || 2,
          s = parseInt(e.columns) || 2;
        return (
          l(t, n, 0, i, s),
          e.headingRows &&
            Object(r.c)("headingRows", Math.min(e.headingRows, i), n, t, 0),
          e.headingColumns &&
            Object(r.c)(
              "headingColumns",
              Math.min(e.headingColumns, s),
              n,
              t,
              0
            ),
          n
        );
      }
      insertRows(t, e = {}) {
        const n = this.editor.model,
          s = e.at || 0,
          a = e.rows || 1,
          c = void 0 !== e.copyStructureFromAbove,
          u = e.copyStructureFromAbove ? s - 1 : s,
          d = this.getRows(t),
          h = this.getColumns(t);
        if (s > d)
          throw new i.a("tableutils-insertrows-insert-out-of-range", this, {
            options: e,
          });
        n.change((e) => {
          const n = t.getAttribute("headingRows") || 0;
          if (
            (n > s && Object(r.c)("headingRows", n + a, t, e, 0),
            !c && (0 === s || s === d))
          )
            return void l(e, t, s, a, h);
          const i = c ? Math.max(s, u) : s,
            f = new o.a(t, { endRow: i }),
            m = new Array(h).fill(1);
          for (const {
            row: t,
            column: n,
            cellHeight: i,
            cellWidth: o,
            cell: r,
          } of f) {
            const l = t + i - 1,
              d = t <= u && u <= l;
            t < s && s <= l
              ? (e.setAttribute("rowspan", i + a, r), (m[n] = -o))
              : c && d && (m[n] = o);
          }
          for (let n = 0; n < a; n++) {
            const n = e.createElement("tableRow");
            e.insert(n, t, s);
            for (let t = 0; t < m.length; t++) {
              const i = m[t],
                s = e.createPositionAt(n, "end");
              i > 0 && Object(r.a)(e, s, i > 1 ? { colspan: i } : null),
                (t += Math.abs(i) - 1);
            }
          }
        });
      }
      insertColumns(t, e = {}) {
        const n = this.editor.model,
          i = e.at || 0,
          s = e.columns || 1;
        n.change((e) => {
          const n = t.getAttribute("headingColumns");
          i < n && e.setAttribute("headingColumns", n + s, t);
          const r = this.getColumns(t);
          if (0 === i || r === i) {
            for (const n of t.getChildren())
              n.is("element", "tableRow") &&
                u(s, e, e.createPositionAt(n, i ? "end" : 0));
            return;
          }
          const a = new o.a(t, { column: i, includeAllSlots: !0 });
          for (const t of a) {
            const {
              row: n,
              cell: o,
              cellAnchorColumn: r,
              cellAnchorRow: c,
              cellWidth: l,
              cellHeight: d,
            } = t;
            if (r < i) {
              e.setAttribute("colspan", l + s, o);
              const t = c + d - 1;
              for (let e = n; e <= t; e++) a.skipRow(e);
            } else u(s, e, t.getPositionBefore());
          }
        });
      }
      removeRows(t, e) {
        const n = this.editor.model,
          s = e.rows || 1,
          c = this.getRows(t),
          l = e.at,
          u = l + s - 1;
        if (u > c - 1)
          throw new i.a("tableutils-removerows-row-index-out-of-range", this, {
            table: t,
            options: e,
          });
        n.change((e) => {
          const { cellsToMove: n, cellsToTrim: i } = (function (t, e, n) {
            const i = new Map(),
              s = [];
            for (const { row: r, column: a, cellHeight: c, cell: l } of new o.a(
              t,
              { endRow: n }
            )) {
              const t = r + c - 1;
              if (r >= e && r <= n && t > n) {
                const t = c - (n - r + 1);
                i.set(a, { cell: l, rowspan: t });
              }
              if (r < e && t >= e) {
                let i;
                (i = t >= n ? n - e + 1 : t - e + 1),
                  s.push({ cell: l, rowspan: c - i });
              }
            }
            return { cellsToMove: i, cellsToTrim: s };
          })(t, l, u);
          if (n.size) {
            !(function (t, e, n, i) {
              const s = [...new o.a(t, { includeAllSlots: !0, row: e })],
                a = t.getChild(e);
              let c;
              for (const { column: t, cell: e, isAnchor: o } of s)
                if (n.has(t)) {
                  const { cell: e, rowspan: s } = n.get(t),
                    o = c ? i.createPositionAfter(c) : i.createPositionAt(a, 0);
                  i.move(i.createRangeOn(e), o),
                    Object(r.c)("rowspan", s, e, i),
                    (c = e);
                } else o && (c = e);
            })(t, u + 1, n, e);
          }
          for (let n = u; n >= l; n--) e.remove(t.getChild(n));
          for (const { rowspan: t, cell: n } of i)
            Object(r.c)("rowspan", t, n, e);
          !(function (t, e, n, i) {
            const s = t.getAttribute("headingRows") || 0;
            if (e < s) {
              const o = n < s ? s - (n - e + 1) : e;
              Object(r.c)("headingRows", o, t, i, 0);
            }
          })(t, l, u, e),
            Object(a.f)(t, this) || Object(a.g)(t, this);
        });
      }
      removeColumns(t, e) {
        const n = this.editor.model,
          i = e.at,
          s = e.columns || 1,
          c = e.at + s - 1;
        n.change((e) => {
          !(function (t, e, n) {
            const i = t.getAttribute("headingColumns") || 0;
            if (i && e.first < i) {
              const s = Math.min(i - 1, e.last) - e.first + 1;
              n.setAttribute("headingColumns", i - s, t);
            }
          })(t, { first: i, last: c }, e);
          for (let n = c; n >= i; n--)
            for (const { cell: i, column: s, cellWidth: a } of [...new o.a(t)])
              s <= n && a > 1 && s + a > n
                ? Object(r.c)("colspan", a - 1, i, e)
                : s === n && e.remove(i);
          Object(a.g)(t, this) || Object(a.f)(t, this);
        });
      }
      splitCellVertically(t, e = 2) {
        const n = this.editor.model,
          i = t.parent.parent,
          s = parseInt(t.getAttribute("rowspan") || 1),
          a = parseInt(t.getAttribute("colspan") || 1);
        n.change((n) => {
          if (a > 1) {
            const { newCellsSpan: i, updatedSpan: o } = d(a, e);
            Object(r.c)("colspan", o, t, n);
            const c = {};
            i > 1 && (c.colspan = i), s > 1 && (c.rowspan = s);
            u(a > e ? e - 1 : a - 1, n, n.createPositionAfter(t), c);
          }
          if (a < e) {
            const c = e - a,
              l = [...new o.a(i)],
              { column: d } = l.find(({ cell: e }) => e === t),
              h = l.filter(
                ({ cell: e, cellWidth: n, column: i }) =>
                  (e !== t && i === d) || (i < d && i + n > d)
              );
            for (const { cell: t, cellWidth: e } of h)
              n.setAttribute("colspan", e + c, t);
            const f = {};
            s > 1 && (f.rowspan = s), u(c, n, n.createPositionAfter(t), f);
            const m = i.getAttribute("headingColumns") || 0;
            m > d && Object(r.c)("headingColumns", m + c, i, n);
          }
        });
      }
      splitCellHorizontally(t, e = 2) {
        const n = this.editor.model,
          i = t.parent,
          s = i.parent,
          a = s.getChildIndex(i),
          c = parseInt(t.getAttribute("rowspan") || 1),
          h = parseInt(t.getAttribute("colspan") || 1);
        n.change((n) => {
          if (c > 1) {
            const i = [
                ...new o.a(s, {
                  startRow: a,
                  endRow: a + c - 1,
                  includeAllSlots: !0,
                }),
              ],
              { newCellsSpan: l, updatedSpan: f } = d(c, e);
            Object(r.c)("rowspan", f, t, n);
            const { column: m } = i.find(({ cell: e }) => e === t),
              g = {};
            l > 1 && (g.rowspan = l), h > 1 && (g.colspan = h);
            for (const t of i) {
              const { column: e, row: i } = t,
                s = e === m,
                o = (i + a + f) % l == 0;
              i >= a + f && s && o && u(1, n, t.getPositionBefore(), g);
            }
          }
          if (c < e) {
            const i = e - c,
              u = [...new o.a(s, { startRow: 0, endRow: a })];
            for (const { cell: e, cellHeight: s, row: o } of u)
              if (e !== t && o + s > a) {
                const t = s + i;
                n.setAttribute("rowspan", t, e);
              }
            const d = {};
            h > 1 && (d.colspan = h), l(n, s, a + 1, i, 1, d);
            const f = s.getAttribute("headingRows") || 0;
            f > a && Object(r.c)("headingRows", f + i, s, n);
          }
        });
      }
      getColumns(t) {
        return [...t.getChild(0).getChildren()].reduce(
          (t, e) => t + parseInt(e.getAttribute("colspan") || 1),
          0
        );
      }
      getRows(t) {
        return Array.from(t.getChildren()).reduce(
          (t, e) => (e.is("element", "tableRow") ? t + 1 : t),
          0
        );
      }
    }
    function l(t, e, n, i, s, o = {}) {
      for (let r = 0; r < i; r++) {
        const i = t.createElement("tableRow");
        t.insert(i, e, n), u(s, t, t.createPositionAt(i, "end"), o);
      }
    }
    function u(t, e, n, i = {}) {
      for (let s = 0; s < t; s++) Object(r.a)(e, n, i);
    }
    function d(t, e) {
      if (t < e) return { newCellsSpan: 1, updatedSpan: 1 };
      const n = Math.floor(t / e);
      return { newCellsSpan: n, updatedSpan: t - n * e + n };
    }
  },
  function (t, e, n) {
    "use strict";
    function i(t) {
      for (const e of t.getChildren())
        if (e && e.is("element", "caption")) return e;
      return null;
    }
    function s(t, e) {
      const n = e.getFirstPosition().findAncestor("caption");
      return n && t.isBlockImage(n.parent) ? n : null;
    }
    function o(t, e) {
      return "figcaption" == e.name && t.isBlockImageView(e.parent)
        ? { name: !0 }
        : null;
    }
    n.d(e, "a", function () {
      return i;
    }),
      n.d(e, "b", function () {
        return s;
      }),
      n.d(e, "c", function () {
        return o;
      });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return c;
    });
    var i = n(91),
      s = n(20),
      o = n(26),
      r = n(60),
      a = n(39);
    class c {
      constructor(t) {
        (this.markers = new Map()),
          (this._children = new i.a()),
          t && this._insertChild(0, t);
      }
      [Symbol.iterator]() {
        return this.getChildren();
      }
      get childCount() {
        return this._children.length;
      }
      get maxOffset() {
        return this._children.maxOffset;
      }
      get isEmpty() {
        return 0 === this.childCount;
      }
      get root() {
        return this;
      }
      get parent() {
        return null;
      }
      is(t) {
        return "documentFragment" === t || "model:documentFragment" === t;
      }
      getChild(t) {
        return this._children.getNode(t);
      }
      getChildren() {
        return this._children[Symbol.iterator]();
      }
      getChildIndex(t) {
        return this._children.getNodeIndex(t);
      }
      getChildStartOffset(t) {
        return this._children.getNodeStartOffset(t);
      }
      getPath() {
        return [];
      }
      getNodeByPath(t) {
        let e = this;
        for (const n of t) e = e.getChild(e.offsetToIndex(n));
        return e;
      }
      offsetToIndex(t) {
        return this._children.offsetToIndex(t);
      }
      toJSON() {
        const t = [];
        for (const e of this._children) t.push(e.toJSON());
        return t;
      }
      static fromJSON(t) {
        const e = [];
        for (const n of t)
          n.name ? e.push(s.a.fromJSON(n)) : e.push(o.a.fromJSON(n));
        return new c(e);
      }
      _appendChild(t) {
        this._insertChild(this.childCount, t);
      }
      _insertChild(t, e) {
        const n = (function (t) {
          if ("string" == typeof t) return [new o.a(t)];
          Object(a.a)(t) || (t = [t]);
          return Array.from(t).map((t) =>
            "string" == typeof t
              ? new o.a(t)
              : t instanceof r.a
              ? new o.a(t.data, t.getAttributes())
              : t
          );
        })(e);
        for (const t of n) null !== t.parent && t._remove(), (t.parent = this);
        this._children._insertNodes(t, n);
      }
      _removeChildren(t, e = 1) {
        const n = this._children._removeNodes(t, e);
        for (const t of n) t.parent = null;
        return n;
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(76),
      s = n(0);
    class o {
      constructor(...t) {
        (this._patterns = []), this.add(...t);
      }
      add(...t) {
        for (let e of t)
          ("string" == typeof e || e instanceof RegExp) && (e = { name: e }),
            this._patterns.push(e);
      }
      match(...t) {
        for (const e of t)
          for (const t of this._patterns) {
            const n = r(e, t);
            if (n) return { element: e, pattern: t, match: n };
          }
        return null;
      }
      matchAll(...t) {
        const e = [];
        for (const n of t)
          for (const t of this._patterns) {
            const i = r(n, t);
            i && e.push({ element: n, pattern: t, match: i });
          }
        return e.length > 0 ? e : null;
      }
      getElementName() {
        if (1 !== this._patterns.length) return null;
        const t = this._patterns[0],
          e = t.name;
        return "function" == typeof t || !e || e instanceof RegExp ? null : e;
      }
    }
    function r(t, e) {
      if ("function" == typeof e) return e(t);
      const n = {};
      return (e.name &&
        ((n.name = (function (t, e) {
          if (t instanceof RegExp) return !!e.match(t);
          return t === e;
        })(e.name, t.name)),
        !n.name)) ||
        (e.attributes &&
          ((n.attributes = (function (t, e) {
            const n = new Set(e.getAttributeKeys());
            Object(i.a)(t)
              ? (void 0 !== t.style &&
                  Object(s.logWarning)(
                    "matcher-pattern-deprecated-attributes-style-key",
                    t
                  ),
                void 0 !== t.class &&
                  Object(s.logWarning)(
                    "matcher-pattern-deprecated-attributes-class-key",
                    t
                  ))
              : (n.delete("style"), n.delete("class"));
            return a(t, n, (t) => e.getAttribute(t));
          })(e.attributes, t)),
          !n.attributes))
        ? null
        : !(
            e.classes &&
            ((n.classes = (function (t, e) {
              return a(t, e.getClassNames());
            })(e.classes, t)),
            !n.classes)
          ) &&
            !(
              e.styles &&
              ((n.styles = (function (t, e) {
                return a(t, e.getStyleNames(!0), (t) => e.getStyle(t));
              })(e.styles, t)),
              !n.styles)
            ) &&
            n;
    }
    function a(t, e, n) {
      const o = (function (t) {
          if (Array.isArray(t))
            return t.map((t) =>
              Object(i.a)(t)
                ? ((void 0 !== t.key && void 0 !== t.value) ||
                    Object(s.logWarning)(
                      "matcher-pattern-missing-key-or-value",
                      t
                    ),
                  [t.key, t.value])
                : [t, !0]
            );
          if (Object(i.a)(t)) return Object.entries(t);
          return [[t, !0]];
        })(t),
        r = Array.from(e),
        a = [];
      return (
        o.forEach(([t, e]) => {
          r.forEach((i) => {
            (function (t, e) {
              return !0 === t || t === e || (t instanceof RegExp && e.match(t));
            })(t, i) &&
              (function (t, e, n) {
                if (!0 === t) return !0;
                const i = n(e);
                return t === i || (t instanceof RegExp && !!String(i).match(t));
              })(e, i, n) &&
              a.push(i);
          });
        }),
        !o.length || a.length < o.length ? null : a
      );
    }
  },
  function (t, e, n) {
    "use strict";
    (function (t) {
      var i = n(41),
        s = n(295),
        o =
          "object" == typeof exports && exports && !exports.nodeType && exports,
        r = o && "object" == typeof t && t && !t.nodeType && t,
        a = r && r.exports === o ? i.a.Buffer : void 0,
        c = (a ? a.isBuffer : void 0) || s.a;
      e.a = c;
    }.call(this, n(247)(t)));
  },
  function (t, e, n) {
    "use strict";
    var i = n(70),
      s = n(41),
      o = Object(i.a)(s.a, "DataView"),
      r = n(124),
      a = Object(i.a)(s.a, "Promise"),
      c = Object(i.a)(s.a, "Set"),
      l = Object(i.a)(s.a, "WeakMap"),
      u = n(63),
      d = n(106),
      h = Object(d.a)(o),
      f = Object(d.a)(r.a),
      m = Object(d.a)(a),
      g = Object(d.a)(c),
      p = Object(d.a)(l),
      b = u.a;
    ((o && "[object DataView]" != b(new o(new ArrayBuffer(1)))) ||
      (r.a && "[object Map]" != b(new r.a())) ||
      (a && "[object Promise]" != b(a.resolve())) ||
      (c && "[object Set]" != b(new c())) ||
      (l && "[object WeakMap]" != b(new l()))) &&
      (b = function (t) {
        var e = Object(u.a)(t),
          n = "[object Object]" == e ? t.constructor : void 0,
          i = n ? Object(d.a)(n) : "";
        if (i)
          switch (i) {
            case h:
              return "[object DataView]";
            case f:
              return "[object Map]";
            case m:
              return "[object Promise]";
            case g:
              return "[object Set]";
            case p:
              return "[object WeakMap]";
          }
        return e;
      });
    e.a = b;
  },
  function (t, e, n) {
    "use strict";
    (function (t) {
      var i = n(205),
        s =
          "object" == typeof exports && exports && !exports.nodeType && exports,
        o = s && "object" == typeof t && t && !t.nodeType && t,
        r = o && o.exports === s && i.a.process,
        a = (function () {
          try {
            var t = o && o.require && o.require("util").types;
            return t || (r && r.binding && r.binding("util"));
          } catch (t) {}
        })();
      e.a = a;
    }.call(this, n(247)(t)));
  },
  function (t, e, n) {
    "use strict";
    function i(t) {
      if (t) {
        if (t.defaultView) return t instanceof t.defaultView.Document;
        if (t.ownerDocument && t.ownerDocument.defaultView)
          return t instanceof t.ownerDocument.defaultView.Node;
      }
      return !1;
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    var i = Function.prototype.toString;
    e.a = function (t) {
      if (null != t) {
        try {
          return i.call(t);
        } catch (t) {}
        try {
          return t + "";
        } catch (t) {}
      }
      return "";
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "e", function () {
      return s;
    }),
      n.d(e, "c", function () {
        return o;
      }),
      n.d(e, "a", function () {
        return r;
      }),
      n.d(e, "b", function () {
        return a;
      }),
      n.d(e, "d", function () {
        return c;
      });
    var i = n(19);
    function s(t, e, n) {
      return (
        e.setCustomProperty("media", !0, t), Object(i.g)(t, e, { label: n })
      );
    }
    function o(t) {
      const e = t.getSelectedElement();
      return e &&
        (function (t) {
          return !!t.getCustomProperty("media") && Object(i.e)(t);
        })(e)
        ? e
        : null;
    }
    function r(t, e, n, i) {
      const s = t.createContainerElement("figure", { class: "media" });
      return (
        t.insert(t.createPositionAt(s, 0), e.getMediaViewElement(t, n, i)), s
      );
    }
    function a(t) {
      const e = t.getSelectedElement();
      return e && e.is("element", "media") ? e : null;
    }
    function c(t, e, n) {
      t.change((i) => {
        const s = i.createElement("media", { url: e });
        t.insertContent(s, n), i.setSelection(s, "on");
      });
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "c", function () {
      return s;
    }),
      n.d(e, "b", function () {
        return o;
      }),
      n.d(e, "a", function () {
        return r;
      });
    var i = n(2);
    function s(t) {
      return (t) => {
        t.on("element:figure", e);
      };
      function e(e, n, s) {
        if (!s.consumable.test(n.viewItem, { name: !0, classes: "image" }))
          return;
        const o = t.findViewImgElement(n.viewItem);
        if (!o || !s.consumable.test(o, { name: !0 })) return;
        s.consumable.consume(n.viewItem, { name: !0, classes: "image" });
        const r = s.convertItem(o, n.modelCursor),
          a = Object(i.n)(r.modelRange.getItems());
        a
          ? (s.convertChildren(n.viewItem, a), s.updateConversionResult(a, n))
          : s.consumable.revert(n.viewItem, { name: !0, classes: "image" });
      }
    }
    function o(t, e) {
      return (t) => {
        t.on("attribute:srcset:" + e, n);
      };
      function n(e, n, i) {
        if (!i.consumable.consume(n.item, e.name)) return;
        const s = i.writer,
          o = i.mapper.toViewElement(n.item),
          r = t.findViewImgElement(o);
        if (null === n.attributeNewValue) {
          const t = n.attributeOldValue;
          t.data &&
            (s.removeAttribute("srcset", r),
            s.removeAttribute("sizes", r),
            t.width && s.removeAttribute("width", r));
        } else {
          const t = n.attributeNewValue;
          t.data &&
            (s.setAttribute("srcset", t.data, r),
            s.setAttribute("sizes", "100vw", r),
            t.width && s.setAttribute("width", t.width, r));
        }
      }
    }
    function r(t, e, n) {
      return (t) => {
        t.on(`attribute:${n}:${e}`, i);
      };
      function i(e, n, i) {
        if (!i.consumable.consume(n.item, e.name)) return;
        const s = i.writer,
          o = i.mapper.toViewElement(n.item),
          r = t.findViewImgElement(o);
        s.setAttribute(n.attributeKey, n.attributeNewValue || "", r);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.r(e);
    const i = {
      get(t) {
        return "number" != typeof t ? this[t] || this.normal : t;
      },
      highest: 1e5,
      high: 1e3,
      normal: 0,
      low: -1e3,
      lowest: -1e5,
    };
    e.default = i;
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return y;
    });
    var i = n(25),
      s = n(50),
      o = n(134),
      r = n(7),
      a = n(15),
      c = n(62),
      l = n(86),
      u = n(94),
      d = n(101),
      h = n(22),
      f = n(27),
      m = n(0);
    function g(t) {
      let e = 0;
      for (; t.previousSibling; ) (t = t.previousSibling), e++;
      return e;
    }
    function p(t) {
      const e = [];
      for (; t && t.nodeType != Node.DOCUMENT_NODE; )
        e.unshift(t), (t = t.parentNode);
      return e;
    }
    var b = n(42);
    const w = Object(h.a)(document),
      v = Object(h.e)(document),
      _ = Object(h.d)(document);
    class y {
      constructor(t, e = {}) {
        (this.document = t),
          (this.renderingMode = e.renderingMode || "editing"),
          (this.blockFillerMode =
            e.blockFillerMode ||
            ("editing" === this.renderingMode ? "br" : "nbsp")),
          (this.preElements = ["pre"]),
          (this.blockElements = [
            "address",
            "article",
            "aside",
            "blockquote",
            "caption",
            "center",
            "dd",
            "details",
            "dir",
            "div",
            "dl",
            "dt",
            "fieldset",
            "figcaption",
            "figure",
            "footer",
            "form",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "header",
            "hgroup",
            "legend",
            "li",
            "main",
            "menu",
            "nav",
            "ol",
            "p",
            "pre",
            "section",
            "summary",
            "table",
            "tbody",
            "td",
            "tfoot",
            "th",
            "thead",
            "tr",
            "ul",
          ]),
          (this.inlineObjectElements = [
            "object",
            "iframe",
            "input",
            "button",
            "textarea",
            "select",
            "option",
            "video",
            "embed",
            "audio",
            "img",
            "canvas",
          ]),
          (this._domToViewMapping = new WeakMap()),
          (this._viewToDomMapping = new WeakMap()),
          (this._fakeSelectionMapping = new WeakMap()),
          (this._rawContentElementMatcher = new d.a()),
          (this._encounteredRawContentDomNodes = new WeakSet());
      }
      bindFakeSelection(t, e) {
        this._fakeSelectionMapping.set(t, new c.a(e));
      }
      fakeSelectionToView(t) {
        return this._fakeSelectionMapping.get(t);
      }
      bindElements(t, e) {
        this._domToViewMapping.set(t, e), this._viewToDomMapping.set(e, t);
      }
      unbindDomElement(t) {
        const e = this._domToViewMapping.get(t);
        if (e) {
          this._domToViewMapping.delete(t), this._viewToDomMapping.delete(e);
          for (const e of t.childNodes) this.unbindDomElement(e);
        }
      }
      bindDocumentFragments(t, e) {
        this._domToViewMapping.set(t, e), this._viewToDomMapping.set(e, t);
      }
      shouldRenderAttribute(t, e, n) {
        return (
          "data" === this.renderingMode ||
          (!(t = t.toLowerCase()).startsWith("on") &&
            ("srcdoc" !== t ||
              !e.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) &&
            (("img" === n && ("src" === t || "srcset" === t)) ||
              ("source" === n && "srcset" === t) ||
              !e.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i)))
        );
      }
      setContentOf(t, e) {
        if ("data" === this.renderingMode) return void (t.innerHTML = e);
        const n = new DOMParser().parseFromString(e, "text/html"),
          i = n.createDocumentFragment(),
          s = n.body.childNodes;
        for (; s.length > 0; ) i.appendChild(s[0]);
        const o = n.createTreeWalker(i, NodeFilter.SHOW_ELEMENT),
          r = [];
        let a;
        for (; (a = o.nextNode()); ) r.push(a);
        for (const t of r) {
          for (const e of t.getAttributeNames())
            this.setDomElementAttribute(t, e, t.getAttribute(e));
          const e = t.tagName.toLowerCase();
          this._shouldRenameElement(e) &&
            (Object(m.logWarning)("domconverter-unsafe-element-detected", {
              unsafeElement: t,
            }),
            t.replaceWith(this._createReplacementDomElement(e, t)));
        }
        for (; t.firstChild; ) t.firstChild.remove();
        t.append(i);
      }
      viewToDom(t, e, n = {}) {
        if (t.is("$text")) {
          const n = this._processDataFromViewText(t);
          return e.createTextNode(n);
        }
        {
          if (this.mapViewToDom(t)) return this.mapViewToDom(t);
          let i;
          if (t.is("documentFragment"))
            (i = e.createDocumentFragment()),
              n.bind && this.bindDocumentFragments(i, t);
          else {
            if (t.is("uiElement"))
              return (
                (i =
                  "$comment" === t.name
                    ? e.createComment(t.getCustomProperty("$rawContent"))
                    : t.render(e, this)),
                n.bind && this.bindElements(i, t),
                i
              );
            this._shouldRenameElement(t.name)
              ? (Object(m.logWarning)("domconverter-unsafe-element-detected", {
                  unsafeElement: t,
                }),
                (i = this._createReplacementDomElement(t.name)))
              : (i = t.hasAttribute("xmlns")
                  ? e.createElementNS(t.getAttribute("xmlns"), t.name)
                  : e.createElement(t.name)),
              t.is("rawElement") && t.render(i, this),
              n.bind && this.bindElements(i, t);
            for (const e of t.getAttributeKeys())
              this.setDomElementAttribute(i, e, t.getAttribute(e), t);
          }
          if (!1 !== n.withChildren)
            for (const s of this.viewChildrenToDom(t, e, n)) i.appendChild(s);
          return i;
        }
      }
      setDomElementAttribute(t, e, n, i = null) {
        const s =
          this.shouldRenderAttribute(e, n, t.tagName.toLowerCase()) ||
          (i && i.shouldRenderUnsafeAttribute(e));
        s ||
          Object(m.logWarning)("domconverter-unsafe-attribute-detected", {
            domElement: t,
            key: e,
            value: n,
          }),
          t.hasAttribute(e) && !s
            ? t.removeAttribute(e)
            : t.hasAttribute("data-ck-unsafe-attribute-" + e) &&
              s &&
              t.removeAttribute("data-ck-unsafe-attribute-" + e),
          t.setAttribute(s ? e : "data-ck-unsafe-attribute-" + e, n);
      }
      removeDomElementAttribute(t, e) {
        "data-ck-unsafe-element" != e &&
          (t.removeAttribute(e),
          t.removeAttribute("data-ck-unsafe-attribute-" + e));
      }
      *viewChildrenToDom(t, e, n = {}) {
        const i = t.getFillerOffset && t.getFillerOffset();
        let s = 0;
        for (const o of t.getChildren())
          i === s && (yield this._getBlockFiller(e)),
            yield this.viewToDom(o, e, n),
            s++;
        i === s && (yield this._getBlockFiller(e));
      }
      viewRangeToDom(t) {
        const e = this.viewPositionToDom(t.start),
          n = this.viewPositionToDom(t.end),
          i = document.createRange();
        return i.setStart(e.parent, e.offset), i.setEnd(n.parent, n.offset), i;
      }
      viewPositionToDom(t) {
        const e = t.parent;
        if (e.is("$text")) {
          const n = this.findCorrespondingDomText(e);
          if (!n) return null;
          let i = t.offset;
          return Object(h.i)(n) && (i += h.c), { parent: n, offset: i };
        }
        {
          let n, i, s;
          if (0 === t.offset) {
            if (((n = this.mapViewToDom(e)), !n)) return null;
            s = n.childNodes[0];
          } else {
            const e = t.nodeBefore;
            if (
              ((i = e.is("$text")
                ? this.findCorrespondingDomText(e)
                : this.mapViewToDom(t.nodeBefore)),
              !i)
            )
              return null;
            (n = i.parentNode), (s = i.nextSibling);
          }
          if (Object(b.a)(s) && Object(h.i)(s))
            return { parent: s, offset: h.c };
          return { parent: n, offset: i ? g(i) + 1 : 0 };
        }
      }
      domToView(t, e = {}) {
        if (this.isBlockFiller(t)) return null;
        const n = this.getHostViewElement(t);
        if (n) return n;
        if (this.isComment(t) && e.skipComments) return null;
        if (Object(b.a)(t)) {
          if (Object(h.h)(t)) return null;
          {
            const e = this._processDataFromDomText(t);
            return "" === e ? null : new i.a(this.document, e);
          }
        }
        {
          if (this.mapDomToView(t)) return this.mapDomToView(t);
          let n;
          if (this.isDocumentFragment(t))
            (n = new l.a(this.document)),
              e.bind && this.bindDocumentFragments(t, n);
          else {
            (n = this._createViewElement(t, e)),
              e.bind && this.bindElements(t, n);
            const i = t.attributes;
            if (i)
              for (let t = i.length - 1; t >= 0; t--)
                n._setAttribute(i[t].name, i[t].value);
            if (this._isViewElementWithRawContent(n, e) || this.isComment(t)) {
              const e = this.isComment(t) ? t.data : t.innerHTML;
              return (
                n._setCustomProperty("$rawContent", e),
                this._encounteredRawContentDomNodes.add(t),
                n
              );
            }
          }
          if (!1 !== e.withChildren)
            for (const i of this.domChildrenToView(t, e)) n._appendChild(i);
          return n;
        }
      }
      *domChildrenToView(t, e = {}) {
        for (let n = 0; n < t.childNodes.length; n++) {
          const i = t.childNodes[n],
            s = this.domToView(i, e);
          null !== s && (yield s);
        }
      }
      domSelectionToView(t) {
        if (1 === t.rangeCount) {
          let e = t.getRangeAt(0).startContainer;
          Object(b.a)(e) && (e = e.parentNode);
          const n = this.fakeSelectionToView(e);
          if (n) return n;
        }
        const e = this.isDomSelectionBackward(t),
          n = [];
        for (let e = 0; e < t.rangeCount; e++) {
          const i = t.getRangeAt(e),
            s = this.domRangeToView(i);
          s && n.push(s);
        }
        return new c.a(n, { backward: e });
      }
      domRangeToView(t) {
        const e = this.domPositionToView(t.startContainer, t.startOffset),
          n = this.domPositionToView(t.endContainer, t.endOffset);
        return e && n ? new a.a(e, n) : null;
      }
      domPositionToView(t, e = 0) {
        if (this.isBlockFiller(t))
          return this.domPositionToView(t.parentNode, g(t));
        const n = this.mapDomToView(t);
        if (n && (n.is("uiElement") || n.is("rawElement")))
          return r.a._createBefore(n);
        if (Object(b.a)(t)) {
          if (Object(h.h)(t)) return this.domPositionToView(t.parentNode, g(t));
          const n = this.findCorrespondingViewText(t);
          let i = e;
          return n
            ? (Object(h.i)(t) && ((i -= h.c), (i = i < 0 ? 0 : i)),
              new r.a(n, i))
            : null;
        }
        if (0 === e) {
          const e = this.mapDomToView(t);
          if (e) return new r.a(e, 0);
        } else {
          const n = t.childNodes[e - 1],
            i = Object(b.a)(n)
              ? this.findCorrespondingViewText(n)
              : this.mapDomToView(n);
          if (i && i.parent) return new r.a(i.parent, i.index + 1);
        }
        return null;
      }
      mapDomToView(t) {
        return this.getHostViewElement(t) || this._domToViewMapping.get(t);
      }
      findCorrespondingViewText(t) {
        if (Object(h.h)(t)) return null;
        const e = this.getHostViewElement(t);
        if (e) return e;
        const n = t.previousSibling;
        if (n) {
          if (!this.isElement(n)) return null;
          const t = this.mapDomToView(n);
          if (t) {
            return t.nextSibling instanceof i.a ? t.nextSibling : null;
          }
        } else {
          const e = this.mapDomToView(t.parentNode);
          if (e) {
            const t = e.getChild(0);
            return t instanceof i.a ? t : null;
          }
        }
        return null;
      }
      mapViewToDom(t) {
        return this._viewToDomMapping.get(t);
      }
      findCorrespondingDomText(t) {
        const e = t.previousSibling;
        return e && this.mapViewToDom(e)
          ? this.mapViewToDom(e).nextSibling
          : !e && t.parent && this.mapViewToDom(t.parent)
          ? this.mapViewToDom(t.parent).childNodes[0]
          : null;
      }
      focus(t) {
        const e = this.mapViewToDom(t);
        if (e && e.ownerDocument.activeElement !== e) {
          const { scrollX: t, scrollY: n } = f.a.window,
            i = [];
          k(e, (t) => {
            const { scrollLeft: e, scrollTop: n } = t;
            i.push([e, n]);
          }),
            e.focus(),
            k(e, (t) => {
              const [e, n] = i.shift();
              (t.scrollLeft = e), (t.scrollTop = n);
            }),
            f.a.window.scrollTo(t, n);
        }
      }
      isElement(t) {
        return t && t.nodeType == Node.ELEMENT_NODE;
      }
      isDocumentFragment(t) {
        return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
      }
      isComment(t) {
        return t && t.nodeType == Node.COMMENT_NODE;
      }
      isBlockFiller(t) {
        return "br" == this.blockFillerMode
          ? t.isEqualNode(w)
          : !(
              "BR" !== t.tagName ||
              !A(t, this.blockElements) ||
              1 !== t.parentNode.childNodes.length
            ) ||
              t.isEqualNode(_) ||
              (function (t, e) {
                return (
                  t.isEqualNode(v) &&
                  A(t, e) &&
                  1 === t.parentNode.childNodes.length
                );
              })(t, this.blockElements);
      }
      isDomSelectionBackward(t) {
        if (t.isCollapsed) return !1;
        const e = document.createRange();
        e.setStart(t.anchorNode, t.anchorOffset),
          e.setEnd(t.focusNode, t.focusOffset);
        const n = e.collapsed;
        return e.detach(), n;
      }
      getHostViewElement(t) {
        const e = p(t);
        for (e.pop(); e.length; ) {
          const t = e.pop(),
            n = this._domToViewMapping.get(t);
          if (n && (n.is("uiElement") || n.is("rawElement"))) return n;
        }
        return null;
      }
      isDomSelectionCorrect(t) {
        return (
          this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) &&
          this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
        );
      }
      registerRawContentMatcher(t) {
        this._rawContentElementMatcher.add(t);
      }
      _getBlockFiller(t) {
        switch (this.blockFillerMode) {
          case "nbsp":
            return Object(h.e)(t);
          case "markedNbsp":
            return Object(h.d)(t);
          case "br":
            return Object(h.a)(t);
        }
      }
      _isDomSelectionPositionCorrect(t, e) {
        if (Object(b.a)(t) && Object(h.i)(t) && e < h.c) return !1;
        if (this.isElement(t) && Object(h.i)(t.childNodes[e])) return !1;
        const n = this.mapDomToView(t);
        return !n || (!n.is("uiElement") && !n.is("rawElement"));
      }
      _processDataFromViewText(t) {
        let e = t.data;
        if (t.getAncestors().some((t) => this.preElements.includes(t.name)))
          return e;
        if (" " == e.charAt(0)) {
          const n = this._getTouchingInlineViewNode(t, !1);
          (!(n && n.is("$textProxy") && this._nodeEndsWithSpace(n)) && n) ||
            (e = " " + e.substr(1));
        }
        if (" " == e.charAt(e.length - 1)) {
          const n = this._getTouchingInlineViewNode(t, !0),
            i = n && n.is("$textProxy") && " " == n.data.charAt(0);
          (" " != e.charAt(e.length - 2) && n && !i) ||
            (e = e.substr(0, e.length - 1) + " ");
        }
        return e.replace(/ {2}/g, "  ");
      }
      _nodeEndsWithSpace(t) {
        if (t.getAncestors().some((t) => this.preElements.includes(t.name)))
          return !1;
        const e = this._processDataFromViewText(t);
        return " " == e.charAt(e.length - 1);
      }
      _processDataFromDomText(t) {
        let e = t.data;
        if (
          (function (t, e) {
            return p(t).some(
              (t) => t.tagName && e.includes(t.tagName.toLowerCase())
            );
          })(t, this.preElements)
        )
          return Object(h.f)(t);
        e = e.replace(/[ \n\t\r]{1,}/g, " ");
        const n = this._getTouchingInlineDomNode(t, !1),
          i = this._getTouchingInlineDomNode(t, !0),
          s = this._checkShouldLeftTrimDomText(t, n),
          o = this._checkShouldRightTrimDomText(t, i);
        s && (e = e.replace(/^ /, "")),
          o && (e = e.replace(/ $/, "")),
          (e = Object(h.f)(new Text(e))),
          (e = e.replace(/ \u00A0/g, "  "));
        const r = i && this.isElement(i) && "BR" != i.tagName,
          a = i && Object(b.a)(i) && " " == i.data.charAt(0);
        return (
          (/( |\u00A0)\u00A0$/.test(e) || !i || r || a) &&
            (e = e.replace(/\u00A0$/, " ")),
          (s || (n && this.isElement(n) && "BR" != n.tagName)) &&
            (e = e.replace(/^\u00A0/, " ")),
          e
        );
      }
      _checkShouldLeftTrimDomText(t, e) {
        return (
          !e ||
          (this.isElement(e)
            ? "BR" === e.tagName
            : !this._encounteredRawContentDomNodes.has(t.previousSibling) &&
              /[^\S\u00A0]/.test(e.data.charAt(e.data.length - 1)))
        );
      }
      _checkShouldRightTrimDomText(t, e) {
        return !e && !Object(h.i)(t);
      }
      _getTouchingInlineViewNode(t, e) {
        const n = new u.a({
          startPosition: e ? r.a._createAfter(t) : r.a._createBefore(t),
          direction: e ? "forward" : "backward",
        });
        for (const t of n) {
          if (
            t.item.is("element") &&
            this.inlineObjectElements.includes(t.item.name)
          )
            return t.item;
          if (t.item.is("containerElement")) return null;
          if (t.item.is("element", "br")) return null;
          if (t.item.is("$textProxy")) return t.item;
        }
        return null;
      }
      _getTouchingInlineDomNode(t, e) {
        if (!t.parentNode) return null;
        const n = e ? "firstChild" : "lastChild",
          i = e ? "nextSibling" : "previousSibling";
        let s = !0;
        do {
          if (
            (!s && t[n]
              ? (t = t[n])
              : t[i]
              ? ((t = t[i]), (s = !1))
              : ((t = t.parentNode), (s = !0)),
            !t || this._isBlockElement(t))
          )
            return null;
        } while (
          !Object(b.a)(t) &&
          "BR" != t.tagName &&
          !this._isInlineObjectElement(t)
        );
        return t;
      }
      _isBlockElement(t) {
        return (
          this.isElement(t) &&
          this.blockElements.includes(t.tagName.toLowerCase())
        );
      }
      _isInlineObjectElement(t) {
        return (
          this.isElement(t) &&
          this.inlineObjectElements.includes(t.tagName.toLowerCase())
        );
      }
      _createViewElement(t, e) {
        if (this.isComment(t)) return new o.a(this.document, "$comment");
        const n = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase();
        return new s.a(this.document, n);
      }
      _isViewElementWithRawContent(t, e) {
        return !1 !== e.withChildren && this._rawContentElementMatcher.match(t);
      }
      _shouldRenameElement(t) {
        return "editing" == this.renderingMode && "script" == t.toLowerCase();
      }
      _createReplacementDomElement(t, e = null) {
        const n = document.createElement("span");
        if ((n.setAttribute("data-ck-unsafe-element", t), e)) {
          for (; e.firstChild; ) n.appendChild(e.firstChild);
          for (const t of e.getAttributeNames())
            n.setAttribute(t, e.getAttribute(t));
        }
        return n;
      }
    }
    function k(t, e) {
      for (; t && t != f.a.document; ) e(t), (t = t.parentNode);
    }
    function A(t, e) {
      const n = t.parentNode;
      return n && n.tagName && e.includes(n.tagName.toLowerCase());
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(174);
    class s {
      constructor(t, e, n) {
        (this.view = t),
          (this.document = t.document),
          (this.domEvent = e),
          (this.domTarget = e.target),
          Object(i.a)(this, n);
      }
      get target() {
        return this.view.domConverter.mapDomToView(this.domTarget);
      }
      preventDefault() {
        this.domEvent.preventDefault();
      }
      stopPropagation() {
        this.domEvent.stopPropagation();
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(6),
      s = n(27),
      o = n(18),
      r = n(72);
    class a {
      constructor(t, e) {
        a._observerInstance || a._createObserver(),
          (this._element = t),
          (this._callback = e),
          a._addElementCallback(t, e),
          a._observerInstance.observe(t);
      }
      destroy() {
        a._deleteElementCallback(this._element, this._callback);
      }
      static _addElementCallback(t, e) {
        a._elementCallbacks || (a._elementCallbacks = new Map());
        let n = a._elementCallbacks.get(t);
        n || ((n = new Set()), a._elementCallbacks.set(t, n)), n.add(e);
      }
      static _deleteElementCallback(t, e) {
        const n = a._getElementCallbacks(t);
        n &&
          (n.delete(e),
          n.size ||
            (a._elementCallbacks.delete(t), a._observerInstance.unobserve(t))),
          a._elementCallbacks &&
            !a._elementCallbacks.size &&
            ((a._observerInstance = null), (a._elementCallbacks = null));
      }
      static _getElementCallbacks(t) {
        return a._elementCallbacks ? a._elementCallbacks.get(t) : null;
      }
      static _createObserver() {
        let t;
        (t =
          "function" == typeof s.a.window.ResizeObserver
            ? s.a.window.ResizeObserver
            : c),
          (a._observerInstance = new t((t) => {
            for (const e of t) {
              const t = a._getElementCallbacks(e.target);
              if (t) for (const n of t) n(e);
            }
          }));
      }
    }
    (a._observerInstance = null), (a._elementCallbacks = null);
    class c {
      constructor(t) {
        (this._callback = t),
          (this._elements = new Set()),
          (this._previousRects = new Map()),
          (this._periodicCheckTimeout = null);
      }
      observe(t) {
        this._elements.add(t),
          this._checkElementRectsAndExecuteCallback(),
          1 === this._elements.size && this._startPeriodicCheck();
      }
      unobserve(t) {
        this._elements.delete(t),
          this._previousRects.delete(t),
          this._elements.size || this._stopPeriodicCheck();
      }
      _startPeriodicCheck() {
        const t = () => {
          this._checkElementRectsAndExecuteCallback(),
            (this._periodicCheckTimeout = setTimeout(t, 100));
        };
        this.listenTo(s.a.window, "resize", () => {
          this._checkElementRectsAndExecuteCallback();
        }),
          (this._periodicCheckTimeout = setTimeout(t, 100));
      }
      _stopPeriodicCheck() {
        clearTimeout(this._periodicCheckTimeout),
          this.stopListening(),
          this._previousRects.clear();
      }
      _checkElementRectsAndExecuteCallback() {
        const t = [];
        for (const e of this._elements)
          this._hasRectChanged(e) &&
            t.push({ target: e, contentRect: this._previousRects.get(e) });
        t.length && this._callback(t);
      }
      _hasRectChanged(t) {
        if (!t.ownerDocument.body.contains(t)) return !1;
        const e = new o.a(t),
          n = this._previousRects.get(t),
          i = !n || !n.isEqual(e);
        return this._previousRects.set(t, e), i;
      }
    }
    Object(i.default)(c, r.a);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(0),
      s = n(51);
    class o extends s.default {
      constructor(t = []) {
        super(t, { idProperty: "viewUid" }),
          this.on("add", (t, e, n) => {
            this._renderViewIntoCollectionParent(e, n);
          }),
          this.on("remove", (t, e) => {
            e.element && this._parentElement && e.element.remove();
          }),
          (this._parentElement = null);
      }
      destroy() {
        this.map((t) => t.destroy());
      }
      setParent(t) {
        this._parentElement = t;
        for (const t of this) this._renderViewIntoCollectionParent(t);
      }
      delegate(...t) {
        if (!t.length || !t.every((t) => "string" == typeof t))
          throw new i.default("ui-viewcollection-delegate-wrong-events", this);
        return {
          to: (e) => {
            for (const n of this) for (const i of t) n.delegate(i).to(e);
            this.on("add", (n, i) => {
              for (const n of t) i.delegate(n).to(e);
            }),
              this.on("remove", (n, i) => {
                for (const n of t) i.stopDelegating(n, e);
              });
          },
        };
      }
      _renderViewIntoCollectionParent(t, e) {
        t.isRendered || t.render(),
          t.element &&
            this._parentElement &&
            this._parentElement.insertBefore(
              t.element,
              this._parentElement.children[e]
            );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(8);
    n(330);
    class s extends i.a {
      constructor() {
        super();
        const t = this.bindTemplate;
        this.set("content", ""),
          this.set("viewBox", "0 0 20 20"),
          this.set("fillColor", ""),
          this.setTemplate({
            tag: "svg",
            ns: "http://www.w3.org/2000/svg",
            attributes: { class: ["ck", "ck-icon"], viewBox: t.to("viewBox") },
          });
      }
      render() {
        super.render(),
          this._updateXMLContent(),
          this._colorFillPaths(),
          this.on("change:content", () => {
            this._updateXMLContent(), this._colorFillPaths();
          }),
          this.on("change:fillColor", () => {
            this._colorFillPaths();
          });
      }
      _updateXMLContent() {
        if (this.content) {
          const t = new DOMParser()
              .parseFromString(this.content.trim(), "image/svg+xml")
              .querySelector("svg"),
            e = t.getAttribute("viewBox");
          for (
            e && (this.viewBox = e), this.element.innerHTML = "";
            t.childNodes.length > 0;

          )
            this.element.appendChild(t.childNodes[0]);
        }
      }
      _colorFillPaths() {
        this.fillColor &&
          this.element.querySelectorAll(".ck-icon__fill").forEach((t) => {
            t.style.fill = this.fillColor;
          });
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(27);
    class s {
      constructor(t) {
        if ((Object.assign(this, t), t.actions && t.keystrokeHandler))
          for (const e in t.actions) {
            let n = t.actions[e];
            "string" == typeof n && (n = [n]);
            for (const i of n)
              t.keystrokeHandler.set(i, (t, n) => {
                this[e](), n();
              });
          }
      }
      get first() {
        return this.focusables.find(o) || null;
      }
      get last() {
        return this.focusables.filter(o).slice(-1)[0] || null;
      }
      get next() {
        return this._getFocusableItem(1);
      }
      get previous() {
        return this._getFocusableItem(-1);
      }
      get current() {
        let t = null;
        return null === this.focusTracker.focusedElement
          ? null
          : (this.focusables.find((e, n) => {
              const i = e.element === this.focusTracker.focusedElement;
              return i && (t = n), i;
            }),
            t);
      }
      focusFirst() {
        this._focus(this.first);
      }
      focusLast() {
        this._focus(this.last);
      }
      focusNext() {
        this._focus(this.next);
      }
      focusPrevious() {
        this._focus(this.previous);
      }
      _focus(t) {
        t && t.focus();
      }
      _getFocusableItem(t) {
        const e = this.current,
          n = this.focusables.length;
        if (!n) return null;
        if (null === e) return this[1 === t ? "first" : "last"];
        let i = (e + n + t) % n;
        do {
          const e = this.focusables.get(i);
          if (o(e)) return e;
          i = (i + n + t) % n;
        } while (i !== e);
        return null;
      }
    }
    function o(t) {
      return !(
        !t.focus || "none" == i.a.window.getComputedStyle(t.element).display
      );
    }
  },
  function (t, e, n) {
    "use strict";
    function i(t) {
      return Array.isArray(t)
        ? { items: t, removeItems: [] }
        : t
        ? Object.assign({ items: [], removeItems: [] }, t)
        : { items: [], removeItems: [] };
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    var i = n(123),
      s = n(207);
    e.a = function (t) {
      return null != t && Object(s.a)(t.length) && !Object(i.a)(t);
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    }),
      n.d(e, "b", function () {
        return o;
      });
    var i = n(50);
    class s extends i.a {
      constructor(t, e, n, i) {
        super(t, e, n, i), (this.getFillerOffset = o);
      }
      is(t, e = null) {
        return e
          ? e === this.name &&
              ("containerElement" === t ||
                "view:containerElement" === t ||
                "element" === t ||
                "view:element" === t)
          : "containerElement" === t ||
              "view:containerElement" === t ||
              "element" === t ||
              "view:element" === t ||
              "node" === t ||
              "view:node" === t;
      }
    }
    function o() {
      const t = [...this.getChildren()],
        e = t[this.childCount - 1];
      if (e && e.is("element", "br")) return this.childCount;
      for (const e of t) if (!e.is("uiElement")) return null;
      return this.childCount;
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(63),
      s = n(38);
    e.a = function (t) {
      return (
        "symbol" == typeof t ||
        (Object(s.a)(t) && "[object Symbol]" == Object(i.a)(t))
      );
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(74);
    class s extends i.a {
      constructor(t, e, n) {
        super(t, e),
          (this.startRange = n),
          (this._eventPhase = "none"),
          (this._currentTarget = null);
      }
      get eventPhase() {
        return this._eventPhase;
      }
      get currentTarget() {
        return this._currentTarget;
      }
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(21);
    n.d(e, "m", function () {
      return i.a;
    });
    var s = n(83);
    n.d(e, "l", function () {
      return s.a;
    });
    var o = n(6);
    n.d(e, "w", function () {
      return o.default;
    });
    var r = n(11);
    n.d(e, "e", function () {
      return r.default;
    });
    var a = n(14);
    n.d(e, "h", function () {
      return a.default;
    });
    var c = n(0);
    n.d(e, "a", function () {
      return c.default;
    }),
      n.d(e, "v", function () {
        return c.logWarning;
      });
    var l = n(279);
    n.d(e, "d", function () {
      return l.a;
    });
    var u = n(188);
    n.d(e, "k", function () {
      return u.a;
    });
    var d = n(72);
    n.d(e, "c", function () {
      return d.a;
    });
    var h = n(27);
    n.d(e, "s", function () {
      return h.a;
    });
    var f = n(268);
    n.d(e, "p", function () {
      return f.a;
    });
    var m = n(18);
    n.d(e, "i", function () {
      return m.a;
    });
    var g = n(112);
    n.d(e, "j", function () {
      return g.a;
    });
    var p = n(187);
    n.d(e, "z", function () {
      return p.a;
    });
    var b = n(68);
    n.d(e, "C", function () {
      return b.a;
    });
    var w = n(12);
    n.d(e, "o", function () {
      return w.a;
    }),
      n.d(e, "r", function () {
        return w.c;
      }),
      n.d(e, "t", function () {
        return w.d;
      }),
      n.d(e, "u", function () {
        return w.f;
      }),
      n.d(e, "x", function () {
        return w.g;
      });
    var v = n(167);
    n.d(e, "q", function () {
      return v.a;
    });
    n(203);
    var _ = n(51);
    n.d(e, "b", function () {
      return _.default;
    });
    var y = n(177);
    n.d(e, "n", function () {
      return y.a;
    });
    var k = n(52);
    n.d(e, "f", function () {
      return k.a;
    });
    var A = n(69);
    n.d(e, "g", function () {
      return A.a;
    });
    var C = n(35);
    n.d(e, "A", function () {
      return C.a;
    });
    var E = n(73);
    n.d(e, "B", function () {
      return E.a;
    });
    var O = n(109);
    n.d(e, "y", function () {
      return O.default;
    });
    var P = n(44);
    n.d(e, "D", function () {
      return P.a;
    });
    var T = n(133);
    n.d(e, "E", function () {
      return T.a;
    });
  },
  function (t, e, n) {
    "use strict";
    var i = function () {
        (this.__data__ = []), (this.size = 0);
      },
      s = n(87);
    var o = function (t, e) {
        for (var n = t.length; n--; ) if (Object(s.a)(t[n][0], e)) return n;
        return -1;
      },
      r = Array.prototype.splice;
    var a = function (t) {
      var e = this.__data__,
        n = o(e, t);
      return (
        !(n < 0) &&
        (n == e.length - 1 ? e.pop() : r.call(e, n, 1), --this.size, !0)
      );
    };
    var c = function (t) {
      var e = this.__data__,
        n = o(e, t);
      return n < 0 ? void 0 : e[n][1];
    };
    var l = function (t) {
      return o(this.__data__, t) > -1;
    };
    var u = function (t, e) {
      var n = this.__data__,
        i = o(n, t);
      return i < 0 ? (++this.size, n.push([t, e])) : (n[i][1] = e), this;
    };
    function d(t) {
      var e = -1,
        n = null == t ? 0 : t.length;
      for (this.clear(); ++e < n; ) {
        var i = t[e];
        this.set(i[0], i[1]);
      }
    }
    (d.prototype.clear = i),
      (d.prototype.delete = a),
      (d.prototype.get = c),
      (d.prototype.has = l),
      (d.prototype.set = u);
    e.a = d;
  },
  function (t, e, n) {
    "use strict";
    var i = n(63),
      s = n(30);
    e.a = function (t) {
      if (!Object(s.a)(t)) return !1;
      var e = Object(i.a)(t);
      return (
        "[object Function]" == e ||
        "[object GeneratorFunction]" == e ||
        "[object AsyncFunction]" == e ||
        "[object Proxy]" == e
      );
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(70),
      s = n(41),
      o = Object(i.a)(s.a, "Map");
    e.a = o;
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "d", function () {
      return c;
    }),
      n.d(e, "c", function () {
        return l;
      }),
      n.d(e, "b", function () {
        return u;
      }),
      n.d(e, "a", function () {
        return d;
      });
    var i = n(101),
      s = n(221),
      o = n(96),
      r = n(109),
      a = n(93);
    class c extends s.a {
      elementToElement(t) {
        return this.add(h(t));
      }
      elementToAttribute(t) {
        return this.add(
          (function (t) {
            g((t = Object(o.a)(t)));
            const e = p(t, !1),
              n = f(t.view),
              i = n ? "element:" + n : "element";
            return (n) => {
              n.on(i, e, { priority: t.converterPriority || "low" });
            };
          })(t)
        );
      }
      attributeToAttribute(t) {
        return this.add(
          (function (t) {
            t = Object(o.a)(t);
            let e = null;
            ("string" == typeof t.view || t.view.key) &&
              (e = (function (t) {
                "string" == typeof t.view && (t.view = { key: t.view });
                const e = t.view.key;
                let n;
                if ("class" == e || "style" == e) {
                  n = { ["class" == e ? "classes" : "styles"]: t.view.value };
                } else {
                  const i = void 0 === t.view.value ? /[\s\S]*/ : t.view.value;
                  n = { attributes: { [e]: i } };
                }
                t.view.name && (n.name = t.view.name);
                return (t.view = n), e;
              })(t));
            g(t, e);
            const n = p(t, !0);
            return (e) => {
              e.on("element", n, { priority: t.converterPriority || "low" });
            };
          })(t)
        );
      }
      elementToMarker(t) {
        return this.add(
          (function (t) {
            return (
              (function (t) {
                const e = t.model;
                t.model = (t, n) => {
                  const i = "string" == typeof e ? e : e(t, n);
                  return n.writer.createElement("$marker", { "data-name": i });
                };
              })((t = Object(o.a)(t))),
              h(t)
            );
          })(t)
        );
      }
      dataToMarker(t) {
        return this.add(
          (function (t) {
            (t = Object(o.a)(t)).model ||
              (t.model = (e) => (e ? t.view + ":" + e : t.view));
            const e = m(b(t, "start")),
              n = m(b(t, "end"));
            return (i) => {
              i.on("element:" + t.view + "-start", e, {
                priority: t.converterPriority || "normal",
              }),
                i.on("element:" + t.view + "-end", n, {
                  priority: t.converterPriority || "normal",
                });
              const s = r.default.get("low"),
                o = r.default.get("highest"),
                a = r.default.get(t.converterPriority) / o;
              i.on(
                "element",
                (function (t) {
                  return (e, n, i) => {
                    const s = "data-" + t.view;
                    function o(e, s) {
                      for (const o of s) {
                        const s = t.model(o, i),
                          r = i.writer.createElement("$marker", {
                            "data-name": s,
                          });
                        i.writer.insert(r, e),
                          n.modelCursor.isEqual(e)
                            ? (n.modelCursor = n.modelCursor.getShiftedBy(1))
                            : (n.modelCursor =
                                n.modelCursor._getTransformedByInsertion(e, 1)),
                          (n.modelRange =
                            n.modelRange._getTransformedByInsertion(e, 1)[0]);
                      }
                    }
                    (i.consumable.test(n.viewItem, {
                      attributes: s + "-end-after",
                    }) ||
                      i.consumable.test(n.viewItem, {
                        attributes: s + "-start-after",
                      }) ||
                      i.consumable.test(n.viewItem, {
                        attributes: s + "-end-before",
                      }) ||
                      i.consumable.test(n.viewItem, {
                        attributes: s + "-start-before",
                      })) &&
                      (n.modelRange ||
                        Object.assign(
                          n,
                          i.convertChildren(n.viewItem, n.modelCursor)
                        ),
                      i.consumable.consume(n.viewItem, {
                        attributes: s + "-end-after",
                      }) &&
                        o(
                          n.modelRange.end,
                          n.viewItem.getAttribute(s + "-end-after").split(",")
                        ),
                      i.consumable.consume(n.viewItem, {
                        attributes: s + "-start-after",
                      }) &&
                        o(
                          n.modelRange.end,
                          n.viewItem.getAttribute(s + "-start-after").split(",")
                        ),
                      i.consumable.consume(n.viewItem, {
                        attributes: s + "-end-before",
                      }) &&
                        o(
                          n.modelRange.start,
                          n.viewItem.getAttribute(s + "-end-before").split(",")
                        ),
                      i.consumable.consume(n.viewItem, {
                        attributes: s + "-start-before",
                      }) &&
                        o(
                          n.modelRange.start,
                          n.viewItem
                            .getAttribute(s + "-start-before")
                            .split(",")
                        ));
                  };
                })(t),
                { priority: s + a }
              );
            };
          })(t)
        );
      }
    }
    function l() {
      return (t, e, n) => {
        if (!e.modelRange && n.consumable.consume(e.viewItem, { name: !0 })) {
          const { modelRange: t, modelCursor: i } = n.convertChildren(
            e.viewItem,
            e.modelCursor
          );
          (e.modelRange = t), (e.modelCursor = i);
        }
      };
    }
    function u() {
      return (t, e, { schema: n, consumable: i, writer: s }) => {
        let o = e.modelCursor;
        if (!i.test(e.viewItem)) return;
        if (!n.checkChild(o, "$text")) {
          if (!Object(a.b)(o, "$text", n)) return;
          o = Object(a.c)(o, s);
        }
        i.consume(e.viewItem);
        const r = s.createText(e.viewItem.data);
        s.insert(r, o),
          (e.modelRange = s.createRange(o, o.getShiftedBy(r.offsetSize))),
          (e.modelCursor = e.modelRange.end);
      };
    }
    function d(t, e) {
      return (n, i) => {
        const s = i.newSelection,
          o = [];
        for (const t of s.getRanges()) o.push(e.toModelRange(t));
        const r = t.createSelection(o, { backward: s.isBackward });
        r.isEqual(t.document.selection) ||
          t.change((t) => {
            t.setSelection(r);
          });
      };
    }
    function h(t) {
      const e = m((t = Object(o.a)(t))),
        n = f(t.view),
        i = n ? "element:" + n : "element";
      return (n) => {
        n.on(i, e, { priority: t.converterPriority || "normal" });
      };
    }
    function f(t) {
      return "string" == typeof t
        ? t
        : "object" == typeof t && "string" == typeof t.name
        ? t.name
        : null;
    }
    function m(t) {
      const e = new i.a(t.view);
      return (n, i, s) => {
        const o = e.match(i.viewItem);
        if (!o) return;
        const r = o.match;
        if (((r.name = !0), !s.consumable.test(i.viewItem, r))) return;
        const a = (function (t, e, n) {
          return t instanceof Function ? t(e, n) : n.writer.createElement(t);
        })(t.model, i.viewItem, s);
        a &&
          s.safeInsert(a, i.modelCursor) &&
          (s.consumable.consume(i.viewItem, r),
          s.convertChildren(i.viewItem, a),
          s.updateConversionResult(a, i));
      };
    }
    function g(t, e = null) {
      const n = null === e || ((t) => t.getAttribute(e)),
        i = "object" != typeof t.model ? t.model : t.model.key,
        s =
          "object" != typeof t.model || void 0 === t.model.value
            ? n
            : t.model.value;
      t.model = { key: i, value: s };
    }
    function p(t, e) {
      const n = new i.a(t.view);
      return (i, s, o) => {
        const r = n.match(s.viewItem);
        if (!r) return;
        if (
          (!(function (t, e) {
            const n = "function" == typeof t ? t(e) : t;
            if ("object" == typeof n && !f(n)) return !1;
            return !n.classes && !n.attributes && !n.styles;
          })(t.view, s.viewItem)
            ? delete r.match.name
            : (r.match.name = !0),
          !o.consumable.test(s.viewItem, r.match))
        )
          return;
        const a = t.model.key,
          c =
            "function" == typeof t.model.value
              ? t.model.value(s.viewItem, o)
              : t.model.value;
        if (null === c) return;
        s.modelRange ||
          Object.assign(s, o.convertChildren(s.viewItem, s.modelCursor));
        (function (t, e, n, i) {
          let s = !1;
          for (const o of Array.from(t.getItems({ shallow: n })))
            i.schema.checkAttribute(o, e.key) &&
              ((s = !0),
              o.hasAttribute(e.key) ||
                i.writer.setAttribute(e.key, e.value, o));
          return s;
        })(s.modelRange, { key: a, value: c }, e, o) &&
          o.consumable.consume(s.viewItem, r.match);
      };
    }
    function b(t, e) {
      const n = {};
      return (
        (n.view = t.view + "-" + e),
        (n.model = (e, n) => {
          const i = e.getAttribute("name"),
            s = t.model(i, n);
          return n.writer.createElement("$marker", { "data-name": s });
        }),
        n
      );
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(40),
      s = n(0);
    class o extends i.a {
      constructor(t, e, n, i, s) {
        super(s),
          (this.root = t),
          (this.key = e),
          (this.oldValue = n),
          (this.newValue = i);
      }
      get type() {
        return null === this.oldValue
          ? "addRootAttribute"
          : null === this.newValue
          ? "removeRootAttribute"
          : "changeRootAttribute";
      }
      clone() {
        return new o(
          this.root,
          this.key,
          this.oldValue,
          this.newValue,
          this.baseVersion
        );
      }
      getReversed() {
        return new o(
          this.root,
          this.key,
          this.newValue,
          this.oldValue,
          this.baseVersion + 1
        );
      }
      _validate() {
        if (this.root != this.root.root || this.root.is("documentFragment"))
          throw new s.default("rootattribute-operation-not-a-root", this, {
            root: this.root,
            key: this.key,
          });
        if (
          null !== this.oldValue &&
          this.root.getAttribute(this.key) !== this.oldValue
        )
          throw new s.default("rootattribute-operation-wrong-old-value", this, {
            root: this.root,
            key: this.key,
          });
        if (
          null === this.oldValue &&
          null !== this.newValue &&
          this.root.hasAttribute(this.key)
        )
          throw new s.default(
            "rootattribute-operation-attribute-exists",
            this,
            { root: this.root, key: this.key }
          );
      }
      _execute() {
        null !== this.newValue
          ? this.root._setAttribute(this.key, this.newValue)
          : this.root._removeAttribute(this.key);
      }
      toJSON() {
        const t = super.toJSON();
        return (t.root = this.root.toJSON()), t;
      }
      static get className() {
        return "RootAttributeOperation";
      }
      static fromJSON(t, e) {
        if (!e.getRoot(t.root))
          throw new s.default(
            "rootattribute-operation-fromjson-no-root",
            this,
            { rootName: t.root }
          );
        return new o(
          e.getRoot(t.root),
          t.key,
          t.oldValue,
          t.newValue,
          t.baseVersion
        );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(122);
    var s = function () {
      (this.__data__ = new i.a()), (this.size = 0);
    };
    var o = function (t) {
      var e = this.__data__,
        n = e.delete(t);
      return (this.size = e.size), n;
    };
    var r = function (t) {
      return this.__data__.get(t);
    };
    var a = function (t) {
        return this.__data__.has(t);
      },
      c = n(124),
      l = n(136);
    var u = function (t, e) {
      var n = this.__data__;
      if (n instanceof i.a) {
        var s = n.__data__;
        if (!c.a || s.length < 199)
          return s.push([t, e]), (this.size = ++n.size), this;
        n = this.__data__ = new l.a(s);
      }
      return n.set(t, e), (this.size = n.size), this;
    };
    function d(t) {
      var e = (this.__data__ = new i.a(t));
      this.size = e.size;
    }
    (d.prototype.clear = s),
      (d.prototype.delete = o),
      (d.prototype.get = r),
      (d.prototype.has = a),
      (d.prototype.set = u);
    e.a = d;
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return g;
    });
    var i = n(9),
      s = n(45),
      o = n(172),
      r = n(225);
    class a extends s.a {
      constructor(t, e) {
        super(t),
          (this.direction = e),
          (this._buffer = new r.a(t.model, t.config.get("typing.undoStep")));
      }
      get buffer() {
        return this._buffer;
      }
      execute(t = {}) {
        const e = this.editor.model,
          n = e.document;
        e.enqueueChange(this._buffer.batch, (i) => {
          this._buffer.lock();
          const s = i.createSelection(t.selection || n.selection),
            r = t.sequence || 1,
            a = s.isCollapsed;
          if (
            (s.isCollapsed &&
              e.modifySelection(s, { direction: this.direction, unit: t.unit }),
            this._shouldEntireContentBeReplacedWithParagraph(r))
          )
            return void this._replaceEntireContentWithParagraph(i);
          if (this._shouldReplaceFirstBlockWithParagraph(s, r))
            return void this.editor.execute("paragraph", { selection: s });
          if (s.isCollapsed) return;
          let c = 0;
          s
            .getFirstRange()
            .getMinimalFlatRanges()
            .forEach((t) => {
              c += Object(o.a)(
                t.getWalker({
                  singleCharacters: !0,
                  ignoreElementEnd: !0,
                  shallow: !0,
                })
              );
            }),
            e.deleteContent(s, {
              doNotResetEntireContent: a,
              direction: this.direction,
            }),
            this._buffer.input(c),
            i.setSelection(s),
            this._buffer.unlock();
        });
      }
      _shouldEntireContentBeReplacedWithParagraph(t) {
        if (t > 1) return !1;
        const e = this.editor.model,
          n = e.document.selection,
          i = e.schema.getLimitElement(n);
        if (!(n.isCollapsed && n.containsEntireContent(i))) return !1;
        if (!e.schema.checkChild(i, "paragraph")) return !1;
        const s = i.getChild(0);
        return !s || "paragraph" !== s.name;
      }
      _replaceEntireContentWithParagraph(t) {
        const e = this.editor.model,
          n = e.document.selection,
          i = e.schema.getLimitElement(n),
          s = t.createElement("paragraph");
        t.remove(t.createRangeIn(i)), t.insert(s, i), t.setSelection(s, 0);
      }
      _shouldReplaceFirstBlockWithParagraph(t, e) {
        const n = this.editor.model;
        if (e > 1 || "backward" != this.direction) return !1;
        if (!t.isCollapsed) return !1;
        const i = t.getFirstPosition(),
          s = n.schema.getLimitElement(i),
          o = s.getChild(0);
        return (
          i.parent == o &&
          !!t.containsEntireContent(o) &&
          !!n.schema.checkChild(s, "paragraph") &&
          "paragraph" != o.name
        );
      }
    }
    var c = n(58),
      l = n(111),
      u = n(120),
      d = n(12),
      h = n(21),
      f = n(137);
    class m extends c.a {
      constructor(t) {
        super(t);
        const e = t.document;
        let n = 0;
        function i(t, n, i) {
          const s = new u.a(e, "delete", e.selection.getFirstRange());
          e.fire(s, new l.a(e, n, i)), s.stop.called && t.stop();
        }
        e.on("keyup", (t, e) => {
          (e.keyCode != d.f.delete && e.keyCode != d.f.backspace) || (n = 0);
        }),
          e.on("keydown", (t, s) => {
            if (h.a.isWindows && Object(f.c)(s, e)) return;
            const o = {};
            if (s.keyCode == d.f.delete)
              (o.direction = "forward"), (o.unit = "character");
            else {
              if (s.keyCode != d.f.backspace) return;
              (o.direction = "backward"), (o.unit = "codePoint");
            }
            const r = h.a.isMac ? s.altKey : s.ctrlKey;
            (o.unit = r ? "word" : o.unit),
              (o.sequence = ++n),
              i(t, s.domEvent, o);
          }),
          h.a.isAndroid &&
            e.on("beforeinput", (e, n) => {
              if ("deleteContentBackward" != n.domEvent.inputType) return;
              const s = {
                  unit: "codepoint",
                  direction: "backward",
                  sequence: 1,
                },
                o = n.domTarget.ownerDocument.defaultView.getSelection();
              o.anchorNode == o.focusNode &&
                o.anchorOffset + 1 != o.focusOffset &&
                (s.selectionToRemove = t.domConverter.domSelectionToView(o)),
                i(e, n.domEvent, s);
            });
      }
      observe() {}
    }
    class g extends i.a {
      static get pluginName() {
        return "Delete";
      }
      init() {
        const t = this.editor,
          e = t.editing.view,
          n = e.document,
          i = t.model.document;
        e.addObserver(m), (this._undoOnBackspace = !1);
        const s = new a(t, "forward");
        if (
          (t.commands.add("deleteForward", s),
          t.commands.add("forwardDelete", s),
          t.commands.add("delete", new a(t, "backward")),
          this.listenTo(
            n,
            "delete",
            (n, i) => {
              const s = { unit: i.unit, sequence: i.sequence };
              if (i.selectionToRemove) {
                const e = t.model.createSelection(),
                  n = [];
                for (const e of i.selectionToRemove.getRanges())
                  n.push(t.editing.mapper.toModelRange(e));
                e.setTo(n), (s.selection = e);
              }
              t.execute(
                "forward" == i.direction ? "deleteForward" : "delete",
                s
              ),
                i.preventDefault(),
                e.scrollToTheSelection();
            },
            { priority: "low" }
          ),
          h.a.isAndroid)
        ) {
          let t = null;
          this.listenTo(
            n,
            "delete",
            (e, n) => {
              const i = n.domTarget.ownerDocument.defaultView.getSelection();
              t = {
                anchorNode: i.anchorNode,
                anchorOffset: i.anchorOffset,
                focusNode: i.focusNode,
                focusOffset: i.focusOffset,
              };
            },
            { priority: "lowest" }
          ),
            this.listenTo(n, "keyup", (e, n) => {
              if (t) {
                const e = n.domTarget.ownerDocument.defaultView.getSelection();
                e.collapse(t.anchorNode, t.anchorOffset),
                  e.extend(t.focusNode, t.focusOffset),
                  (t = null);
              }
            });
        }
        this.editor.plugins.has("UndoEditing") &&
          (this.listenTo(
            n,
            "delete",
            (e, n) => {
              this._undoOnBackspace &&
                "backward" == n.direction &&
                1 == n.sequence &&
                "codePoint" == n.unit &&
                ((this._undoOnBackspace = !1),
                t.execute("undo"),
                n.preventDefault(),
                e.stop());
            },
            { context: "$capture" }
          ),
          this.listenTo(i, "change", () => {
            this._undoOnBackspace = !1;
          }));
      }
      requestUndoOnBackspace() {
        this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = !0);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(59);
    class s extends i.a {
      constructor(t) {
        super(t),
          (this.domEventType = [
            "mousedown",
            "mouseup",
            "mouseover",
            "mouseout",
          ]);
      }
      onDomEvent(t) {
        this.fire(t.type, t);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return i.a;
    }),
      n.d(e, "b", function () {
        return d;
      });
    var i = n(204),
      s = n(45),
      o = n(232);
    class r extends s.a {
      execute() {
        const t = this.editor.model,
          e = t.document;
        t.change((n) => {
          !(function (t, e, n) {
            const i = n.isCollapsed,
              s = n.getFirstRange(),
              r = s.start.parent,
              c = s.end.parent,
              l = r == c;
            if (i) {
              const i = Object(o.a)(t.schema, n.getAttributes());
              a(t, e, s.end),
                e.removeSelectionAttribute(n.getAttributeKeys()),
                e.setSelectionAttribute(i);
            } else {
              const i = !(s.start.isAtStart && s.end.isAtEnd);
              t.deleteContent(n, { leaveUnmerged: i }),
                l ? a(t, e, n.focus) : i && e.setSelection(c, 0);
            }
          })(t, n, e.selection),
            this.fire("afterExecute", { writer: n });
        });
      }
      refresh() {
        const t = this.editor.model,
          e = t.document;
        this.isEnabled = (function (t, e) {
          if (e.rangeCount > 1) return !1;
          const n = e.anchor;
          if (!n || !t.checkChild(n, "softBreak")) return !1;
          const i = e.getFirstRange(),
            s = i.start.parent,
            o = i.end.parent;
          if ((c(s, t) || c(o, t)) && s !== o) return !1;
          return !0;
        })(t.schema, e.selection);
      }
    }
    function a(t, e, n) {
      const i = e.createElement("softBreak");
      t.insertContent(i, n), e.setSelection(i, "after");
    }
    function c(t, e) {
      return !t.is("rootElement") && (e.isLimit(t) || c(t.parent, e));
    }
    var l = n(233),
      u = n(9);
    class d extends u.a {
      static get pluginName() {
        return "ShiftEnter";
      }
      init() {
        const t = this.editor,
          e = t.model.schema,
          n = t.conversion,
          i = t.editing.view,
          s = i.document;
        e.register("softBreak", { allowWhere: "$text", isInline: !0 }),
          n.for("upcast").elementToElement({ model: "softBreak", view: "br" }),
          n.for("downcast").elementToElement({
            model: "softBreak",
            view: (t, { writer: e }) => e.createEmptyElement("br"),
          }),
          i.addObserver(l.a),
          t.commands.add("shiftEnter", new r(t)),
          this.listenTo(
            s,
            "enter",
            (e, n) => {
              n.preventDefault(),
                n.isSoft && (t.execute("shiftEnter"), i.scrollToTheSelection());
            },
            { priority: "low" }
          );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return d;
    });
    var i = n(9),
      s = n(175),
      o = n(0),
      r = n(14),
      a = n(51),
      c = n(6);
    class l {
      constructor() {
        const t = new window.FileReader();
        (this._reader = t),
          (this._data = void 0),
          this.set("loaded", 0),
          (t.onprogress = (t) => {
            this.loaded = t.loaded;
          });
      }
      get error() {
        return this._reader.error;
      }
      get data() {
        return this._data;
      }
      read(t) {
        const e = this._reader;
        return (
          (this.total = t.size),
          new Promise((n, i) => {
            (e.onload = () => {
              const t = e.result;
              (this._data = t), n(t);
            }),
              (e.onerror = () => {
                i("error");
              }),
              (e.onabort = () => {
                i("aborted");
              }),
              this._reader.readAsDataURL(t);
          })
        );
      }
      abort() {
        this._reader.abort();
      }
    }
    Object(c.default)(l, r.default);
    var u = n(44);
    class d extends i.a {
      static get pluginName() {
        return "FileRepository";
      }
      static get requires() {
        return [s.a];
      }
      init() {
        (this.loaders = new a.default()),
          this.loaders.on("add", () => this._updatePendingAction()),
          this.loaders.on("remove", () => this._updatePendingAction()),
          (this._loadersMap = new Map()),
          (this._pendingAction = null),
          this.set("uploaded", 0),
          this.set("uploadTotal", null),
          this.bind("uploadedPercent").to(
            this,
            "uploaded",
            this,
            "uploadTotal",
            (t, e) => (e ? (t / e) * 100 : 0)
          );
      }
      getLoader(t) {
        return this._loadersMap.get(t) || null;
      }
      createLoader(t) {
        if (!this.createUploadAdapter)
          return Object(o.logWarning)("filerepository-no-upload-adapter"), null;
        const e = new h(Promise.resolve(t), this.createUploadAdapter);
        return (
          this.loaders.add(e),
          this._loadersMap.set(t, e),
          t instanceof Promise &&
            e.file
              .then((t) => {
                this._loadersMap.set(t, e);
              })
              .catch(() => {}),
          e.on("change:uploaded", () => {
            let t = 0;
            for (const e of this.loaders) t += e.uploaded;
            this.uploaded = t;
          }),
          e.on("change:uploadTotal", () => {
            let t = 0;
            for (const e of this.loaders) e.uploadTotal && (t += e.uploadTotal);
            this.uploadTotal = t;
          }),
          e
        );
      }
      destroyLoader(t) {
        const e = t instanceof h ? t : this.getLoader(t);
        e._destroy(),
          this.loaders.remove(e),
          this._loadersMap.forEach((t, n) => {
            t === e && this._loadersMap.delete(n);
          });
      }
      _updatePendingAction() {
        const t = this.editor.plugins.get(s.a);
        if (this.loaders.length) {
          if (!this._pendingAction) {
            const e = this.editor.t,
              n = (t) => `${e("Upload in progress")} ${parseInt(t)}%.`;
            (this._pendingAction = t.add(n(this.uploadedPercent))),
              this._pendingAction
                .bind("message")
                .to(this, "uploadedPercent", n);
          }
        } else t.remove(this._pendingAction), (this._pendingAction = null);
      }
    }
    Object(c.default)(d, r.default);
    class h {
      constructor(t, e) {
        (this.id = Object(u.a)()),
          (this._filePromiseWrapper = this._createFilePromiseWrapper(t)),
          (this._adapter = e(this)),
          (this._reader = new l()),
          this.set("status", "idle"),
          this.set("uploaded", 0),
          this.set("uploadTotal", null),
          this.bind("uploadedPercent").to(
            this,
            "uploaded",
            this,
            "uploadTotal",
            (t, e) => (e ? (t / e) * 100 : 0)
          ),
          this.set("uploadResponse", null);
      }
      get file() {
        return this._filePromiseWrapper
          ? this._filePromiseWrapper.promise.then((t) =>
              this._filePromiseWrapper ? t : null
            )
          : Promise.resolve(null);
      }
      get data() {
        return this._reader.data;
      }
      read() {
        if ("idle" != this.status)
          throw new o.default("filerepository-read-wrong-status", this);
        return (
          (this.status = "reading"),
          this.file
            .then((t) => this._reader.read(t))
            .then((t) => {
              if ("reading" !== this.status) throw this.status;
              return (this.status = "idle"), t;
            })
            .catch((t) => {
              if ("aborted" === t) throw ((this.status = "aborted"), "aborted");
              throw (
                ((this.status = "error"),
                this._reader.error ? this._reader.error : t)
              );
            })
        );
      }
      upload() {
        if ("idle" != this.status)
          throw new o.default("filerepository-upload-wrong-status", this);
        return (
          (this.status = "uploading"),
          this.file
            .then(() => this._adapter.upload())
            .then((t) => ((this.uploadResponse = t), (this.status = "idle"), t))
            .catch((t) => {
              if ("aborted" === this.status) throw "aborted";
              throw ((this.status = "error"), t);
            })
        );
      }
      abort() {
        const t = this.status;
        (this.status = "aborted"),
          this._filePromiseWrapper.isFulfilled
            ? "reading" == t
              ? this._reader.abort()
              : "uploading" == t && this._adapter.abort && this._adapter.abort()
            : (this._filePromiseWrapper.promise.catch(() => {}),
              this._filePromiseWrapper.rejecter("aborted")),
          this._destroy();
      }
      _destroy() {
        (this._filePromiseWrapper = void 0),
          (this._reader = void 0),
          (this._adapter = void 0),
          (this.uploadResponse = void 0);
      }
      _createFilePromiseWrapper(t) {
        const e = {};
        return (
          (e.promise = new Promise((n, i) => {
            (e.rejecter = i),
              (e.isFulfilled = !1),
              t
                .then((t) => {
                  (e.isFulfilled = !0), n(t);
                })
                .catch((t) => {
                  (e.isFulfilled = !0), i(t);
                });
          })),
          e
        );
      }
    }
    Object(c.default)(h, r.default);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "c", function () {
      return p;
    }),
      n.d(e, "b", function () {
        return b;
      }),
      n.d(e, "a", function () {
        return w;
      });
    var i = n(8);
    class s extends i.a {
      constructor(t) {
        super(t);
        const e = this.bindTemplate;
        this.set("isVisible", !1),
          this.set("position", "se"),
          (this.children = this.createCollection()),
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-reset",
                "ck-dropdown__panel",
                e.to("position", (t) => "ck-dropdown__panel_" + t),
                e.if("isVisible", "ck-dropdown__panel-visible"),
              ],
            },
            children: this.children,
            on: { selectstart: e.to((t) => t.preventDefault()) },
          });
      }
      focus() {
        this.children.length && this.children.first.focus();
      }
      focusLast() {
        if (this.children.length) {
          const t = this.children.last;
          "function" == typeof t.focusLast ? t.focusLast() : t.focus();
        }
      }
    }
    var o = n(69),
      r = (n(336), n(157));
    class a extends i.a {
      constructor(t, e, n) {
        super(t);
        const i = this.bindTemplate;
        (this.buttonView = e),
          (this.panelView = n),
          this.set("isOpen", !1),
          this.set("isEnabled", !0),
          this.set("class"),
          this.set("id"),
          this.set("panelPosition", "auto"),
          (this.keystrokes = new o.a()),
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-dropdown",
                i.to("class"),
                i.if("isEnabled", "ck-disabled", (t) => !t),
              ],
              id: i.to("id"),
              "aria-describedby": i.to("ariaDescribedById"),
            },
            children: [e, n],
          }),
          e.extendTemplate({ attributes: { class: ["ck-dropdown__button"] } });
      }
      render() {
        super.render(),
          this.listenTo(this.buttonView, "open", () => {
            this.isOpen = !this.isOpen;
          }),
          this.panelView.bind("isVisible").to(this, "isOpen"),
          this.on("change:isOpen", () => {
            this.isOpen &&
              ("auto" === this.panelPosition
                ? (this.panelView.position = a._getOptimalPosition({
                    element: this.panelView.element,
                    target: this.buttonView.element,
                    fitInViewport: !0,
                    positions: this._panelPositions,
                  }).name)
                : (this.panelView.position = this.panelPosition));
          }),
          this.keystrokes.listenTo(this.element);
        const t = (t, e) => {
          this.isOpen && (this.buttonView.focus(), (this.isOpen = !1), e());
        };
        this.keystrokes.set("arrowdown", (t, e) => {
          this.buttonView.isEnabled &&
            !this.isOpen &&
            ((this.isOpen = !0), e());
        }),
          this.keystrokes.set("arrowright", (t, e) => {
            this.isOpen && e();
          }),
          this.keystrokes.set("arrowleft", t),
          this.keystrokes.set("esc", t);
      }
      focus() {
        this.buttonView.focus();
      }
      get _panelPositions() {
        const {
          south: t,
          north: e,
          southEast: n,
          southWest: i,
          northEast: s,
          northWest: o,
          southMiddleEast: r,
          southMiddleWest: c,
          northMiddleEast: l,
          northMiddleWest: u,
        } = a.defaultPanelPositions;
        return "rtl" !== this.locale.uiLanguageDirection
          ? [n, i, r, c, t, s, o, l, u, e]
          : [i, n, c, r, t, o, s, u, l, e];
      }
    }
    (a.defaultPanelPositions = {
      south: (t, e) => ({
        top: t.bottom,
        left: t.left - (e.width - t.width) / 2,
        name: "s",
      }),
      southEast: (t) => ({ top: t.bottom, left: t.left, name: "se" }),
      southWest: (t, e) => ({
        top: t.bottom,
        left: t.left - e.width + t.width,
        name: "sw",
      }),
      southMiddleEast: (t, e) => ({
        top: t.bottom,
        left: t.left - (e.width - t.width) / 4,
        name: "sme",
      }),
      southMiddleWest: (t, e) => ({
        top: t.bottom,
        left: t.left - (3 * (e.width - t.width)) / 4,
        name: "smw",
      }),
      north: (t, e) => ({
        top: t.top - e.height,
        left: t.left - (e.width - t.width) / 2,
        name: "n",
      }),
      northEast: (t, e) => ({
        top: t.top - e.height,
        left: t.left,
        name: "ne",
      }),
      northWest: (t, e) => ({
        top: t.top - e.height,
        left: t.left - e.width + t.width,
        name: "nw",
      }),
      northMiddleEast: (t, e) => ({
        top: t.top - e.height,
        left: t.left - (e.width - t.width) / 4,
        name: "nme",
      }),
      northMiddleWest: (t, e) => ({
        top: t.top - e.height,
        left: t.left - (3 * (e.width - t.width)) / 4,
        name: "nmw",
      }),
    }),
      (a._getOptimalPosition = r.a);
    var c = n(169),
      l = n(97),
      u = n(194),
      d = n(195);
    class h extends i.a {
      constructor(t) {
        super(t),
          this.setTemplate({
            tag: "li",
            attributes: { class: ["ck", "ck-list__separator"] },
          });
      }
    }
    var f = n(34),
      m = n(168),
      g = n(142);
    n(339), n(340);
    function p(t, e = c.a) {
      const n = new e(t),
        i = new s(t),
        o = new a(t, n, i);
      return (
        n.bind("isEnabled").to(o),
        n instanceof c.a
          ? n.bind("isOn").to(o, "isOpen")
          : n.arrowView.bind("isOn").to(o, "isOpen"),
        (function (t) {
          (function (t) {
            t.on("render", () => {
              Object(g.a)({
                emitter: t,
                activator: () => t.isOpen,
                callback: () => {
                  t.isOpen = !1;
                },
                contextElements: [t.element],
              });
            });
          })(t),
            (function (t) {
              t.on("execute", (e) => {
                e.source instanceof m.a || (t.isOpen = !1);
              });
            })(t),
            (function (t) {
              t.keystrokes.set("arrowdown", (e, n) => {
                t.isOpen && (t.panelView.focus(), n());
              }),
                t.keystrokes.set("arrowup", (e, n) => {
                  t.isOpen && (t.panelView.focusLast(), n());
                });
            })(t);
        })(o),
        o
      );
    }
    function b(t, e) {
      const n = t.locale,
        i = n.t,
        s = (t.toolbarView = new l.a(n));
      s.set("ariaLabel", i("Dropdown toolbar")),
        t.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } }),
        e.map((t) => s.items.add(t)),
        t.panelView.children.add(s),
        s.items.delegate("execute").to(t);
    }
    function w(t, e) {
      const n = t.locale,
        i = (t.listView = new u.a(n));
      i.items.bindTo(e).using(({ type: t, model: e }) => {
        if ("separator" === t) return new h(n);
        if ("button" === t || "switchbutton" === t) {
          const i = new d.a(n);
          let s;
          return (
            (s = "button" === t ? new f.a(n) : new m.a(n)),
            s.bind(...Object.keys(e)).to(e),
            s.delegate("execute").to(i),
            i.children.add(s),
            i
          );
        }
      }),
        t.panelView.children.add(i),
        i.items.delegate("execute").to(t);
    }
  },
  function (t, e, n) {
    "use strict";
    (function (t) {
      var i = n(0);
      e.a = "31.1.0";
      const s = "object" == typeof window ? window : t;
      if (s.CKEDITOR_VERSION)
        throw new i.default("ckeditor-duplicated-modules", null);
      s.CKEDITOR_VERSION = "31.1.0";
    }.call(this, n(259)));
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    }),
      n.d(e, "b", function () {
        return c;
      });
    var i = n(50),
      s = n(0),
      o = n(79),
      r = n(12);
    class a extends i.a {
      constructor(t, e, n, i) {
        super(t, e, n, i),
          (this._isAllowedInsideAttributeElement = !0),
          (this.getFillerOffset = l);
      }
      is(t, e = null) {
        return e
          ? e === this.name &&
              ("uiElement" === t ||
                "view:uiElement" === t ||
                "element" === t ||
                "view:element" === t)
          : "uiElement" === t ||
              "view:uiElement" === t ||
              "element" === t ||
              "view:element" === t ||
              "node" === t ||
              "view:node" === t;
      }
      _insertChild(t, e) {
        if (e && (e instanceof o.a || Array.from(e).length > 0))
          throw new s.default("view-uielement-cannot-add", this);
      }
      render(t) {
        return this.toDomElement(t);
      }
      toDomElement(t) {
        const e = t.createElement(this.name);
        for (const t of this.getAttributeKeys())
          e.setAttribute(t, this.getAttribute(t));
        return e;
      }
    }
    function c(t) {
      t.document.on(
        "arrowKey",
        (e, n) =>
          (function (t, e, n) {
            if (e.keyCode == r.f.arrowright) {
              const t = e.domTarget.ownerDocument.defaultView.getSelection(),
                i = 1 == t.rangeCount && t.getRangeAt(0).collapsed;
              if (i || e.shiftKey) {
                const e = t.focusNode,
                  s = t.focusOffset,
                  o = n.domPositionToView(e, s);
                if (null === o) return;
                let r = !1;
                const a = o.getLastMatchingPosition(
                  (t) => (
                    t.item.is("uiElement") && (r = !0),
                    !(!t.item.is("uiElement") && !t.item.is("attributeElement"))
                  )
                );
                if (r) {
                  const e = n.viewPositionToDom(a);
                  i
                    ? t.collapse(e.parent, e.offset)
                    : t.extend(e.parent, e.offset);
                }
              }
            }
          })(0, n, t.domConverter),
        { priority: "low" }
      );
    }
    function l() {
      return null;
    }
  },
  function (t, e, n) {
    "use strict";
    function i(t) {
      return "[object Range]" == Object.prototype.toString.apply(t);
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    var i = n(70),
      s = Object(i.a)(Object, "create");
    var o = function () {
      (this.__data__ = s ? s(null) : {}), (this.size = 0);
    };
    var r = function (t) {
        var e = this.has(t) && delete this.__data__[t];
        return (this.size -= e ? 1 : 0), e;
      },
      a = Object.prototype.hasOwnProperty;
    var c = function (t) {
        var e = this.__data__;
        if (s) {
          var n = e[t];
          return "__lodash_hash_undefined__" === n ? void 0 : n;
        }
        return a.call(e, t) ? e[t] : void 0;
      },
      l = Object.prototype.hasOwnProperty;
    var u = function (t) {
      var e = this.__data__;
      return s ? void 0 !== e[t] : l.call(e, t);
    };
    var d = function (t, e) {
      var n = this.__data__;
      return (
        (this.size += this.has(t) ? 0 : 1),
        (n[t] = s && void 0 === e ? "__lodash_hash_undefined__" : e),
        this
      );
    };
    function h(t) {
      var e = -1,
        n = null == t ? 0 : t.length;
      for (this.clear(); ++e < n; ) {
        var i = t[e];
        this.set(i[0], i[1]);
      }
    }
    (h.prototype.clear = o),
      (h.prototype.delete = r),
      (h.prototype.get = c),
      (h.prototype.has = u),
      (h.prototype.set = d);
    var f = h,
      m = n(122),
      g = n(124);
    var p = function () {
      (this.size = 0),
        (this.__data__ = {
          hash: new f(),
          map: new (g.a || m.a)(),
          string: new f(),
        });
    };
    var b = function (t) {
      var e = typeof t;
      return "string" == e || "number" == e || "symbol" == e || "boolean" == e
        ? "__proto__" !== t
        : null === t;
    };
    var w = function (t, e) {
      var n = t.__data__;
      return b(e) ? n["string" == typeof e ? "string" : "hash"] : n.map;
    };
    var v = function (t) {
      var e = w(this, t).delete(t);
      return (this.size -= e ? 1 : 0), e;
    };
    var _ = function (t) {
      return w(this, t).get(t);
    };
    var y = function (t) {
      return w(this, t).has(t);
    };
    var k = function (t, e) {
      var n = w(this, t),
        i = n.size;
      return n.set(t, e), (this.size += n.size == i ? 0 : 1), this;
    };
    function A(t) {
      var e = -1,
        n = null == t ? 0 : t.length;
      for (this.clear(); ++e < n; ) {
        var i = t[e];
        this.set(i[0], i[1]);
      }
    }
    (A.prototype.clear = p),
      (A.prototype.delete = v),
      (A.prototype.get = _),
      (A.prototype.has = y),
      (A.prototype.set = k);
    e.a = A;
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    }),
      n.d(e, "b", function () {
        return r;
      }),
      n.d(e, "c", function () {
        return c;
      });
    var i = n(83);
    var s = n(12);
    function o(t) {
      if (0 == t.length) return !1;
      for (const e of t) if ("children" === e.type && !r(e)) return !0;
      return !1;
    }
    function r(t) {
      if (t.newChildren.length - t.oldChildren.length != 1) return;
      const e = (function (t, e) {
        const n = [];
        let i,
          s = 0;
        return (
          t.forEach((t) => {
            "equal" == t
              ? (o(), s++)
              : "insert" == t
              ? (r("insert")
                  ? i.values.push(e[s])
                  : (o(), (i = { type: "insert", index: s, values: [e[s]] })),
                s++)
              : r("delete")
              ? i.howMany++
              : (o(), (i = { type: "delete", index: s, howMany: 1 }));
          }),
          o(),
          n
        );
        function o() {
          i && (n.push(i), (i = null));
        }
        function r(t) {
          return i && i.type == t;
        }
      })(Object(i.a)(t.oldChildren, t.newChildren, a), t.newChildren);
      if (e.length > 1) return;
      const n = e[0];
      return n.values[0] && n.values[0].is("$text") ? n : void 0;
    }
    function a(t, e) {
      return t && t.is("$text") && e && e.is("$text")
        ? t.data === e.data
        : t === e;
    }
    function c(t, e) {
      const n = e.selection,
        i = t.shiftKey && t.keyCode === s.f.delete,
        o = !n.isCollapsed;
      return i && o;
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(50),
      s = n(0);
    class o extends i.a {
      constructor(t, e, n, i) {
        super(t, e, n, i),
          (this.getFillerOffset = r),
          (this._priority = 10),
          (this._id = null),
          (this._clonesGroup = null);
      }
      get priority() {
        return this._priority;
      }
      get id() {
        return this._id;
      }
      getElementsWithSameId() {
        if (null === this.id)
          throw new s.default(
            "attribute-element-get-elements-with-same-id-no-id",
            this
          );
        return new Set(this._clonesGroup);
      }
      is(t, e = null) {
        return e
          ? e === this.name &&
              ("attributeElement" === t ||
                "view:attributeElement" === t ||
                "element" === t ||
                "view:element" === t)
          : "attributeElement" === t ||
              "view:attributeElement" === t ||
              "element" === t ||
              "view:element" === t ||
              "node" === t ||
              "view:node" === t;
      }
      isSimilar(t) {
        return null !== this.id || null !== t.id
          ? this.id === t.id
          : super.isSimilar(t) && this.priority == t.priority;
      }
      _clone(t) {
        const e = super._clone(t);
        return (e._priority = this._priority), (e._id = this._id), e;
      }
    }
    function r() {
      if (a(this)) return null;
      let t = this.parent;
      for (; t && t.is("attributeElement"); ) {
        if (a(t) > 1) return null;
        t = t.parent;
      }
      return !t || a(t) > 1 ? null : this.childCount;
    }
    function a(t) {
      return Array.from(t.getChildren()).filter((t) => !t.is("uiElement"))
        .length;
    }
    o.DEFAULT_PRIORITY = 10;
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return f;
    });
    var i = n(9),
      s = n(82),
      o = n(8),
      r = n(34),
      a = n(0),
      c = n(52),
      l = n(68),
      u = n(18),
      d = n(257);
    n(347), n(348);
    const h = Object(l.a)("px");
    class f extends i.a {
      static get pluginName() {
        return "ContextualBalloon";
      }
      constructor(t) {
        super(t),
          (this.positionLimiter = () => {
            const t = this.editor.editing.view,
              e = t.document.selection.editableElement;
            return e ? t.domConverter.mapViewToDom(e.root) : null;
          }),
          this.set("visibleView", null),
          (this.view = new s.a(t.locale)),
          t.ui.view.body.add(this.view),
          t.ui.focusTracker.add(this.view.element),
          (this._viewToStack = new Map()),
          (this._idToStack = new Map()),
          this.set("_numberOfStacks", 0),
          this.set("_singleViewMode", !1),
          (this._rotatorView = this._createRotatorView()),
          (this._fakePanelsView = this._createFakePanelsView());
      }
      destroy() {
        super.destroy(),
          this.view.destroy(),
          this._rotatorView.destroy(),
          this._fakePanelsView.destroy();
      }
      hasView(t) {
        return Array.from(this._viewToStack.keys()).includes(t);
      }
      add(t) {
        if (this.hasView(t.view))
          throw new a.default("contextualballoon-add-view-exist", [this, t]);
        const e = t.stackId || "main";
        if (!this._idToStack.has(e))
          return (
            this._idToStack.set(e, new Map([[t.view, t]])),
            this._viewToStack.set(t.view, this._idToStack.get(e)),
            (this._numberOfStacks = this._idToStack.size),
            void (
              (this._visibleStack && !t.singleViewMode) ||
              this.showStack(e)
            )
          );
        const n = this._idToStack.get(e);
        t.singleViewMode && this.showStack(e),
          n.set(t.view, t),
          this._viewToStack.set(t.view, n),
          n === this._visibleStack && this._showView(t);
      }
      remove(t) {
        if (!this.hasView(t))
          throw new a.default("contextualballoon-remove-view-not-exist", [
            this,
            t,
          ]);
        const e = this._viewToStack.get(t);
        this._singleViewMode &&
          this.visibleView === t &&
          (this._singleViewMode = !1),
          this.visibleView === t &&
            (1 === e.size
              ? this._idToStack.size > 1
                ? this._showNextStack()
                : (this.view.hide(),
                  (this.visibleView = null),
                  this._rotatorView.hideView())
              : this._showView(Array.from(e.values())[e.size - 2])),
          1 === e.size
            ? (this._idToStack.delete(this._getStackId(e)),
              (this._numberOfStacks = this._idToStack.size))
            : e.delete(t),
          this._viewToStack.delete(t);
      }
      updatePosition(t) {
        t && (this._visibleStack.get(this.visibleView).position = t),
          this.view.pin(this._getBalloonPosition()),
          this._fakePanelsView.updatePosition();
      }
      showStack(t) {
        this.visibleStack = t;
        const e = this._idToStack.get(t);
        if (!e)
          throw new a.default(
            "contextualballoon-showstack-stack-not-exist",
            this
          );
        this._visibleStack !== e &&
          this._showView(Array.from(e.values()).pop());
      }
      get _visibleStack() {
        return this._viewToStack.get(this.visibleView);
      }
      _getStackId(t) {
        return Array.from(this._idToStack.entries()).find((e) => e[1] === t)[0];
      }
      _showNextStack() {
        const t = Array.from(this._idToStack.values());
        let e = t.indexOf(this._visibleStack) + 1;
        t[e] || (e = 0), this.showStack(this._getStackId(t[e]));
      }
      _showPrevStack() {
        const t = Array.from(this._idToStack.values());
        let e = t.indexOf(this._visibleStack) - 1;
        t[e] || (e = t.length - 1), this.showStack(this._getStackId(t[e]));
      }
      _createRotatorView() {
        const t = new m(this.editor.locale),
          e = this.editor.locale.t;
        return (
          this.view.content.add(t),
          t
            .bind("isNavigationVisible")
            .to(
              this,
              "_numberOfStacks",
              this,
              "_singleViewMode",
              (t, e) => !e && t > 1
            ),
          t.on("change:isNavigationVisible", () => this.updatePosition(), {
            priority: "low",
          }),
          t
            .bind("counter")
            .to(this, "visibleView", this, "_numberOfStacks", (t, n) => {
              if (n < 2) return "";
              const i =
                Array.from(this._idToStack.values()).indexOf(
                  this._visibleStack
                ) + 1;
              return e("%0 of %1", [i, n]);
            }),
          t.buttonNextView.on("execute", () => {
            t.focusTracker.isFocused && this.editor.editing.view.focus(),
              this._showNextStack();
          }),
          t.buttonPrevView.on("execute", () => {
            t.focusTracker.isFocused && this.editor.editing.view.focus(),
              this._showPrevStack();
          }),
          t
        );
      }
      _createFakePanelsView() {
        const t = new g(this.editor.locale, this.view);
        return (
          t
            .bind("numberOfPanels")
            .to(this, "_numberOfStacks", this, "_singleViewMode", (t, e) =>
              !e && t >= 2 ? Math.min(t - 1, 2) : 0
            ),
          t.listenTo(this.view, "change:top", () => t.updatePosition()),
          t.listenTo(this.view, "change:left", () => t.updatePosition()),
          this.editor.ui.view.body.add(t),
          t
        );
      }
      _showView({
        view: t,
        balloonClassName: e = "",
        withArrow: n = !0,
        singleViewMode: i = !1,
      }) {
        (this.view.class = e),
          (this.view.withArrow = n),
          this._rotatorView.showView(t),
          (this.visibleView = t),
          this.view.pin(this._getBalloonPosition()),
          this._fakePanelsView.updatePosition(),
          i && (this._singleViewMode = !0);
      }
      _getBalloonPosition() {
        let t = Array.from(this._visibleStack.values()).pop().position;
        return (
          t &&
            (t.limiter ||
              (t = Object.assign({}, t, { limiter: this.positionLimiter })),
            (t = Object.assign({}, t, {
              viewportOffsetConfig: this.editor.ui.viewportOffset,
            }))),
          t
        );
      }
    }
    class m extends o.a {
      constructor(t) {
        super(t);
        const e = t.t,
          n = this.bindTemplate;
        this.set("isNavigationVisible", !0),
          (this.focusTracker = new c.a()),
          (this.buttonPrevView = this._createButtonView(e("Previous"), d.a)),
          (this.buttonNextView = this._createButtonView(
            e("Next"),
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'
          )),
          (this.content = this.createCollection()),
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck", "ck-balloon-rotator"],
              "z-index": "-1",
            },
            children: [
              {
                tag: "div",
                attributes: {
                  class: [
                    "ck-balloon-rotator__navigation",
                    n.to("isNavigationVisible", (t) => (t ? "" : "ck-hidden")),
                  ],
                },
                children: [
                  this.buttonPrevView,
                  {
                    tag: "span",
                    attributes: { class: ["ck-balloon-rotator__counter"] },
                    children: [{ text: n.to("counter") }],
                  },
                  this.buttonNextView,
                ],
              },
              {
                tag: "div",
                attributes: { class: "ck-balloon-rotator__content" },
                children: this.content,
              },
            ],
          });
      }
      render() {
        super.render(), this.focusTracker.add(this.element);
      }
      destroy() {
        super.destroy(), this.focusTracker.destroy();
      }
      showView(t) {
        this.hideView(), this.content.add(t);
      }
      hideView() {
        this.content.clear();
      }
      _createButtonView(t, e) {
        const n = new r.a(this.locale);
        return n.set({ label: t, icon: e, tooltip: !0 }), n;
      }
    }
    class g extends o.a {
      constructor(t, e) {
        super(t);
        const n = this.bindTemplate;
        this.set("top", 0),
          this.set("left", 0),
          this.set("height", 0),
          this.set("width", 0),
          this.set("numberOfPanels", 0),
          (this.content = this.createCollection()),
          (this._balloonPanelView = e),
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck-fake-panel",
                n.to("numberOfPanels", (t) => (t ? "" : "ck-hidden")),
              ],
              style: {
                top: n.to("top", h),
                left: n.to("left", h),
                width: n.to("width", h),
                height: n.to("height", h),
              },
            },
            children: this.content,
          }),
          this.on("change:numberOfPanels", (t, e, n, i) => {
            n > i ? this._addPanels(n - i) : this._removePanels(i - n),
              this.updatePosition();
          });
      }
      _addPanels(t) {
        for (; t--; ) {
          const t = new o.a();
          t.setTemplate({ tag: "div" }),
            this.content.add(t),
            this.registerChild(t);
        }
      }
      _removePanels(t) {
        for (; t--; ) {
          const t = this.content.last;
          this.content.remove(t), this.deregisterChild(t), t.destroy();
        }
      }
      updatePosition() {
        if (this.numberOfPanels) {
          const { top: t, left: e } = this._balloonPanelView,
            { width: n, height: i } = new u.a(this._balloonPanelView.element);
          Object.assign(this, { top: t, left: e, width: n, height: i });
        }
      }
    }
  },
  function (t, e, n) {
    "use strict";
    e.a = function (t) {
      return function (e) {
        return t(e);
      };
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(14),
      s = n(6);
    class o {
      constructor(t) {
        this.context = t;
      }
      destroy() {
        this.stopListening();
      }
      static get isContextPlugin() {
        return !0;
      }
    }
    Object(s.default)(o, i.default);
  },
  function (t, e, n) {
    "use strict";
    function i({ emitter: t, activator: e, callback: n, contextElements: i }) {
      t.listenTo(document, "mousedown", (t, s) => {
        if (!e()) return;
        const o = "function" == typeof s.composedPath ? s.composedPath() : [];
        for (const t of i) if (t.contains(s.target) || o.includes(t)) return;
        n();
      });
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "b", function () {
      return d;
    }),
      n.d(e, "a", function () {
        return h;
      });
    var i = n(30),
      s = n(388),
      o = n(216);
    var r = function (t, e, n) {
        var i = null == t ? void 0 : Object(o.a)(t, e);
        return void 0 === i ? n : i;
      },
      a = n(276),
      c = n(184),
      l = Object(c.a)(function (t, e, n) {
        Object(a.a)(t, e, n);
      }),
      u = n(389);
    class d {
      constructor(t) {
        (this._styles = {}), (this._styleProcessor = t);
      }
      get isEmpty() {
        const t = Object.entries(this._styles);
        return !Array.from(t).length;
      }
      get size() {
        return this.isEmpty ? 0 : this.getStyleNames().length;
      }
      setTo(t) {
        this.clear();
        const e = Array.from(
          (function (t) {
            let e = null,
              n = 0,
              i = 0,
              s = null;
            const o = new Map();
            if ("" === t) return o;
            ";" != t.charAt(t.length - 1) && (t += ";");
            for (let r = 0; r < t.length; r++) {
              const a = t.charAt(r);
              if (null === e)
                switch (a) {
                  case ":":
                    s || ((s = t.substr(n, r - n)), (i = r + 1));
                    break;
                  case '"':
                  case "'":
                    e = a;
                    break;
                  case ";": {
                    const e = t.substr(i, r - i);
                    s && o.set(s.trim(), e.trim()), (s = null), (n = r + 1);
                    break;
                  }
                }
              else a === e && (e = null);
            }
            return o;
          })(t).entries()
        );
        for (const [t, n] of e)
          this._styleProcessor.toNormalizedForm(t, n, this._styles);
      }
      has(t) {
        if (this.isEmpty) return !1;
        const e = this._styleProcessor
          .getReducedForm(t, this._styles)
          .find(([e]) => e === t);
        return Array.isArray(e);
      }
      set(t, e) {
        if (Object(i.a)(t))
          for (const [e, n] of Object.entries(t))
            this._styleProcessor.toNormalizedForm(e, n, this._styles);
        else this._styleProcessor.toNormalizedForm(t, e, this._styles);
      }
      remove(t) {
        const e = f(t);
        Object(s.a)(this._styles, e),
          delete this._styles[t],
          this._cleanEmptyObjectsOnPath(e);
      }
      getNormalized(t) {
        return this._styleProcessor.getNormalized(t, this._styles);
      }
      toString() {
        return this.isEmpty
          ? ""
          : this._getStylesEntries()
              .map((t) => t.join(":"))
              .sort()
              .join(";") + ";";
      }
      getAsString(t) {
        if (this.isEmpty) return;
        if (this._styles[t] && !Object(i.a)(this._styles[t]))
          return this._styles[t];
        const e = this._styleProcessor
          .getReducedForm(t, this._styles)
          .find(([e]) => e === t);
        return Array.isArray(e) ? e[1] : void 0;
      }
      getStyleNames(t = !1) {
        if (this.isEmpty) return [];
        if (t) return this._styleProcessor.getStyleNames(this._styles);
        return this._getStylesEntries().map(([t]) => t);
      }
      clear() {
        this._styles = {};
      }
      _getStylesEntries() {
        const t = [],
          e = Object.keys(this._styles);
        for (const n of e)
          t.push(...this._styleProcessor.getReducedForm(n, this._styles));
        return t;
      }
      _cleanEmptyObjectsOnPath(t) {
        const e = t.split(".");
        if (!(e.length > 1)) return;
        const n = e.splice(0, e.length - 1).join("."),
          i = r(this._styles, n);
        if (!i) return;
        !Array.from(Object.keys(i)).length && this.remove(n);
      }
    }
    class h {
      constructor() {
        (this._normalizers = new Map()),
          (this._extractors = new Map()),
          (this._reducers = new Map()),
          (this._consumables = new Map());
      }
      toNormalizedForm(t, e, n) {
        if (Object(i.a)(e)) m(n, f(t), e);
        else if (this._normalizers.has(t)) {
          const i = this._normalizers.get(t),
            { path: s, value: o } = i(e);
          m(n, s, o);
        } else m(n, t, e);
      }
      getNormalized(t, e) {
        if (!t) return l({}, e);
        if (void 0 !== e[t]) return e[t];
        if (this._extractors.has(t)) {
          const n = this._extractors.get(t);
          if ("string" == typeof n) return r(e, n);
          const i = n(t, e);
          if (i) return i;
        }
        return r(e, f(t));
      }
      getReducedForm(t, e) {
        const n = this.getNormalized(t, e);
        if (void 0 === n) return [];
        if (this._reducers.has(t)) {
          return this._reducers.get(t)(n);
        }
        return [[t, n]];
      }
      getStyleNames(t) {
        const e = Array.from(this._consumables.keys()).filter((e) => {
            const n = this.getNormalized(e, t);
            return n && "object" == typeof n ? Object.keys(n).length : n;
          }),
          n = new Set([...e, ...Object.keys(t)]);
        return Array.from(n.values());
      }
      getRelatedStyles(t) {
        return this._consumables.get(t) || [];
      }
      setNormalizer(t, e) {
        this._normalizers.set(t, e);
      }
      setExtractor(t, e) {
        this._extractors.set(t, e);
      }
      setReducer(t, e) {
        this._reducers.set(t, e);
      }
      setStyleRelation(t, e) {
        this._mapStyleNames(t, e);
        for (const n of e) this._mapStyleNames(n, [t]);
      }
      _mapStyleNames(t, e) {
        this._consumables.has(t) || this._consumables.set(t, []),
          this._consumables.get(t).push(...e);
      }
    }
    function f(t) {
      return t.replace("-", ".");
    }
    function m(t, e, n) {
      let s = n;
      Object(i.a)(n) && (s = l({}, r(t, e), n)), Object(u.a)(t, e, s);
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return y;
    });
    var i = n(7),
      s = n(15),
      o = n(62),
      r = n(118),
      a = n(138),
      c = n(50),
      l = n(0),
      u = n(79);
    class d extends c.a {
      constructor(t, e, n, i) {
        super(t, e, n, i),
          (this._isAllowedInsideAttributeElement = !0),
          (this.getFillerOffset = h);
      }
      is(t, e = null) {
        return e
          ? e === this.name &&
              ("emptyElement" === t ||
                "view:emptyElement" === t ||
                "element" === t ||
                "view:element" === t)
          : "emptyElement" === t ||
              "view:emptyElement" === t ||
              "element" === t ||
              "view:element" === t ||
              "node" === t ||
              "view:node" === t;
      }
      _insertChild(t, e) {
        if (e && (e instanceof u.a || Array.from(e).length > 0))
          throw new l.default("view-emptyelement-cannot-add", [this, e]);
      }
    }
    function h() {
      return null;
    }
    var f = n(134);
    class m extends c.a {
      constructor(t, e, n, i) {
        super(t, e, n, i),
          (this._isAllowedInsideAttributeElement = !0),
          (this.getFillerOffset = g);
      }
      is(t, e = null) {
        return e
          ? e === this.name &&
              ("rawElement" === t ||
                "view:rawElement" === t ||
                "element" === t ||
                "view:element" === t)
          : "rawElement" === t ||
              "view:rawElement" === t ||
              t === this.name ||
              t === "view:" + this.name ||
              "element" === t ||
              "view:element" === t ||
              "node" === t ||
              "view:node" === t;
      }
      _insertChild(t, e) {
        if (e && (e instanceof u.a || Array.from(e).length > 0))
          throw new l.default("view-rawelement-cannot-add", [this, e]);
      }
    }
    function g() {
      return null;
    }
    var p = n(86),
      b = n(39),
      w = n(25),
      v = n(152),
      _ = n(76);
    class y {
      constructor(t) {
        (this.document = t), (this._cloneGroups = new Map());
      }
      setSelection(t, e, n) {
        this.document.selection._setTo(t, e, n);
      }
      setSelectionFocus(t, e) {
        this.document.selection._setFocus(t, e);
      }
      createDocumentFragment(t) {
        return new p.a(this.document, t);
      }
      createText(t) {
        return new w.a(this.document, t);
      }
      createAttributeElement(t, e, n = {}) {
        const i = new a.a(this.document, t, e);
        return (
          "number" == typeof n.priority && (i._priority = n.priority),
          n.id && (i._id = n.id),
          n.renderUnsafeAttributes &&
            i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes),
          i
        );
      }
      createContainerElement(t, e, n = {}) {
        const i = new r.a(this.document, t, e);
        return (
          void 0 !== n.isAllowedInsideAttributeElement &&
            (i._isAllowedInsideAttributeElement =
              n.isAllowedInsideAttributeElement),
          n.renderUnsafeAttributes &&
            i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes),
          i
        );
      }
      createEditableElement(t, e, n = {}) {
        const i = new v.a(this.document, t, e);
        return (
          (i._document = this.document),
          n.renderUnsafeAttributes &&
            i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes),
          i
        );
      }
      createEmptyElement(t, e, n = {}) {
        const i = new d(this.document, t, e);
        return (
          void 0 !== n.isAllowedInsideAttributeElement &&
            (i._isAllowedInsideAttributeElement =
              n.isAllowedInsideAttributeElement),
          n.renderUnsafeAttributes &&
            i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes),
          i
        );
      }
      createUIElement(t, e, n, i = {}) {
        const s = new f.a(this.document, t, e);
        return (
          n && (s.render = n),
          void 0 !== i.isAllowedInsideAttributeElement &&
            (s._isAllowedInsideAttributeElement =
              i.isAllowedInsideAttributeElement),
          s
        );
      }
      createRawElement(t, e, n, i = {}) {
        const s = new m(this.document, t, e);
        return (
          (s.render = n || (() => {})),
          void 0 !== i.isAllowedInsideAttributeElement &&
            (s._isAllowedInsideAttributeElement =
              i.isAllowedInsideAttributeElement),
          i.renderUnsafeAttributes &&
            s._unsafeAttributesToRender.push(...i.renderUnsafeAttributes),
          s
        );
      }
      setAttribute(t, e, n) {
        n._setAttribute(t, e);
      }
      removeAttribute(t, e) {
        e._removeAttribute(t);
      }
      addClass(t, e) {
        e._addClass(t);
      }
      removeClass(t, e) {
        e._removeClass(t);
      }
      setStyle(t, e, n) {
        Object(_.a)(t) && void 0 === n && (n = e), n._setStyle(t, e);
      }
      removeStyle(t, e) {
        e._removeStyle(t);
      }
      setCustomProperty(t, e, n) {
        n._setCustomProperty(t, e);
      }
      removeCustomProperty(t, e) {
        return e._removeCustomProperty(t);
      }
      breakAttributes(t) {
        return t instanceof i.a
          ? this._breakAttributes(t)
          : this._breakAttributesRange(t);
      }
      breakContainer(t) {
        const e = t.parent;
        if (!e.is("containerElement"))
          throw new l.default(
            "view-writer-break-non-container-element",
            this.document
          );
        if (!e.parent)
          throw new l.default("view-writer-break-root", this.document);
        if (t.isAtStart) return i.a._createBefore(e);
        if (!t.isAtEnd) {
          const n = e._clone(!1);
          this.insert(i.a._createAfter(e), n);
          const o = new s.a(t, i.a._createAt(e, "end")),
            r = new i.a(n, 0);
          this.move(o, r);
        }
        return i.a._createAfter(e);
      }
      mergeAttributes(t) {
        const e = t.offset,
          n = t.parent;
        if (n.is("$text")) return t;
        if (n.is("attributeElement") && 0 === n.childCount) {
          const t = n.parent,
            e = n.index;
          return (
            n._remove(),
            this._removeFromClonedElementsGroup(n),
            this.mergeAttributes(new i.a(t, e))
          );
        }
        const s = n.getChild(e - 1),
          o = n.getChild(e);
        if (!s || !o) return t;
        if (s.is("$text") && o.is("$text")) return O(s, o);
        if (
          s.is("attributeElement") &&
          o.is("attributeElement") &&
          s.isSimilar(o)
        ) {
          const t = s.childCount;
          return (
            s._appendChild(o.getChildren()),
            o._remove(),
            this._removeFromClonedElementsGroup(o),
            this.mergeAttributes(new i.a(s, t))
          );
        }
        return t;
      }
      mergeContainers(t) {
        const e = t.nodeBefore,
          n = t.nodeAfter;
        if (!(e && n && e.is("containerElement") && n.is("containerElement")))
          throw new l.default(
            "view-writer-merge-containers-invalid-position",
            this.document
          );
        const o = e.getChild(e.childCount - 1),
          r =
            o instanceof w.a
              ? i.a._createAt(o, "end")
              : i.a._createAt(e, "end");
        return (
          this.move(s.a._createIn(n), i.a._createAt(e, "end")),
          this.remove(s.a._createOn(n)),
          r
        );
      }
      insert(t, e) {
        (function t(e, n) {
          for (const i of e) {
            if (!P.some((t) => i instanceof t))
              throw new l.default("view-writer-insert-invalid-node-type", n);
            i.is("$text") || t(i.getChildren(), n);
          }
        })((e = Object(b.a)(e) ? [...e] : [e]), this.document);
        const n = e.reduce((t, e) => {
          const n = t[t.length - 1],
            i = !(e.is("uiElement") && e.isAllowedInsideAttributeElement);
          return (
            n && n.breakAttributes == i
              ? n.nodes.push(e)
              : t.push({ breakAttributes: i, nodes: [e] }),
            t
          );
        }, []);
        let i = null,
          o = t;
        for (const { nodes: t, breakAttributes: e } of n) {
          const n = this._insertNodes(o, t, e);
          i || (i = n.start), (o = n.end);
        }
        return i ? new s.a(i, o) : new s.a(t);
      }
      remove(t) {
        const e = t instanceof s.a ? t : s.a._createOn(t);
        if ((x(e, this.document), e.isCollapsed)) return new p.a(this.document);
        const { start: n, end: i } = this._breakAttributesRange(e, !0),
          o = n.parent,
          r = i.offset - n.offset,
          a = o._removeChildren(n.offset, r);
        for (const t of a) this._removeFromClonedElementsGroup(t);
        const c = this.mergeAttributes(n);
        return (e.start = c), (e.end = c.clone()), new p.a(this.document, a);
      }
      clear(t, e) {
        x(t, this.document);
        const n = t.getWalker({ direction: "backward", ignoreElementEnd: !0 });
        for (const i of n) {
          const n = i.item;
          let o;
          if (n.is("element") && e.isSimilar(n)) o = s.a._createOn(n);
          else if (!i.nextPosition.isAfter(t.start) && n.is("$textProxy")) {
            const t = n
              .getAncestors()
              .find((t) => t.is("element") && e.isSimilar(t));
            t && (o = s.a._createIn(t));
          }
          o &&
            (o.end.isAfter(t.end) && (o.end = t.end),
            o.start.isBefore(t.start) && (o.start = t.start),
            this.remove(o));
        }
      }
      move(t, e) {
        let n;
        if (e.isAfter(t.end)) {
          const i = (e = this._breakAttributes(e, !0)).parent,
            s = i.childCount;
          (t = this._breakAttributesRange(t, !0)),
            (n = this.remove(t)),
            (e.offset += i.childCount - s);
        } else n = this.remove(t);
        return this.insert(e, n);
      }
      wrap(t, e) {
        if (!(e instanceof a.a))
          throw new l.default(
            "view-writer-wrap-invalid-attribute",
            this.document
          );
        if ((x(t, this.document), t.isCollapsed)) {
          let i = t.start;
          i.parent.is("element") &&
            ((n = i.parent),
            !Array.from(n.getChildren()).some((t) => !t.is("uiElement"))) &&
            (i = i.getLastMatchingPosition((t) => t.item.is("uiElement"))),
            (i = this._wrapPosition(i, e));
          const o = this.document.selection;
          return (
            o.isCollapsed &&
              o.getFirstPosition().isEqual(t.start) &&
              this.setSelection(i),
            new s.a(i)
          );
        }
        return this._wrapRange(t, e);
        var n;
      }
      unwrap(t, e) {
        if (!(e instanceof a.a))
          throw new l.default(
            "view-writer-unwrap-invalid-attribute",
            this.document
          );
        if ((x(t, this.document), t.isCollapsed)) return t;
        const { start: n, end: i } = this._breakAttributesRange(t, !0),
          o = n.parent,
          r = this._unwrapChildren(o, n.offset, i.offset, e),
          c = this.mergeAttributes(r.start);
        c.isEqual(r.start) || r.end.offset--;
        const u = this.mergeAttributes(r.end);
        return new s.a(c, u);
      }
      rename(t, e) {
        const n = new r.a(this.document, t, e.getAttributes());
        return (
          this.insert(i.a._createAfter(e), n),
          this.move(s.a._createIn(e), i.a._createAt(n, 0)),
          this.remove(s.a._createOn(e)),
          n
        );
      }
      clearClonedElementsGroup(t) {
        this._cloneGroups.delete(t);
      }
      createPositionAt(t, e) {
        return i.a._createAt(t, e);
      }
      createPositionAfter(t) {
        return i.a._createAfter(t);
      }
      createPositionBefore(t) {
        return i.a._createBefore(t);
      }
      createRange(t, e) {
        return new s.a(t, e);
      }
      createRangeOn(t) {
        return s.a._createOn(t);
      }
      createRangeIn(t) {
        return s.a._createIn(t);
      }
      createSelection(t, e, n) {
        return new o.a(t, e, n);
      }
      _insertNodes(t, e, n) {
        let i, o;
        if (
          ((i = n ? k(t) : t.parent.is("$text") ? t.parent.parent : t.parent),
          !i)
        )
          throw new l.default(
            "view-writer-invalid-position-container",
            this.document
          );
        o = n ? this._breakAttributes(t, !0) : t.parent.is("$text") ? E(t) : t;
        const r = i._insertChild(o.offset, e);
        for (const t of e) this._addToClonedElementsGroup(t);
        const a = o.getShiftedBy(r),
          c = this.mergeAttributes(o);
        c.isEqual(o) || a.offset--;
        const u = this.mergeAttributes(a);
        return new s.a(c, u);
      }
      _wrapChildren(t, e, n, o) {
        let r = e;
        const a = [];
        for (; r < n; ) {
          const e = t.getChild(r),
            n = e.is("$text"),
            s = e.is("attributeElement"),
            c = e.isAllowedInsideAttributeElement;
          if (s && this._wrapAttributeElement(o, e)) a.push(new i.a(t, r));
          else if (n || c || (s && A(o, e))) {
            const n = o._clone();
            e._remove(),
              n._appendChild(e),
              t._insertChild(r, n),
              this._addToClonedElementsGroup(n),
              a.push(new i.a(t, r));
          } else s && this._wrapChildren(e, 0, e.childCount, o);
          r++;
        }
        let c = 0;
        for (const t of a) {
          if (((t.offset -= c), t.offset == e)) continue;
          this.mergeAttributes(t).isEqual(t) || (c++, n--);
        }
        return s.a._createFromParentsAndOffsets(t, e, t, n);
      }
      _unwrapChildren(t, e, n, o) {
        let r = e;
        const a = [];
        for (; r < n; ) {
          const e = t.getChild(r);
          if (e.is("attributeElement"))
            if (e.isSimilar(o)) {
              const s = e.getChildren(),
                o = e.childCount;
              e._remove(),
                t._insertChild(r, s),
                this._removeFromClonedElementsGroup(e),
                a.push(new i.a(t, r), new i.a(t, r + o)),
                (r += o),
                (n += o - 1);
            } else
              this._unwrapAttributeElement(o, e)
                ? (a.push(new i.a(t, r), new i.a(t, r + 1)), r++)
                : (this._unwrapChildren(e, 0, e.childCount, o), r++);
          else r++;
        }
        let c = 0;
        for (const t of a) {
          if (((t.offset -= c), t.offset == e || t.offset == n)) continue;
          this.mergeAttributes(t).isEqual(t) || (c++, n--);
        }
        return s.a._createFromParentsAndOffsets(t, e, t, n);
      }
      _wrapRange(t, e) {
        const { start: n, end: i } = this._breakAttributesRange(t, !0),
          o = n.parent,
          r = this._wrapChildren(o, n.offset, i.offset, e),
          a = this.mergeAttributes(r.start);
        a.isEqual(r.start) || r.end.offset--;
        const c = this.mergeAttributes(r.end);
        return new s.a(a, c);
      }
      _wrapPosition(t, e) {
        if (e.isSimilar(t.parent)) return C(t.clone());
        t.parent.is("$text") && (t = E(t));
        const n = this.createAttributeElement();
        (n._priority = Number.POSITIVE_INFINITY),
          (n.isSimilar = () => !1),
          t.parent._insertChild(t.offset, n);
        const o = new s.a(t, t.getShiftedBy(1));
        this.wrap(o, e);
        const r = new i.a(n.parent, n.index);
        n._remove();
        const a = r.nodeBefore,
          c = r.nodeAfter;
        return a instanceof w.a && c instanceof w.a ? O(a, c) : C(r);
      }
      _wrapAttributeElement(t, e) {
        if (!S(t, e)) return !1;
        if (t.name !== e.name || t.priority !== e.priority) return !1;
        for (const n of t.getAttributeKeys())
          if (
            "class" !== n &&
            "style" !== n &&
            e.hasAttribute(n) &&
            e.getAttribute(n) !== t.getAttribute(n)
          )
            return !1;
        for (const n of t.getStyleNames())
          if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) return !1;
        for (const n of t.getAttributeKeys())
          "class" !== n &&
            "style" !== n &&
            (e.hasAttribute(n) || this.setAttribute(n, t.getAttribute(n), e));
        for (const n of t.getStyleNames())
          e.hasStyle(n) || this.setStyle(n, t.getStyle(n), e);
        for (const n of t.getClassNames()) e.hasClass(n) || this.addClass(n, e);
        return !0;
      }
      _unwrapAttributeElement(t, e) {
        if (!S(t, e)) return !1;
        if (t.name !== e.name || t.priority !== e.priority) return !1;
        for (const n of t.getAttributeKeys())
          if (
            "class" !== n &&
            "style" !== n &&
            (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n))
          )
            return !1;
        if (!e.hasClass(...t.getClassNames())) return !1;
        for (const n of t.getStyleNames())
          if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) return !1;
        for (const n of t.getAttributeKeys())
          "class" !== n && "style" !== n && this.removeAttribute(n, e);
        return (
          this.removeClass(Array.from(t.getClassNames()), e),
          this.removeStyle(Array.from(t.getStyleNames()), e),
          !0
        );
      }
      _breakAttributesRange(t, e = !1) {
        const n = t.start,
          i = t.end;
        if ((x(t, this.document), t.isCollapsed)) {
          const n = this._breakAttributes(t.start, e);
          return new s.a(n, n);
        }
        const o = this._breakAttributes(i, e),
          r = o.parent.childCount,
          a = this._breakAttributes(n, e);
        return (o.offset += o.parent.childCount - r), new s.a(a, o);
      }
      _breakAttributes(t, e = !1) {
        const n = t.offset,
          s = t.parent;
        if (t.parent.is("emptyElement"))
          throw new l.default(
            "view-writer-cannot-break-empty-element",
            this.document
          );
        if (t.parent.is("uiElement"))
          throw new l.default(
            "view-writer-cannot-break-ui-element",
            this.document
          );
        if (t.parent.is("rawElement"))
          throw new l.default(
            "view-writer-cannot-break-raw-element",
            this.document
          );
        if (!e && s.is("$text") && T(s.parent)) return t.clone();
        if (T(s)) return t.clone();
        if (s.is("$text")) return this._breakAttributes(E(t), e);
        if (n == s.childCount) {
          const t = new i.a(s.parent, s.index + 1);
          return this._breakAttributes(t, e);
        }
        if (0 === n) {
          const t = new i.a(s.parent, s.index);
          return this._breakAttributes(t, e);
        }
        {
          const t = s.index + 1,
            o = s._clone();
          s.parent._insertChild(t, o), this._addToClonedElementsGroup(o);
          const r = s.childCount - n,
            a = s._removeChildren(n, r);
          o._appendChild(a);
          const c = new i.a(s.parent, t);
          return this._breakAttributes(c, e);
        }
      }
      _addToClonedElementsGroup(t) {
        if (!t.root.is("rootElement")) return;
        if (t.is("element"))
          for (const e of t.getChildren()) this._addToClonedElementsGroup(e);
        const e = t.id;
        if (!e) return;
        let n = this._cloneGroups.get(e);
        n || ((n = new Set()), this._cloneGroups.set(e, n)),
          n.add(t),
          (t._clonesGroup = n);
      }
      _removeFromClonedElementsGroup(t) {
        if (t.is("element"))
          for (const e of t.getChildren())
            this._removeFromClonedElementsGroup(e);
        const e = t.id;
        if (!e) return;
        const n = this._cloneGroups.get(e);
        n && n.delete(t);
      }
    }
    function k(t) {
      let e = t.parent;
      for (; !T(e); ) {
        if (!e) return;
        e = e.parent;
      }
      return e;
    }
    function A(t, e) {
      return (
        t.priority < e.priority ||
        (!(t.priority > e.priority) && t.getIdentity() < e.getIdentity())
      );
    }
    function C(t) {
      const e = t.nodeBefore;
      if (e && e.is("$text")) return new i.a(e, e.data.length);
      const n = t.nodeAfter;
      return n && n.is("$text") ? new i.a(n, 0) : t;
    }
    function E(t) {
      if (t.offset == t.parent.data.length)
        return new i.a(t.parent.parent, t.parent.index + 1);
      if (0 === t.offset) return new i.a(t.parent.parent, t.parent.index);
      const e = t.parent.data.slice(t.offset);
      return (
        (t.parent._data = t.parent.data.slice(0, t.offset)),
        t.parent.parent._insertChild(
          t.parent.index + 1,
          new w.a(t.root.document, e)
        ),
        new i.a(t.parent.parent, t.parent.index + 1)
      );
    }
    function O(t, e) {
      const n = t.data.length;
      return (t._data += e.data), e._remove(), new i.a(t, n);
    }
    const P = [w.a, a.a, r.a, d, m, f.a];
    function T(t) {
      return t && (t.is("containerElement") || t.is("documentFragment"));
    }
    function x(t, e) {
      const n = k(t.start),
        i = k(t.end);
      if (!n || !i || n !== i)
        throw new l.default("view-writer-invalid-range-container", e);
    }
    function S(t, e) {
      return null === t.id && null === e.id;
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return w;
    });
    var i = n(217),
      s = n(51),
      o = n(6),
      r = n(74),
      a = n(0),
      c = n(11),
      l = n(35),
      u = n(120);
    const d = Symbol("bubbling contexts");
    var h = {
      fire(t, ...e) {
        try {
          const n = t instanceof r.a ? t : new r.a(this, t),
            i = p(this);
          if (!i.size) return;
          if ((f(n, "capturing", this), m(i, "$capture", n, ...e)))
            return n.return;
          const s = n.startRange || this.selection.getFirstRange(),
            o = s ? s.getContainedElement() : null,
            a = !!o && Boolean(g(i, o));
          let c =
            o ||
            (function (t) {
              if (!t) return null;
              const e = t.start.parent,
                n = t.end.parent,
                i = e.getPath(),
                s = n.getPath();
              return i.length > s.length ? e : n;
            })(s);
          if ((f(n, "atTarget", c), !a)) {
            if (m(i, "$text", n, ...e)) return n.return;
            f(n, "bubbling", c);
          }
          for (; c; ) {
            if (c.is("rootElement")) {
              if (m(i, "$root", n, ...e)) return n.return;
            } else if (c.is("element") && m(i, c.name, n, ...e))
              return n.return;
            if (m(i, c, n, ...e)) return n.return;
            (c = c.parent), f(n, "bubbling", c);
          }
          return f(n, "bubbling", this), m(i, "$document", n, ...e), n.return;
        } catch (t) {
          a.default.rethrowUnexpectedError(t, this);
        }
      },
      _addEventListener(t, e, n) {
        const i = Object(l.a)(n.context || "$document"),
          s = p(this);
        for (const o of i) {
          let i = s.get(o);
          i || ((i = Object.create(c.default)), s.set(o, i)),
            this.listenTo(i, t, e, n);
        }
      },
      _removeEventListener(t, e) {
        const n = p(this);
        for (const i of n.values()) this.stopListening(i, t, e);
      },
    };
    function f(t, e, n) {
      t instanceof u.a && ((t._eventPhase = e), (t._currentTarget = n));
    }
    function m(t, e, n, ...i) {
      const s = "string" == typeof e ? t.get(e) : g(t, e);
      return !!s && (s.fire(n, ...i), n.stop.called);
    }
    function g(t, e) {
      for (const [n, i] of t) if ("function" == typeof n && n(e)) return i;
      return null;
    }
    function p(t) {
      return t[d] || (t[d] = new Map()), t[d];
    }
    var b = n(14);
    class w {
      constructor(t) {
        (this.selection = new i.a()),
          (this.roots = new s.default({ idProperty: "rootName" })),
          (this.stylesProcessor = t),
          this.set("isReadOnly", !1),
          this.set("isFocused", !1),
          this.set("isSelecting", !1),
          this.set("isComposing", !1),
          (this._postFixers = new Set());
      }
      getRoot(t = "main") {
        return this.roots.get(t);
      }
      registerPostFixer(t) {
        this._postFixers.add(t);
      }
      destroy() {
        this.roots.map((t) => t.destroy()), this.stopListening();
      }
      _callPostFixers(t) {
        let e = !1;
        do {
          for (const n of this._postFixers) if (((e = n(t)), e)) break;
        } while (e);
      }
    }
    Object(o.default)(w, h), Object(o.default)(w, b.default);
  },
  function (t, e, n) {
    "use strict";
    var i = /^(?:0|[1-9]\d*)$/;
    e.a = function (t, e) {
      var n = typeof t;
      return (
        !!(e = null == e ? 9007199254740991 : e) &&
        ("number" == n || ("symbol" != n && i.test(t))) &&
        t > -1 &&
        t % 1 == 0 &&
        t < e
      );
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(161);
    e.a = function (t, e, n) {
      "__proto__" == e && i.a
        ? Object(i.a)(t, e, {
            configurable: !0,
            enumerable: !0,
            value: n,
            writable: !0,
          })
        : (t[e] = n);
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(147),
      s = n(87),
      o = Object.prototype.hasOwnProperty;
    e.a = function (t, e, n) {
      var r = t[e];
      (o.call(t, e) && Object(s.a)(r, n) && (void 0 !== n || e in t)) ||
        Object(i.a)(t, e, n);
    };
  },
  function (t, e, n) {
    "use strict";
    var i = Object.prototype;
    e.a = function (t) {
      var e = t && t.constructor;
      return t === (("function" == typeof e && e.prototype) || i);
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(209),
      s = Object(i.a)(Object.getPrototypeOf, Object);
    e.a = s;
  },
  function (t, e, n) {
    "use strict";
    var i = n(162);
    e.a = function (t) {
      var e = new t.constructor(t.byteLength);
      return new i.a(e).set(new i.a(t)), e;
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(118),
      s = n(6),
      o = n(14);
    class r extends i.a {
      constructor(t, e, n, i) {
        super(t, e, n, i),
          this.set("isReadOnly", !1),
          this.set("isFocused", !1),
          this.bind("isReadOnly").to(t),
          this.bind("isFocused").to(
            t,
            "isFocused",
            (e) => e && t.selection.editableElement == this
          ),
          this.listenTo(t.selection, "change", () => {
            this.isFocused = t.isFocused && t.selection.editableElement == this;
          });
      }
      is(t, e = null) {
        return e
          ? e === this.name &&
              ("editableElement" === t ||
                "view:editableElement" === t ||
                "containerElement" === t ||
                "view:containerElement" === t ||
                "element" === t ||
                "view:element" === t)
          : "editableElement" === t ||
              "view:editableElement" === t ||
              "containerElement" === t ||
              "view:containerElement" === t ||
              "element" === t ||
              "view:element" === t ||
              "node" === t ||
              "view:node" === t;
      }
      destroy() {
        this.stopListening();
      }
    }
    Object(s.default)(r, o.default);
  },
  function (t, e, n) {
    "use strict";
    var i = n(119);
    e.a = function (t) {
      if ("string" == typeof t || Object(i.a)(t)) return t;
      var e = t + "";
      return "0" == e && 1 / t == -1 / 0 ? "-0" : e;
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(127);
    var s = function (t, e) {
        for (
          var n = -1, i = null == t ? 0 : t.length;
          ++n < i && !1 !== e(t[n], n, t);

        );
        return t;
      },
      o = n(148),
      r = n(78),
      a = n(156);
    var c = function (t, e) {
        return t && Object(r.a)(e, Object(a.a)(e), t);
      },
      l = n(80);
    var u = function (t, e) {
        return t && Object(r.a)(e, Object(l.a)(e), t);
      },
      d = n(210),
      h = n(183),
      f = n(160);
    var m = function (t, e) {
        return Object(r.a)(t, Object(f.a)(t), e);
      },
      g = n(212),
      p = n(150),
      b = n(211),
      w = Object.getOwnPropertySymbols
        ? function (t) {
            for (var e = []; t; )
              Object(g.a)(e, Object(f.a)(t)), (t = Object(p.a)(t));
            return e;
          }
        : b.a;
    var v = function (t, e) {
        return Object(r.a)(t, w(t), e);
      },
      _ = n(171),
      y = n(214);
    var k = function (t) {
        return Object(y.a)(t, l.a, w);
      },
      A = n(103),
      C = Object.prototype.hasOwnProperty;
    var E = function (t) {
        var e = t.length,
          n = new t.constructor(e);
        return (
          e &&
            "string" == typeof t[0] &&
            C.call(t, "index") &&
            ((n.index = t.index), (n.input = t.input)),
          n
        );
      },
      O = n(151);
    var P = function (t, e) {
        var n = e ? Object(O.a)(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.byteLength);
      },
      T = /\w*$/;
    var x = function (t) {
        var e = new t.constructor(t.source, T.exec(t));
        return (e.lastIndex = t.lastIndex), e;
      },
      S = n(64),
      I = S.a ? S.a.prototype : void 0,
      R = I ? I.valueOf : void 0;
    var j = function (t) {
        return R ? Object(R.call(t)) : {};
      },
      M = n(213);
    var V = function (t, e, n) {
        var i = t.constructor;
        switch (e) {
          case "[object ArrayBuffer]":
            return Object(O.a)(t);
          case "[object Boolean]":
          case "[object Date]":
            return new i(+t);
          case "[object DataView]":
            return P(t, n);
          case "[object Float32Array]":
          case "[object Float64Array]":
          case "[object Int8Array]":
          case "[object Int16Array]":
          case "[object Int32Array]":
          case "[object Uint8Array]":
          case "[object Uint8ClampedArray]":
          case "[object Uint16Array]":
          case "[object Uint32Array]":
            return Object(M.a)(t, n);
          case "[object Map]":
            return new i();
          case "[object Number]":
          case "[object String]":
            return new i(t);
          case "[object RegExp]":
            return x(t);
          case "[object Set]":
            return new i();
          case "[object Symbol]":
            return j(t);
        }
      },
      N = n(229),
      B = n(46),
      D = n(102),
      F = n(38);
    var z = function (t) {
        return Object(F.a)(t) && "[object Map]" == Object(A.a)(t);
      },
      L = n(140),
      H = n(104),
      W = H.a && H.a.isMap,
      q = W ? Object(L.a)(W) : z,
      $ = n(30);
    var U = function (t) {
        return Object(F.a)(t) && "[object Set]" == Object(A.a)(t);
      },
      K = H.a && H.a.isSet,
      G = K ? Object(L.a)(K) : U,
      J = {};
    (J["[object Arguments]"] =
      J["[object Array]"] =
      J["[object ArrayBuffer]"] =
      J["[object DataView]"] =
      J["[object Boolean]"] =
      J["[object Date]"] =
      J["[object Float32Array]"] =
      J["[object Float64Array]"] =
      J["[object Int8Array]"] =
      J["[object Int16Array]"] =
      J["[object Int32Array]"] =
      J["[object Map]"] =
      J["[object Number]"] =
      J["[object Object]"] =
      J["[object RegExp]"] =
      J["[object Set]"] =
      J["[object String]"] =
      J["[object Symbol]"] =
      J["[object Uint8Array]"] =
      J["[object Uint8ClampedArray]"] =
      J["[object Uint16Array]"] =
      J["[object Uint32Array]"] =
        !0),
      (J["[object Error]"] =
        J["[object Function]"] =
        J["[object WeakMap]"] =
          !1);
    e.a = function t(e, n, r, f, g, p) {
      var b,
        w = 1 & n,
        y = 2 & n,
        C = 4 & n;
      if ((r && (b = g ? r(e, f, g, p) : r(e)), void 0 !== b)) return b;
      if (!Object($.a)(e)) return e;
      var O = Object(B.a)(e);
      if (O) {
        if (((b = E(e)), !w)) return Object(h.a)(e, b);
      } else {
        var P = Object(A.a)(e),
          T = "[object Function]" == P || "[object GeneratorFunction]" == P;
        if (Object(D.a)(e)) return Object(d.a)(e, w);
        if ("[object Object]" == P || "[object Arguments]" == P || (T && !g)) {
          if (((b = y || T ? {} : Object(N.a)(e)), !w))
            return y ? v(e, u(b, e)) : m(e, c(b, e));
        } else {
          if (!J[P]) return g ? e : {};
          b = V(e, P, w);
        }
      }
      p || (p = new i.a());
      var x = p.get(e);
      if (x) return x;
      p.set(e, b),
        G(e)
          ? e.forEach(function (i) {
              b.add(t(i, n, r, i, e, p));
            })
          : q(e) &&
            e.forEach(function (i, s) {
              b.set(s, t(i, n, r, s, e, p));
            });
      var S = C ? (y ? k : _.a) : y ? l.a : a.a,
        I = O ? void 0 : S(e);
      return (
        s(I || e, function (i, s) {
          I && (i = e[(s = i)]), Object(o.a)(b, s, t(i, n, r, s, e, p));
        }),
        b
      );
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(46),
      s = n(119),
      o = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      r = /^\w*$/;
    var a = function (t, e) {
        if (Object(i.a)(t)) return !1;
        var n = typeof t;
        return (
          !(
            "number" != n &&
            "symbol" != n &&
            "boolean" != n &&
            null != t &&
            !Object(s.a)(t)
          ) ||
          r.test(t) ||
          !o.test(t) ||
          (null != e && t in Object(e))
        );
      },
      c = n(136);
    function l(t, e) {
      if ("function" != typeof t || (null != e && "function" != typeof e))
        throw new TypeError("Expected a function");
      var n = function () {
        var i = arguments,
          s = e ? e.apply(this, i) : i[0],
          o = n.cache;
        if (o.has(s)) return o.get(s);
        var r = t.apply(this, i);
        return (n.cache = o.set(s, r) || o), r;
      };
      return (n.cache = new (l.Cache || c.a)()), n;
    }
    l.Cache = c.a;
    var u = l;
    var d =
        /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
      h = /\\(\\)?/g,
      f = (function (t) {
        var e = u(t, function (t) {
            return 500 === n.size && n.clear(), t;
          }),
          n = e.cache;
        return e;
      })(function (t) {
        var e = [];
        return (
          46 === t.charCodeAt(0) && e.push(""),
          t.replace(d, function (t, n, i, s) {
            e.push(i ? s.replace(h, "$1") : n || t);
          }),
          e
        );
      }),
      m = n(166);
    e.a = function (t, e) {
      return Object(i.a)(t) ? t : a(t, e) ? [t] : f(Object(m.a)(t));
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(228),
      s = n(149),
      o = n(209),
      r = Object(o.a)(Object.keys, Object),
      a = Object.prototype.hasOwnProperty;
    var c = function (t) {
        if (!Object(s.a)(t)) return r(t);
        var e = [];
        for (var n in Object(t))
          a.call(t, n) && "constructor" != n && e.push(n);
        return e;
      },
      l = n(117);
    e.a = function (t) {
      return Object(l.a)(t) ? Object(i.a)(t) : c(t);
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(27),
      s = n(18);
    var o = n(219),
      r = n(123);
    function a({
      element: t,
      target: e,
      positions: n,
      limiter: o,
      fitInViewport: a,
      viewportOffsetConfig: c,
    }) {
      Object(r.a)(e) && (e = e()), Object(r.a)(o) && (o = o());
      const u = (function (t) {
          return t && t.parentNode
            ? t.offsetParent === i.a.document.body
              ? null
              : t.offsetParent
            : null;
        })(t),
        d = new s.a(t);
      let h;
      const f = {
        targetRect: new s.a(e),
        elementRect: d,
        positionedElementAncestor: u,
      };
      if (o || a) {
        const t = o && new s.a(o).getVisible(),
          e =
            a &&
            (function (t) {
              t = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, t);
              const e = new s.a(i.a.window);
              return (
                (e.top += t.top),
                (e.height -= t.top),
                (e.bottom -= t.bottom),
                (e.height -= t.bottom),
                e
              );
            })(c);
        Object.assign(f, { limiterRect: t, viewportRect: e }),
          (h =
            (function (t, e) {
              const { elementRect: n } = e,
                i = n.getArea(),
                s = t.map((t) => new l(t, e)).filter((t) => !!t.name);
              let o = 0,
                r = null;
              for (const t of s) {
                const {
                  _limiterIntersectionArea: e,
                  _viewportIntersectionArea: n,
                } = t;
                if (e === i) return t;
                const s = n ** 2 + e ** 2;
                s > o && ((o = s), (r = t));
              }
              return r;
            })(n, f) || new l(n[0], f));
      } else h = new l(n[0], f);
      return h;
    }
    function c(t) {
      const { scrollX: e, scrollY: n } = i.a.window;
      return t.clone().moveBy(e, n);
    }
    class l {
      constructor(t, e) {
        const n = t(e.targetRect, e.elementRect, e.viewportRect);
        if (!n) return;
        const { left: i, top: s, name: o, config: r } = n;
        Object.assign(this, { name: o, config: r }),
          (this._positioningFunctionCorrdinates = { left: i, top: s }),
          (this._options = e);
      }
      get left() {
        return this._absoluteRect.left;
      }
      get top() {
        return this._absoluteRect.top;
      }
      get _limiterIntersectionArea() {
        const t = this._options.limiterRect;
        if (t) {
          const e = this._options.viewportRect;
          if (!e) return t.getIntersectionArea(this._rect);
          {
            const n = t.getIntersection(e);
            if (n) return n.getIntersectionArea(this._rect);
          }
        }
        return 0;
      }
      get _viewportIntersectionArea() {
        const t = this._options.viewportRect;
        return t ? t.getIntersectionArea(this._rect) : 0;
      }
      get _rect() {
        return (
          this._cachedRect ||
            (this._cachedRect = this._options.elementRect
              .clone()
              .moveTo(
                this._positioningFunctionCorrdinates.left,
                this._positioningFunctionCorrdinates.top
              )),
          this._cachedRect
        );
      }
      get _absoluteRect() {
        return (
          this._cachedAbsoluteRect ||
            ((this._cachedAbsoluteRect = c(this._rect)),
            this._options.positionedElementAncestor &&
              (function (t, e) {
                const n = c(new s.a(e)),
                  i = Object(o.a)(e);
                let r = 0,
                  a = 0;
                (r -= n.left),
                  (a -= n.top),
                  (r += e.scrollLeft),
                  (a += e.scrollTop),
                  (r -= i.left),
                  (a -= i.top),
                  t.moveBy(r, a);
              })(
                this._cachedAbsoluteRect,
                this._options.positionedElementAncestor
              )),
          this._cachedAbsoluteRect
        );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(63),
      s = n(207),
      o = n(38),
      r = {};
    (r["[object Float32Array]"] =
      r["[object Float64Array]"] =
      r["[object Int8Array]"] =
      r["[object Int16Array]"] =
      r["[object Int32Array]"] =
      r["[object Uint8Array]"] =
      r["[object Uint8ClampedArray]"] =
      r["[object Uint16Array]"] =
      r["[object Uint32Array]"] =
        !0),
      (r["[object Arguments]"] =
        r["[object Array]"] =
        r["[object ArrayBuffer]"] =
        r["[object Boolean]"] =
        r["[object DataView]"] =
        r["[object Date]"] =
        r["[object Error]"] =
        r["[object Function]"] =
        r["[object Map]"] =
        r["[object Number]"] =
        r["[object Object]"] =
        r["[object RegExp]"] =
        r["[object Set]"] =
        r["[object String]"] =
        r["[object WeakMap]"] =
          !1);
    var a = function (t) {
        return Object(o.a)(t) && Object(s.a)(t.length) && !!r[Object(i.a)(t)];
      },
      c = n(140),
      l = n(104),
      u = l.a && l.a.isTypedArray,
      d = u ? Object(c.a)(u) : a;
    e.a = d;
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(59),
      s = n(74);
    class o {
      constructor(t) {
        (this.files = (function (t) {
          const e = Array.from(t.files || []),
            n = Array.from(t.items || []);
          if (e.length) return e;
          return n.filter((t) => "file" === t.kind).map((t) => t.getAsFile());
        })(t)),
          (this._native = t);
      }
      get types() {
        return this._native.types;
      }
      getData(t) {
        return this._native.getData(t);
      }
      setData(t, e) {
        this._native.setData(t, e);
      }
      set effectAllowed(t) {
        this._native.effectAllowed = t;
      }
      get effectAllowed() {
        return this._native.effectAllowed;
      }
      set dropEffect(t) {
        this._native.dropEffect = t;
      }
      get dropEffect() {
        return this._native.dropEffect;
      }
      get isCanceled() {
        return (
          "none" == this._native.dropEffect || !!this._native.mozUserCancelled
        );
      }
    }
    class r extends i.a {
      constructor(t) {
        super(t);
        const e = this.document;
        function n(t) {
          return (n, i) => {
            i.preventDefault();
            const o = i.dropRange ? [i.dropRange] : null,
              r = new s.a(e, t);
            e.fire(r, {
              dataTransfer: i.dataTransfer,
              method: n.name,
              targetRanges: o,
              target: i.target,
            }),
              r.stop.called && i.stopPropagation();
          };
        }
        (this.domEventType = [
          "paste",
          "copy",
          "cut",
          "drop",
          "dragover",
          "dragstart",
          "dragend",
          "dragenter",
          "dragleave",
        ]),
          this.listenTo(e, "paste", n("clipboardInput"), { priority: "low" }),
          this.listenTo(e, "drop", n("clipboardInput"), { priority: "low" }),
          this.listenTo(e, "dragover", n("dragging"), { priority: "low" });
      }
      onDomEvent(t) {
        const e = {
          dataTransfer: new o(
            t.clipboardData ? t.clipboardData : t.dataTransfer
          ),
        };
        ("drop" != t.type && "dragover" != t.type) ||
          (e.dropRange = (function (t, e) {
            const n = e.target.ownerDocument,
              i = e.clientX,
              s = e.clientY;
            let o;
            n.caretRangeFromPoint && n.caretRangeFromPoint(i, s)
              ? (o = n.caretRangeFromPoint(i, s))
              : e.rangeParent &&
                ((o = n.createRange()),
                o.setStart(e.rangeParent, e.rangeOffset),
                o.collapse(!0));
            if (o) return t.domConverter.domRangeToView(o);
            return null;
          })(this.view, t)),
          this.fire(t.type, t, e);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    var i = function (t, e) {
        for (
          var n = -1, i = null == t ? 0 : t.length, s = 0, o = [];
          ++n < i;

        ) {
          var r = t[n];
          e(r, n, t) && (o[s++] = r);
        }
        return o;
      },
      s = n(211),
      o = Object.prototype.propertyIsEnumerable,
      r = Object.getOwnPropertySymbols,
      a = r
        ? function (t) {
            return null == t
              ? []
              : ((t = Object(t)),
                i(r(t), function (e) {
                  return o.call(t, e);
                }));
          }
        : s.a;
    e.a = a;
  },
  function (t, e, n) {
    "use strict";
    var i = n(70),
      s = (function () {
        try {
          var t = Object(i.a)(Object, "defineProperty");
          return t({}, "", {}), t;
        } catch (t) {}
      })();
    e.a = s;
  },
  function (t, e, n) {
    "use strict";
    var i = n(41).a.Uint8Array;
    e.a = i;
  },
  function (t, e, n) {
    "use strict";
    function i(t) {
      const e = Object.prototype.toString.apply(t);
      return "[object Window]" == e || "[object global]" == e;
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    }),
      n.d(e, "b", function () {
        return c;
      });
    var i = n(12),
      s = n(21),
      o = n(137);
    function r(t) {
      let e = null;
      const n = t.model,
        i = t.editing.view,
        r = t.commands.get("input");
      function a(t) {
        if (s.a.isWindows && Object(o.c)(t, i.document)) return;
        const a = n.document,
          u = i.document.isComposing,
          d = e && e.isEqual(a.selection);
        (e = null),
          r.isEnabled &&
            (c(t) ||
              a.selection.isCollapsed ||
              (u && 229 === t.keyCode) ||
              (!u && 229 === t.keyCode && d) ||
              l());
      }
      function l() {
        const t = r.buffer;
        t.lock();
        const e = t.batch;
        r._batches.add(e),
          n.enqueueChange(e, () => {
            n.deleteContent(n.document.selection);
          }),
          t.unlock();
      }
      s.a.isAndroid
        ? i.document.on("beforeinput", (t, e) => a(e), { priority: "lowest" })
        : i.document.on("keydown", (t, e) => a(e), { priority: "lowest" }),
        i.document.on(
          "compositionstart",
          function () {
            const t = n.document,
              e =
                1 !== t.selection.rangeCount ||
                t.selection.getFirstRange().isFlat;
            if (t.selection.isCollapsed || e) return;
            l();
          },
          { priority: "lowest" }
        ),
        i.document.on(
          "compositionend",
          () => {
            e = n.createSelection(n.document.selection);
          },
          { priority: "lowest" }
        );
    }
    const a = [
      Object(i.a)("arrowUp"),
      Object(i.a)("arrowRight"),
      Object(i.a)("arrowDown"),
      Object(i.a)("arrowLeft"),
      9,
      16,
      17,
      18,
      19,
      20,
      27,
      33,
      34,
      35,
      36,
      45,
      91,
      93,
      144,
      145,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      255,
    ];
    for (let t = 112; t <= 135; t++) a.push(t);
    function c(t) {
      return !(!t.ctrlKey && !t.metaKey) || a.includes(t.keyCode);
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(1);
    class s extends i.a {
      constructor(t, e) {
        super(t), (this.attributeKey = e);
      }
      refresh() {
        const t = this.editor.model,
          e = t.document;
        (this.value = this._getValueFromFirstAllowedNode()),
          (this.isEnabled = t.schema.checkAttributeInSelection(
            e.selection,
            this.attributeKey
          ));
      }
      execute(t = {}) {
        const e = this.editor.model,
          n = e.document.selection,
          i = void 0 === t.forceValue ? !this.value : t.forceValue;
        e.change((t) => {
          if (n.isCollapsed)
            i
              ? t.setSelectionAttribute(this.attributeKey, !0)
              : t.removeSelectionAttribute(this.attributeKey);
          else {
            const s = e.schema.getValidRanges(n.getRanges(), this.attributeKey);
            for (const e of s)
              i
                ? t.setAttribute(this.attributeKey, i, e)
                : t.removeAttribute(this.attributeKey, e);
          }
        });
      }
      _getValueFromFirstAllowedNode() {
        const t = this.editor.model,
          e = t.schema,
          n = t.document.selection;
        if (n.isCollapsed) return n.hasAttribute(this.attributeKey);
        for (const t of n.getRanges())
          for (const n of t.getItems())
            if (e.checkAttribute(n, this.attributeKey))
              return n.hasAttribute(this.attributeKey);
        return !1;
      }
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(64),
      s = n(275),
      o = n(46),
      r = n(119),
      a = i.a ? i.a.prototype : void 0,
      c = a ? a.toString : void 0;
    var l = function t(e) {
      if ("string" == typeof e) return e;
      if (Object(o.a)(e)) return Object(s.a)(e, t) + "";
      if (Object(r.a)(e)) return c ? c.call(e) : "";
      var n = e + "";
      return "0" == n && 1 / e == -1 / 0 ? "-0" : n;
    };
    e.a = function (t) {
      return null == t ? "" : l(t);
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    const i = [
      "ar",
      "ara",
      "fa",
      "per",
      "fas",
      "he",
      "heb",
      "ku",
      "kur",
      "ug",
      "uig",
    ];
    function s(t) {
      return i.includes(t) ? "rtl" : "ltr";
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(8),
      s = n(34);
    n(333);
    class o extends s.a {
      constructor(t) {
        super(t),
          (this.isToggleable = !0),
          (this.toggleSwitchView = this._createToggleView()),
          this.extendTemplate({ attributes: { class: "ck-switchbutton" } });
      }
      render() {
        super.render(), this.children.add(this.toggleSwitchView);
      }
      _createToggleView() {
        const t = new i.a();
        return (
          t.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-button__toggle"] },
            children: [
              {
                tag: "span",
                attributes: { class: ["ck", "ck-button__toggle__inner"] },
              },
            ],
          }),
          t
        );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(34),
      s = n(224),
      o = n(114);
    class r extends i.a {
      constructor(t) {
        super(t),
          (this.arrowView = this._createArrowView()),
          this.extendTemplate({ attributes: { "aria-haspopup": !0 } }),
          this.delegate("execute").to(this, "open");
      }
      render() {
        super.render(), this.children.add(this.arrowView);
      }
      _createArrowView() {
        const t = new o.a();
        return (
          (t.content = s.a),
          t.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } }),
          t
        );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(8);
    class s extends i.a {
      constructor(t) {
        super(t),
          this.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-toolbar__separator"] },
          });
      }
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(214),
      s = n(160),
      o = n(156);
    e.a = function (t) {
      return Object(i.a)(t, o.a, s.a);
    };
  },
  function (t, e, n) {
    "use strict";
    function i(t) {
      let e = 0;
      for (const n of t) e++;
      return e;
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    var i = n(63),
      s = n(38);
    var o = function (t) {
        return Object(s.a)(t) && "[object Arguments]" == Object(i.a)(t);
      },
      r = Object.prototype,
      a = r.hasOwnProperty,
      c = r.propertyIsEnumerable,
      l = o(
        (function () {
          return arguments;
        })()
      )
        ? o
        : function (t) {
            return (
              Object(s.a)(t) && a.call(t, "callee") && !c.call(t, "callee")
            );
          };
    e.a = l;
  },
  function (t, e, n) {
    "use strict";
    var i = n(78),
      s = n(184),
      o = n(80),
      r = Object(s.a)(function (t, e) {
        Object(i.a)(e, Object(o.a)(e), t);
      });
    e.a = r;
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(141),
      s = n(14),
      o = n(51),
      r = n(0);
    class a extends i.a {
      static get pluginName() {
        return "PendingActions";
      }
      init() {
        this.set("hasAny", !1),
          (this._actions = new o.default({ idProperty: "_id" })),
          this._actions.delegate("add", "remove").to(this);
      }
      add(t) {
        if ("string" != typeof t)
          throw new r.default("pendingactions-add-invalid-message", this);
        const e = Object.create(s.default);
        return e.set("message", t), this._actions.add(e), (this.hasAny = !0), e;
      }
      remove(t) {
        this._actions.remove(t), (this.hasAny = !!this._actions.length);
      }
      get first() {
        return this._actions.get(0);
      }
      [Symbol.iterator]() {
        return this._actions[Symbol.iterator]();
      }
    }
  },
  ,
  function (t, e, n) {
    "use strict";
    function i(t) {
      const e = t.next();
      return e.done ? null : e.value;
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  ,
  function (t, e, n) {
    "use strict";
    var i = n(38),
      s = n(76);
    e.a = function (t) {
      return Object(i.a)(t) && 1 === t.nodeType && !Object(s.a)(t);
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return l;
    });
    var i = n(45),
      s = n(177);
    class o extends i.a {
      refresh() {
        const t = this.editor.model,
          e = t.document,
          n = Object(s.a)(e.selection.getSelectedBlocks());
        (this.value = !!n && n.is("element", "paragraph")),
          (this.isEnabled = !!n && r(n, t.schema));
      }
      execute(t = {}) {
        const e = this.editor.model,
          n = e.document;
        e.change((i) => {
          const s = (t.selection || n.selection).getSelectedBlocks();
          for (const t of s)
            !t.is("element", "paragraph") &&
              r(t, e.schema) &&
              i.rename(t, "paragraph");
        });
      }
    }
    function r(t, e) {
      return e.checkChild(t.parent, "paragraph") && !e.isObject(t);
    }
    class a extends i.a {
      execute(t) {
        const e = this.editor.model;
        let n = t.position;
        e.change((t) => {
          const i = t.createElement("paragraph");
          if (!e.schema.checkChild(n.parent, i)) {
            const s = e.schema.findAllowedParent(n, i);
            if (!s) return;
            n = t.split(n, s).position;
          }
          e.insertContent(i, n), t.setSelection(i, "in");
        });
      }
    }
    var c = n(9);
    class l extends c.a {
      static get pluginName() {
        return "Paragraph";
      }
      init() {
        const t = this.editor,
          e = t.model;
        t.commands.add("paragraph", new o(t)),
          t.commands.add("insertParagraph", new a(t)),
          e.schema.register("paragraph", { inheritAllFrom: "$block" }),
          t.conversion.elementToElement({ model: "paragraph", view: "p" }),
          t.conversion.for("upcast").elementToElement({
            model: (t, { writer: e }) =>
              l.paragraphLikeElements.has(t.name)
                ? t.isEmpty
                  ? null
                  : e.createElement("paragraph")
                : null,
            view: /.+/,
            converterPriority: "low",
          });
      }
    }
    l.paragraphLikeElements = new Set([
      "blockquote",
      "dd",
      "div",
      "dt",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "li",
      "p",
      "td",
      "th",
    ]);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return m;
    });
    var i = n(9),
      s = n(129),
      o = n(234),
      r = n(128),
      a = n(21),
      c = n(12),
      l = n(18);
    function u(t) {
      const e = t.model;
      return (n, i) => {
        const s = i.keyCode == c.f.arrowup,
          o = i.keyCode == c.f.arrowdown,
          r = i.shiftKey,
          a = e.document.selection;
        if (!s && !o) return;
        const u = o;
        if (
          r &&
          (function (t, e) {
            return !t.isCollapsed && t.isBackward == e;
          })(a, u)
        )
          return;
        const f = (function (t, e, n) {
          const i = t.model;
          if (n) {
            const t = e.isCollapsed ? e.focus : e.getLastPosition(),
              n = d(i, t, "forward");
            if (!n) return null;
            const s = i.createRange(t, n),
              o = h(i.schema, s, "backward");
            return o ? i.createRange(t, o) : null;
          }
          {
            const t = e.isCollapsed ? e.focus : e.getFirstPosition(),
              n = d(i, t, "backward");
            if (!n) return null;
            const s = i.createRange(n, t),
              o = h(i.schema, s, "forward");
            return o ? i.createRange(o, t) : null;
          }
        })(t, a, u);
        if (f) {
          if (f.isCollapsed) {
            if (a.isCollapsed) return;
            if (r) return;
          }
          (f.isCollapsed ||
            (function (t, e, n) {
              const i = t.model,
                s = t.view.domConverter;
              if (n) {
                const t = i.createSelection(e.start);
                i.modifySelection(t),
                  t.focus.isAtEnd ||
                    e.start.isEqual(t.focus) ||
                    (e = i.createRange(t.focus, e.end));
              }
              const o = t.mapper.toViewRange(e),
                r = s.viewRangeToDom(o),
                a = l.a.getDomRangeRects(r);
              let c;
              for (const t of a)
                if (void 0 !== c) {
                  if (Math.round(t.top) >= c) return !1;
                  c = Math.max(c, Math.round(t.bottom));
                } else c = Math.round(t.bottom);
              return !0;
            })(t, f, u)) &&
            (e.change((t) => {
              const n = u ? f.end : f.start;
              if (r) {
                const i = e.createSelection(a.anchor);
                i.setFocus(n), t.setSelection(i);
              } else t.setSelection(n);
            }),
            n.stop(),
            i.preventDefault(),
            i.stopPropagation());
        }
      };
    }
    function d(t, e, n) {
      const i = t.schema,
        s = t.createRangeIn(e.root),
        o = "forward" == n ? "elementStart" : "elementEnd";
      for (const { previousPosition: t, item: r, type: a } of s.getWalker({
        startPosition: e,
        direction: n,
      })) {
        if (i.isLimit(r) && !i.isInline(r)) return t;
        if (a == o && i.isBlock(r)) return null;
      }
      return null;
    }
    function h(t, e, n) {
      const i = "backward" == n ? e.end : e.start;
      if (t.checkChild(i, "$text")) return i;
      for (const { nextPosition: i } of e.getWalker({ direction: n }))
        if (t.checkChild(i, "$text")) return i;
      return null;
    }
    var f = n(28);
    n(353);
    class m extends i.a {
      static get pluginName() {
        return "Widget";
      }
      static get requires() {
        return [o.a, r.a];
      }
      init() {
        const t = this.editor,
          e = t.editing.view,
          n = e.document;
        (this._previouslySelected = new Set()),
          this.editor.editing.downcastDispatcher.on("selection", (e, n, i) => {
            const s = i.writer,
              o = n.selection;
            if (o.isCollapsed) return;
            const r = o.getSelectedElement();
            if (!r) return;
            const a = t.editing.mapper.toViewElement(r);
            Object(f.d)(a) &&
              i.consumable.consume(o, "selection") &&
              s.setSelection(s.createRangeOn(a), {
                fake: !0,
                label: Object(f.c)(a),
              });
          }),
          this.editor.editing.downcastDispatcher.on(
            "selection",
            (t, e, n) => {
              this._clearPreviouslySelectedWidgets(n.writer);
              const i = n.writer,
                s = i.document.selection;
              let o = null;
              for (const t of s.getRanges())
                for (const e of t) {
                  const t = e.item;
                  Object(f.d)(t) &&
                    !g(t, o) &&
                    (i.addClass(f.a, t),
                    this._previouslySelected.add(t),
                    (o = t));
                }
            },
            { priority: "low" }
          ),
          e.addObserver(s.a),
          this.listenTo(n, "mousedown", (...t) => this._onMousedown(...t)),
          this.listenTo(
            n,
            "arrowKey",
            (...t) => {
              this._handleSelectionChangeOnArrowKeyPress(...t);
            },
            { context: [f.d, "$text"] }
          ),
          this.listenTo(
            n,
            "arrowKey",
            (...t) => {
              this._preventDefaultOnArrowKeyPress(...t);
            },
            { context: "$root" }
          ),
          this.listenTo(n, "arrowKey", u(this.editor.editing), {
            context: "$text",
          }),
          this.listenTo(
            n,
            "delete",
            (t, e) => {
              this._handleDelete("forward" == e.direction) &&
                (e.preventDefault(), t.stop());
            },
            { context: "$root" }
          );
      }
      _onMousedown(t, e) {
        const n = this.editor,
          i = n.editing.view,
          s = i.document;
        let o = e.target;
        if (
          (function (t) {
            for (; t; ) {
              if (t.is("editableElement") && !t.is("rootElement")) return !0;
              if (Object(f.d)(t)) return !1;
              t = t.parent;
            }
            return !1;
          })(o)
        ) {
          if ((a.a.isSafari || a.a.isGecko) && e.domEvent.detail >= 3) {
            const t = n.editing.mapper,
              i = o.is("attributeElement")
                ? o.findAncestor((t) => !t.is("attributeElement"))
                : o,
              s = t.toModelElement(i);
            e.preventDefault(),
              this.editor.model.change((t) => {
                t.setSelection(s, "in");
              });
          }
          return;
        }
        if (!Object(f.d)(o) && ((o = o.findAncestor(f.d)), !o)) return;
        a.a.isAndroid && e.preventDefault(), s.isFocused || i.focus();
        const r = n.editing.mapper.toModelElement(o);
        this._setSelectionOverElement(r);
      }
      _handleSelectionChangeOnArrowKeyPress(t, e) {
        const n = e.keyCode,
          i = this.editor.model,
          s = i.schema,
          o = i.document.selection,
          r = o.getSelectedElement(),
          a = Object(c.c)(n, this.editor.locale.contentLanguageDirection),
          l = "down" == a || "right" == a,
          u = "up" == a || "down" == a;
        if (r && s.isObject(r)) {
          const n = l ? o.getLastPosition() : o.getFirstPosition(),
            r = s.getNearestSelectionRange(n, l ? "forward" : "backward");
          return void (
            r &&
            (i.change((t) => {
              t.setSelection(r);
            }),
            e.preventDefault(),
            t.stop())
          );
        }
        if (!o.isCollapsed && !e.shiftKey) {
          const n = o.getFirstPosition(),
            r = o.getLastPosition(),
            a = n.nodeAfter,
            c = r.nodeBefore;
          return void (
            ((a && s.isObject(a)) || (c && s.isObject(c))) &&
            (i.change((t) => {
              t.setSelection(l ? r : n);
            }),
            e.preventDefault(),
            t.stop())
          );
        }
        if (!o.isCollapsed) return;
        const d = this._getObjectElementNextToSelection(l);
        if (d && s.isObject(d)) {
          if (s.isInline(d) && u) return;
          this._setSelectionOverElement(d), e.preventDefault(), t.stop();
        }
      }
      _preventDefaultOnArrowKeyPress(t, e) {
        const n = this.editor.model,
          i = n.schema,
          s = n.document.selection.getSelectedElement();
        s && i.isObject(s) && (e.preventDefault(), t.stop());
      }
      _handleDelete(t) {
        if (this.editor.isReadOnly) return;
        const e = this.editor.model.document.selection;
        if (!e.isCollapsed) return;
        const n = this._getObjectElementNextToSelection(t);
        return n
          ? (this.editor.model.change((t) => {
              let i = e.anchor.parent;
              for (; i.isEmpty; ) {
                const e = i;
                (i = e.parent), t.remove(e);
              }
              this._setSelectionOverElement(n);
            }),
            !0)
          : void 0;
      }
      _setSelectionOverElement(t) {
        this.editor.model.change((e) => {
          e.setSelection(e.createRangeOn(t));
        });
      }
      _getObjectElementNextToSelection(t) {
        const e = this.editor.model,
          n = e.schema,
          i = e.document.selection,
          s = e.createSelection(i);
        if (
          (e.modifySelection(s, { direction: t ? "forward" : "backward" }),
          s.isEqual(i))
        )
          return null;
        const o = t ? s.focus.nodeBefore : s.focus.nodeAfter;
        return o && n.isObject(o) ? o : null;
      }
      _clearPreviouslySelectedWidgets(t) {
        for (const e of this._previouslySelected) t.removeClass(f.a, e);
        this._previouslySelected.clear();
      }
    }
    function g(t, e) {
      return !!e && Array.from(t.getAncestors()).includes(e);
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(8),
      s = n(192);
    n(341);
    class o extends i.a {
      constructor(t) {
        super(t), (this.body = new s.a(t));
      }
      render() {
        super.render(), this.body.attachToDom();
      }
      destroy() {
        return this.body.detachFromDom(), super.destroy();
      }
    }
  },
  function (t, e, n) {
    "use strict";
    e.a = function (t, e) {
      var n = -1,
        i = t.length;
      for (e || (e = Array(i)); ++n < i; ) e[n] = t[n];
      return e;
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(277),
      s = n(87),
      o = n(117),
      r = n(146),
      a = n(30);
    var c = function (t, e, n) {
      if (!Object(a.a)(n)) return !1;
      var i = typeof e;
      return (
        !!("number" == i
          ? Object(o.a)(n) && Object(r.a)(e, n.length)
          : "string" == i && e in n) && Object(s.a)(n[e], t)
      );
    };
    e.a = function (t) {
      return Object(i.a)(function (e, n) {
        var i = -1,
          s = n.length,
          o = s > 1 ? n[s - 1] : void 0,
          r = s > 2 ? n[2] : void 0;
        for (
          o = t.length > 3 && "function" == typeof o ? (s--, o) : void 0,
            r && c(n[0], n[1], r) && ((o = s < 3 ? void 0 : o), (s = 1)),
            e = Object(e);
          ++i < s;

        ) {
          var a = n[i];
          a && t(e, a, i, o);
        }
        return e;
      });
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(286),
      s = n(110);
    class o {
      constructor(t) {
        (this.domParser = new DOMParser()),
          (this.domConverter = new s.a(t, { renderingMode: "data" })),
          (this.htmlWriter = new i.a());
      }
      toData(t) {
        const e = this.domConverter.viewToDom(t, document);
        return this.htmlWriter.getHtml(e);
      }
      toView(t) {
        const e = this._toDom(t);
        return this.domConverter.domToView(e);
      }
      registerRawContentMatcher(t) {
        this.domConverter.registerRawContentMatcher(t);
      }
      useFillerType(t) {
        this.domConverter.blockFillerMode =
          "marked" == t ? "markedNbsp" : "nbsp";
      }
      _toDom(t) {
        const e = this.domParser.parseFromString(t, "text/html"),
          n = e.createDocumentFragment();
        let i = e.firstChild;
        for (; !i.isSameNode(e.documentElement); ) {
          const t = i;
          (i = i.nextSibling),
            t.nodeType == Node.COMMENT_NODE && n.appendChild(t);
        }
        const s = e.body.childNodes;
        for (; s.length > 0; ) n.appendChild(s[0]);
        return n;
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return c;
    });
    var i = n(208),
      s = n(51),
      o = n(215),
      r = n(203),
      a = n(0);
    class c {
      constructor(t) {
        this.config = new i.a(t, this.constructor.defaultConfig);
        const e = this.constructor.builtinPlugins;
        this.config.define("plugins", e), (this.plugins = new o.a(this, e));
        const n = this.config.get("language") || {};
        (this.locale = new r.a({
          uiLanguage: "string" == typeof n ? n : n.ui,
          contentLanguage: this.config.get("language.content"),
        })),
          (this.t = this.locale.t),
          (this.editors = new s.default()),
          (this._contextOwner = null);
      }
      initPlugins() {
        const t = this.config.get("plugins") || [],
          e = this.config.get("substitutePlugins") || [];
        for (const n of t.concat(e)) {
          if ("function" != typeof n)
            throw new a.default("context-initplugins-constructor-only", null, {
              Plugin: n,
            });
          if (!0 !== n.isContextPlugin)
            throw new a.default("context-initplugins-invalid-plugin", null, {
              Plugin: n,
            });
        }
        return this.plugins.init(t, [], e);
      }
      destroy() {
        return Promise.all(Array.from(this.editors, (t) => t.destroy())).then(
          () => this.plugins.destroy()
        );
      }
      _addEditor(t, e) {
        if (this._contextOwner)
          throw new a.default("context-addeditor-private-context");
        this.editors.add(t), e && (this._contextOwner = t);
      }
      _removeEditor(t) {
        return (
          this.editors.has(t) && this.editors.remove(t),
          this._contextOwner === t ? this.destroy() : Promise.resolve()
        );
      }
      _getEditorConfig() {
        const t = {};
        for (const e of this.config.names())
          ["plugins", "removePlugins", "extraPlugins"].includes(e) ||
            (t[e] = this.config.get(e));
        return t;
      }
      static create(t) {
        return new Promise((e) => {
          const n = new this(t);
          e(n.initPlugins().then(() => n));
        });
      }
    }
  },
  function (t, e, n) {
    "use strict";
    function i(t, e) {
      t instanceof HTMLTextAreaElement && (t.value = e), (t.innerHTML = e);
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return c;
    });
    var i = n(39),
      s = n(63),
      o = n(46),
      r = n(38);
    var a = function (t) {
      return (
        "string" == typeof t ||
        (!Object(o.a)(t) &&
          Object(r.a)(t) &&
          "[object String]" == Object(s.a)(t))
      );
    };
    function c(t, e, n = {}, s = []) {
      const o = n && n.xmlns,
        r = o ? t.createElementNS(o, e) : t.createElement(e);
      for (const t in n) r.setAttribute(t, n[t]);
      (!a(s) && Object(i.a)(s)) || (s = [s]);
      for (let e of s) a(e) && (e = t.createTextNode(e)), r.appendChild(e);
      return r;
    }
  },
  function (t, e, n) {
    "use strict";
    e.a =
      '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(0),
      s = n(125),
      o = n(95),
      r = n(35);
    class a {
      constructor(t, e) {
        (this._helpers = new Map()),
          (this._downcast = Object(r.a)(t)),
          this._createConversionHelpers({
            name: "downcast",
            dispatchers: this._downcast,
            isDowncast: !0,
          }),
          (this._upcast = Object(r.a)(e)),
          this._createConversionHelpers({
            name: "upcast",
            dispatchers: this._upcast,
            isDowncast: !1,
          });
      }
      addAlias(t, e) {
        const n = this._downcast.includes(e);
        if (!this._upcast.includes(e) && !n)
          throw new i.default(
            "conversion-add-alias-dispatcher-not-registered",
            this
          );
        this._createConversionHelpers({
          name: t,
          dispatchers: [e],
          isDowncast: n,
        });
      }
      for(t) {
        if (!this._helpers.has(t))
          throw new i.default("conversion-for-unknown-group", this);
        return this._helpers.get(t);
      }
      elementToElement(t) {
        this.for("downcast").elementToElement(t);
        for (const { model: e, view: n } of c(t))
          this.for("upcast").elementToElement({
            model: e,
            view: n,
            converterPriority: t.converterPriority,
          });
      }
      attributeToElement(t) {
        this.for("downcast").attributeToElement(t);
        for (const { model: e, view: n } of c(t))
          this.for("upcast").elementToAttribute({
            view: n,
            model: e,
            converterPriority: t.converterPriority,
          });
      }
      attributeToAttribute(t) {
        this.for("downcast").attributeToAttribute(t);
        for (const { model: e, view: n } of c(t))
          this.for("upcast").attributeToAttribute({ view: n, model: e });
      }
      _createConversionHelpers({ name: t, dispatchers: e, isDowncast: n }) {
        if (this._helpers.has(t))
          throw new i.default("conversion-group-exists", this);
        const r = n ? new o.d(e) : new s.d(e);
        this._helpers.set(t, r);
      }
    }
    function* c(t) {
      if (t.model.values)
        for (const e of t.model.values) {
          const n = { key: t.model.key, value: e },
            i = t.view[e],
            s = t.upcastAlso ? t.upcastAlso[e] : void 0;
          yield* l(n, i, s);
        }
      else yield* l(t.model, t.view, t.upcastAlso);
    }
    function* l(t, e, n) {
      if ((yield { model: t, view: e }, n))
        for (const e of Object(r.a)(n)) yield { model: t, view: e };
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return m;
    });
    var i = n(48),
      s = n(47),
      o = n(65),
      r = n(23),
      a = n(56),
      c = n(40),
      l = n(75),
      u = n(126),
      d = n(29),
      h = n(36);
    const f = {};
    (f[i.a.className] = i.a),
      (f[s.a.className] = s.a),
      (f[o.a.className] = o.a),
      (f[r.a.className] = r.a),
      (f[a.a.className] = a.a),
      (f[c.a.className] = c.a),
      (f[l.a.className] = l.a),
      (f[u.a.className] = u.a),
      (f[d.a.className] = d.a),
      (f[h.a.className] = h.a);
    class m {
      static fromJSON(t, e) {
        return f[t.__className].fromJSON(t, e);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(61),
      s = n(113),
      o = n(188);
    class r extends s.a {
      constructor(t, e = []) {
        super(e), (this.locale = t);
      }
      attachToDom() {
        this._bodyCollectionContainer = new i.a({
          tag: "div",
          attributes: {
            class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
            dir: this.locale.uiLanguageDirection,
          },
          children: this,
        }).render();
        let t = document.querySelector(".ck-body-wrapper");
        t ||
          ((t = Object(o.a)(document, "div", { class: "ck-body-wrapper" })),
          document.body.appendChild(t)),
          t.appendChild(this._bodyCollectionContainer);
      }
      detachFromDom() {
        super.destroy(),
          this._bodyCollectionContainer &&
            this._bodyCollectionContainer.remove();
        const t = document.querySelector(".ck-body-wrapper");
        t && 0 == t.childElementCount && t.remove();
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(8);
    n(331);
    class s extends i.a {
      constructor(t) {
        super(t), this.set("text", ""), this.set("position", "s");
        const e = this.bindTemplate;
        this.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-tooltip",
              e.to("position", (t) => "ck-tooltip_" + t),
              e.if("text", "ck-hidden", (t) => !t.trim()),
            ],
          },
          children: [
            {
              tag: "span",
              attributes: { class: ["ck", "ck-tooltip__text"] },
              children: [{ text: e.to("text") }],
            },
          ],
        });
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(8),
      s = n(52),
      o = n(115),
      r = n(69);
    n(338);
    class a extends i.a {
      constructor() {
        super(),
          (this.items = this.createCollection()),
          (this.focusTracker = new s.a()),
          (this.keystrokes = new r.a()),
          (this._focusCycler = new o.a({
            focusables: this.items,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "arrowup", focusNext: "arrowdown" },
          })),
          this.setTemplate({
            tag: "ul",
            attributes: { class: ["ck", "ck-reset", "ck-list"] },
            children: this.items,
          });
      }
      render() {
        super.render();
        for (const t of this.items) this.focusTracker.add(t.element);
        this.items.on("add", (t, e) => {
          this.focusTracker.add(e.element);
        }),
          this.items.on("remove", (t, e) => {
            this.focusTracker.remove(e.element);
          }),
          this.keystrokes.listenTo(this.element);
      }
      destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
      }
      focus() {
        this._focusCycler.focusFirst();
      }
      focusLast() {
        this._focusCycler.focusLast();
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(8);
    class s extends i.a {
      constructor(t) {
        super(t),
          (this.children = this.createCollection()),
          this.setTemplate({
            tag: "li",
            attributes: { class: ["ck", "ck-list__item"] },
            children: this.children,
          });
      }
      focus() {
        this.children.first.focus();
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return v;
    });
    var i = n(47),
      s = n(48),
      o = n(75),
      r = n(65),
      a = n(23),
      c = n(126),
      l = n(36),
      u = n(29),
      d = n(56),
      h = n(3),
      f = n(5),
      m = n(37);
    const g = new Map();
    function p(t, e, n) {
      let i = g.get(t);
      i || ((i = new Map()), g.set(t, i)), i.set(e, n);
    }
    function b(t) {
      return [t];
    }
    function w(t, e, n = {}) {
      const i = (function (t, e) {
        const n = g.get(t);
        return n && n.has(e) ? n.get(e) : b;
      })(t.constructor, e.constructor);
      try {
        return i((t = t.clone()), e, n);
      } catch (t) {
        throw t;
      }
    }
    function v(t, e, n) {
      (t = t.slice()), (e = e.slice());
      const i = new _(n.document, n.useRelations, n.forceWeakRemove);
      i.setOriginalOperations(t), i.setOriginalOperations(e);
      const s = i.originalOperations;
      if (0 == t.length || 0 == e.length)
        return { operationsA: t, operationsB: e, originalOperations: s };
      const o = new WeakMap();
      for (const e of t) o.set(e, 0);
      const r = {
        nextBaseVersionA: t[t.length - 1].baseVersion + 1,
        nextBaseVersionB: e[e.length - 1].baseVersion + 1,
        originalOperationsACount: t.length,
        originalOperationsBCount: e.length,
      };
      let a = 0;
      for (; a < t.length; ) {
        const n = t[a],
          s = o.get(n);
        if (s == e.length) {
          a++;
          continue;
        }
        const r = e[s],
          c = w(n, r, i.getContext(n, r, !0)),
          l = w(r, n, i.getContext(r, n, !1));
        i.updateRelation(n, r),
          i.setOriginalOperations(c, n),
          i.setOriginalOperations(l, r);
        for (const t of c) o.set(t, s + l.length);
        t.splice(a, 1, ...c), e.splice(s, 1, ...l);
      }
      if (n.padWithNoOps) {
        const n = t.length - r.originalOperationsACount,
          i = e.length - r.originalOperationsBCount;
        k(t, i - n), k(e, n - i);
      }
      return (
        y(t, r.nextBaseVersionB),
        y(e, r.nextBaseVersionA),
        { operationsA: t, operationsB: e, originalOperations: s }
      );
    }
    class _ {
      constructor(t, e, n = !1) {
        (this.originalOperations = new Map()),
          (this._history = t.history),
          (this._useRelations = e),
          (this._forceWeakRemove = !!n),
          (this._relations = new Map());
      }
      setOriginalOperations(t, e = null) {
        const n = e ? this.originalOperations.get(e) : null;
        for (const e of t) this.originalOperations.set(e, n || e);
      }
      updateRelation(t, e) {
        switch (t.constructor) {
          case a.a:
            switch (e.constructor) {
              case l.a:
                t.targetPosition.isEqual(e.sourcePosition) ||
                e.movedRange.containsPosition(t.targetPosition)
                  ? this._setRelation(t, e, "insertAtSource")
                  : t.targetPosition.isEqual(e.deletionPosition)
                  ? this._setRelation(t, e, "insertBetween")
                  : t.targetPosition.isAfter(e.sourcePosition) &&
                    this._setRelation(t, e, "moveTargetAfter");
                break;
              case a.a:
                t.targetPosition.isEqual(e.sourcePosition) ||
                t.targetPosition.isBefore(e.sourcePosition)
                  ? this._setRelation(t, e, "insertBefore")
                  : this._setRelation(t, e, "insertAfter");
            }
            break;
          case u.a:
            switch (e.constructor) {
              case l.a:
                t.splitPosition.isBefore(e.sourcePosition) &&
                  this._setRelation(t, e, "splitBefore");
                break;
              case a.a:
                if (
                  t.splitPosition.isEqual(e.sourcePosition) ||
                  t.splitPosition.isBefore(e.sourcePosition)
                )
                  this._setRelation(t, e, "splitBefore");
                else {
                  const n = h.a._createFromPositionAndShift(
                    e.sourcePosition,
                    e.howMany
                  );
                  if (
                    t.splitPosition.hasSameParentAs(e.sourcePosition) &&
                    n.containsPosition(t.splitPosition)
                  ) {
                    const i = n.end.offset - t.splitPosition.offset,
                      s = t.splitPosition.offset - n.start.offset;
                    this._setRelation(t, e, { howMany: i, offset: s });
                  }
                }
            }
            break;
          case l.a:
            switch (e.constructor) {
              case l.a:
                t.targetPosition.isEqual(e.sourcePosition) ||
                  this._setRelation(t, e, "mergeTargetNotMoved"),
                  t.sourcePosition.isEqual(e.targetPosition) &&
                    this._setRelation(t, e, "mergeSourceNotMoved"),
                  t.sourcePosition.isEqual(e.sourcePosition) &&
                    this._setRelation(t, e, "mergeSameElement");
                break;
              case u.a:
                t.sourcePosition.isEqual(e.splitPosition) &&
                  this._setRelation(t, e, "splitAtSource");
            }
            break;
          case r.a: {
            const n = t.newRange;
            if (!n) return;
            switch (e.constructor) {
              case a.a: {
                const i = h.a._createFromPositionAndShift(
                    e.sourcePosition,
                    e.howMany
                  ),
                  s = i.containsPosition(n.start) || i.start.isEqual(n.start),
                  o = i.containsPosition(n.end) || i.end.isEqual(n.end);
                (!s && !o) ||
                  i.containsRange(n) ||
                  this._setRelation(t, e, {
                    side: s ? "left" : "right",
                    path: s ? n.start.path.slice() : n.end.path.slice(),
                  });
                break;
              }
              case l.a: {
                const i = n.start.isEqual(e.targetPosition),
                  s = n.start.isEqual(e.deletionPosition),
                  o = n.end.isEqual(e.deletionPosition),
                  r = n.end.isEqual(e.sourcePosition);
                (i || s || o || r) &&
                  this._setRelation(t, e, {
                    wasInLeftElement: i,
                    wasStartBeforeMergedElement: s,
                    wasEndBeforeMergedElement: o,
                    wasInRightElement: r,
                  });
                break;
              }
            }
            break;
          }
        }
      }
      getContext(t, e, n) {
        return {
          aIsStrong: n,
          aWasUndone: this._wasUndone(t),
          bWasUndone: this._wasUndone(e),
          abRelation: this._useRelations ? this._getRelation(t, e) : null,
          baRelation: this._useRelations ? this._getRelation(e, t) : null,
          forceWeakRemove: this._forceWeakRemove,
        };
      }
      _wasUndone(t) {
        const e = this.originalOperations.get(t);
        return e.wasUndone || this._history.isUndoneOperation(e);
      }
      _getRelation(t, e) {
        const n = this.originalOperations.get(e),
          i = this._history.getUndoneOperation(n);
        if (!i) return null;
        const s = this.originalOperations.get(t),
          o = this._relations.get(s);
        return (o && o.get(i)) || null;
      }
      _setRelation(t, e, n) {
        const i = this.originalOperations.get(t),
          s = this.originalOperations.get(e);
        let o = this._relations.get(i);
        o || ((o = new Map()), this._relations.set(i, o)), o.set(s, n);
      }
    }
    function y(t, e) {
      for (const n of t) n.baseVersion = e++;
    }
    function k(t, e) {
      for (let n = 0; n < e; n++) t.push(new d.a(0));
    }
    function A(t, e, n) {
      const i = t.nodes.getNode(0).getAttribute(e);
      if (i == n) return null;
      const o = new h.a(t.position, t.position.getShiftedBy(t.howMany));
      return new s.a(o, e, i, n, 0);
    }
    function C(t, e) {
      return (
        null ===
        t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany)
      );
    }
    function E(t, e) {
      const n = [];
      for (let i = 0; i < t.length; i++) {
        const s = t[i],
          o = new a.a(s.start, s.end.offset - s.start.offset, e, 0);
        n.push(o);
        for (let e = i + 1; e < t.length; e++)
          t[e] = t[e]._getTransformedByMove(
            o.sourcePosition,
            o.targetPosition,
            o.howMany
          )[0];
        e = e._getTransformedByMove(
          o.sourcePosition,
          o.targetPosition,
          o.howMany
        );
      }
      return n;
    }
    p(s.a, s.a, (t, e, n) => {
      if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) {
        const i = t.range
            .getDifference(e.range)
            .map((e) => new s.a(e, t.key, t.oldValue, t.newValue, 0)),
          o = t.range.getIntersection(e.range);
        return (
          o &&
            n.aIsStrong &&
            i.push(new s.a(o, e.key, e.newValue, t.newValue, 0)),
          0 == i.length ? [new d.a(0)] : i
        );
      }
      return [t];
    }),
      p(s.a, i.a, (t, e) => {
        if (
          t.range.start.hasSameParentAs(e.position) &&
          t.range.containsPosition(e.position)
        ) {
          const n = t.range
            ._getTransformedByInsertion(
              e.position,
              e.howMany,
              !e.shouldReceiveAttributes
            )
            .map(
              (e) => new s.a(e, t.key, t.oldValue, t.newValue, t.baseVersion)
            );
          if (e.shouldReceiveAttributes) {
            const i = A(e, t.key, t.oldValue);
            i && n.unshift(i);
          }
          return n;
        }
        return (
          (t.range = t.range._getTransformedByInsertion(
            e.position,
            e.howMany,
            !1
          )[0]),
          [t]
        );
      }),
      p(s.a, l.a, (t, e) => {
        const n = [];
        t.range.start.hasSameParentAs(e.deletionPosition) &&
          (t.range.containsPosition(e.deletionPosition) ||
            t.range.start.isEqual(e.deletionPosition)) &&
          n.push(h.a._createFromPositionAndShift(e.graveyardPosition, 1));
        const i = t.range._getTransformedByMergeOperation(e);
        return (
          i.isCollapsed || n.push(i),
          n.map((e) => new s.a(e, t.key, t.oldValue, t.newValue, t.baseVersion))
        );
      }),
      p(s.a, a.a, (t, e) =>
        (function (t, e) {
          const n = h.a._createFromPositionAndShift(
            e.sourcePosition,
            e.howMany
          );
          let i = null,
            s = [];
          n.containsRange(t, !0)
            ? (i = t)
            : t.start.hasSameParentAs(n.start)
            ? ((s = t.getDifference(n)), (i = t.getIntersection(n)))
            : (s = [t]);
          const o = [];
          for (let t of s) {
            t = t._getTransformedByDeletion(e.sourcePosition, e.howMany);
            const n = e.getMovedRangeStart(),
              i = t.start.hasSameParentAs(n);
            (t = t._getTransformedByInsertion(n, e.howMany, i)), o.push(...t);
          }
          i &&
            o.push(
              i._getTransformedByMove(
                e.sourcePosition,
                e.targetPosition,
                e.howMany,
                !1
              )[0]
            );
          return o;
        })(t.range, e).map(
          (e) => new s.a(e, t.key, t.oldValue, t.newValue, t.baseVersion)
        )
      ),
      p(s.a, u.a, (t, e) => {
        if (t.range.end.isEqual(e.insertionPosition))
          return e.graveyardPosition || t.range.end.offset++, [t];
        if (
          t.range.start.hasSameParentAs(e.splitPosition) &&
          t.range.containsPosition(e.splitPosition)
        ) {
          const n = t.clone();
          return (
            (n.range = new h.a(
              e.moveTargetPosition.clone(),
              t.range.end._getCombined(e.splitPosition, e.moveTargetPosition)
            )),
            (t.range.end = e.splitPosition.clone()),
            (t.range.end.stickiness = "toPrevious"),
            [t, n]
          );
        }
        return (t.range = t.range._getTransformedBySplitOperation(e)), [t];
      }),
      p(i.a, s.a, (t, e) => {
        const n = [t];
        if (
          t.shouldReceiveAttributes &&
          t.position.hasSameParentAs(e.range.start) &&
          e.range.containsPosition(t.position)
        ) {
          const i = A(t, e.key, e.newValue);
          i && n.push(i);
        }
        return n;
      }),
      p(
        i.a,
        i.a,
        (t, e, n) => (
          (t.position.isEqual(e.position) && n.aIsStrong) ||
            (t.position = t.position._getTransformedByInsertOperation(e)),
          [t]
        )
      ),
      p(
        i.a,
        a.a,
        (t, e) => (
          (t.position = t.position._getTransformedByMoveOperation(e)), [t]
        )
      ),
      p(
        i.a,
        u.a,
        (t, e) => (
          (t.position = t.position._getTransformedBySplitOperation(e)), [t]
        )
      ),
      p(
        i.a,
        l.a,
        (t, e) => (
          (t.position = t.position._getTransformedByMergeOperation(e)), [t]
        )
      ),
      p(
        r.a,
        i.a,
        (t, e) => (
          t.oldRange &&
            (t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0]),
          t.newRange &&
            (t.newRange = t.newRange._getTransformedByInsertOperation(e)[0]),
          [t]
        )
      ),
      p(r.a, r.a, (t, e, n) => {
        if (t.name == e.name) {
          if (!n.aIsStrong) return [new d.a(0)];
          t.oldRange = e.newRange ? e.newRange.clone() : null;
        }
        return [t];
      }),
      p(
        r.a,
        l.a,
        (t, e) => (
          t.oldRange &&
            (t.oldRange = t.oldRange._getTransformedByMergeOperation(e)),
          t.newRange &&
            (t.newRange = t.newRange._getTransformedByMergeOperation(e)),
          [t]
        )
      ),
      p(r.a, a.a, (t, e, n) => {
        if (
          (t.oldRange &&
            (t.oldRange = h.a._createFromRanges(
              t.oldRange._getTransformedByMoveOperation(e)
            )),
          t.newRange)
        ) {
          if (n.abRelation) {
            const i = h.a._createFromRanges(
              t.newRange._getTransformedByMoveOperation(e)
            );
            if (
              "left" == n.abRelation.side &&
              e.targetPosition.isEqual(t.newRange.start)
            )
              return (
                (t.newRange.start.path = n.abRelation.path),
                (t.newRange.end = i.end),
                [t]
              );
            if (
              "right" == n.abRelation.side &&
              e.targetPosition.isEqual(t.newRange.end)
            )
              return (
                (t.newRange.start = i.start),
                (t.newRange.end.path = n.abRelation.path),
                [t]
              );
          }
          t.newRange = h.a._createFromRanges(
            t.newRange._getTransformedByMoveOperation(e)
          );
        }
        return [t];
      }),
      p(r.a, u.a, (t, e, n) => {
        if (
          (t.oldRange &&
            (t.oldRange = t.oldRange._getTransformedBySplitOperation(e)),
          t.newRange)
        ) {
          if (n.abRelation) {
            const i = t.newRange._getTransformedBySplitOperation(e);
            return (
              t.newRange.start.isEqual(e.splitPosition) &&
              n.abRelation.wasStartBeforeMergedElement
                ? (t.newRange.start = f.a._createAt(e.insertionPosition))
                : t.newRange.start.isEqual(e.splitPosition) &&
                  !n.abRelation.wasInLeftElement &&
                  (t.newRange.start = f.a._createAt(e.moveTargetPosition)),
              t.newRange.end.isEqual(e.splitPosition) &&
              n.abRelation.wasInRightElement
                ? (t.newRange.end = f.a._createAt(e.moveTargetPosition))
                : t.newRange.end.isEqual(e.splitPosition) &&
                  n.abRelation.wasEndBeforeMergedElement
                ? (t.newRange.end = f.a._createAt(e.insertionPosition))
                : (t.newRange.end = i.end),
              [t]
            );
          }
          t.newRange = t.newRange._getTransformedBySplitOperation(e);
        }
        return [t];
      }),
      p(
        l.a,
        i.a,
        (t, e) => (
          t.sourcePosition.hasSameParentAs(e.position) &&
            (t.howMany += e.howMany),
          (t.sourcePosition =
            t.sourcePosition._getTransformedByInsertOperation(e)),
          (t.targetPosition =
            t.targetPosition._getTransformedByInsertOperation(e)),
          [t]
        )
      ),
      p(l.a, l.a, (t, e, n) => {
        if (
          t.sourcePosition.isEqual(e.sourcePosition) &&
          t.targetPosition.isEqual(e.targetPosition)
        ) {
          if (n.bWasUndone) {
            const n = e.graveyardPosition.path.slice();
            return (
              n.push(0),
              (t.sourcePosition = new f.a(e.graveyardPosition.root, n)),
              (t.howMany = 0),
              [t]
            );
          }
          return [new d.a(0)];
        }
        if (
          t.sourcePosition.isEqual(e.sourcePosition) &&
          !t.targetPosition.isEqual(e.targetPosition) &&
          !n.bWasUndone &&
          "splitAtSource" != n.abRelation
        ) {
          const i = "$graveyard" == t.targetPosition.root.rootName,
            s = "$graveyard" == e.targetPosition.root.rootName,
            o = i && !s;
          if ((s && !i) || (!o && n.aIsStrong)) {
            const n = e.targetPosition._getTransformedByMergeOperation(e),
              i = t.targetPosition._getTransformedByMergeOperation(e);
            return [new a.a(n, t.howMany, i, 0)];
          }
          return [new d.a(0)];
        }
        return (
          t.sourcePosition.hasSameParentAs(e.targetPosition) &&
            (t.howMany += e.howMany),
          (t.sourcePosition =
            t.sourcePosition._getTransformedByMergeOperation(e)),
          (t.targetPosition =
            t.targetPosition._getTransformedByMergeOperation(e)),
          (t.graveyardPosition.isEqual(e.graveyardPosition) && n.aIsStrong) ||
            (t.graveyardPosition =
              t.graveyardPosition._getTransformedByMergeOperation(e)),
          [t]
        );
      }),
      p(l.a, a.a, (t, e, n) => {
        const i = h.a._createFromPositionAndShift(e.sourcePosition, e.howMany);
        return "remove" == e.type &&
          !n.bWasUndone &&
          !n.forceWeakRemove &&
          t.deletionPosition.hasSameParentAs(e.sourcePosition) &&
          i.containsPosition(t.sourcePosition)
          ? [new d.a(0)]
          : (t.sourcePosition.hasSameParentAs(e.targetPosition) &&
              (t.howMany += e.howMany),
            t.sourcePosition.hasSameParentAs(e.sourcePosition) &&
              (t.howMany -= e.howMany),
            (t.sourcePosition =
              t.sourcePosition._getTransformedByMoveOperation(e)),
            (t.targetPosition =
              t.targetPosition._getTransformedByMoveOperation(e)),
            t.graveyardPosition.isEqual(e.targetPosition) ||
              (t.graveyardPosition =
                t.graveyardPosition._getTransformedByMoveOperation(e)),
            [t]);
      }),
      p(l.a, u.a, (t, e, n) => {
        if (
          (e.graveyardPosition &&
            ((t.graveyardPosition =
              t.graveyardPosition._getTransformedByDeletion(
                e.graveyardPosition,
                1
              )),
            t.deletionPosition.isEqual(e.graveyardPosition) &&
              (t.howMany = e.howMany)),
          t.targetPosition.isEqual(e.splitPosition))
        ) {
          const i = 0 != e.howMany,
            s =
              e.graveyardPosition &&
              t.deletionPosition.isEqual(e.graveyardPosition);
          if (i || s || "mergeTargetNotMoved" == n.abRelation)
            return (
              (t.sourcePosition =
                t.sourcePosition._getTransformedBySplitOperation(e)),
              [t]
            );
        }
        if (t.sourcePosition.isEqual(e.splitPosition)) {
          if ("mergeSourceNotMoved" == n.abRelation)
            return (
              (t.howMany = 0),
              (t.targetPosition =
                t.targetPosition._getTransformedBySplitOperation(e)),
              [t]
            );
          if ("mergeSameElement" == n.abRelation || t.sourcePosition.offset > 0)
            return (
              (t.sourcePosition = e.moveTargetPosition.clone()),
              (t.targetPosition =
                t.targetPosition._getTransformedBySplitOperation(e)),
              [t]
            );
        }
        return (
          t.sourcePosition.hasSameParentAs(e.splitPosition) &&
            (t.howMany = e.splitPosition.offset),
          (t.sourcePosition =
            t.sourcePosition._getTransformedBySplitOperation(e)),
          (t.targetPosition =
            t.targetPosition._getTransformedBySplitOperation(e)),
          [t]
        );
      }),
      p(a.a, i.a, (t, e) => {
        const n = h.a
          ._createFromPositionAndShift(t.sourcePosition, t.howMany)
          ._getTransformedByInsertOperation(e, !1)[0];
        return (
          (t.sourcePosition = n.start),
          (t.howMany = n.end.offset - n.start.offset),
          t.targetPosition.isEqual(e.position) ||
            (t.targetPosition =
              t.targetPosition._getTransformedByInsertOperation(e)),
          [t]
        );
      }),
      p(a.a, a.a, (t, e, n) => {
        const i = h.a._createFromPositionAndShift(t.sourcePosition, t.howMany),
          s = h.a._createFromPositionAndShift(e.sourcePosition, e.howMany);
        let o,
          r = n.aIsStrong,
          a = !n.aIsStrong;
        if (
          ("insertBefore" == n.abRelation || "insertAfter" == n.baRelation
            ? (a = !0)
            : ("insertAfter" != n.abRelation &&
                "insertBefore" != n.baRelation) ||
              (a = !1),
          (o =
            t.targetPosition.isEqual(e.targetPosition) && a
              ? t.targetPosition._getTransformedByDeletion(
                  e.sourcePosition,
                  e.howMany
                )
              : t.targetPosition._getTransformedByMove(
                  e.sourcePosition,
                  e.targetPosition,
                  e.howMany
                )),
          C(t, e) && C(e, t))
        )
          return [e.getReversed()];
        if (i.containsPosition(e.targetPosition) && i.containsRange(s, !0))
          return (
            (i.start = i.start._getTransformedByMove(
              e.sourcePosition,
              e.targetPosition,
              e.howMany
            )),
            (i.end = i.end._getTransformedByMove(
              e.sourcePosition,
              e.targetPosition,
              e.howMany
            )),
            E([i], o)
          );
        if (s.containsPosition(t.targetPosition) && s.containsRange(i, !0))
          return (
            (i.start = i.start._getCombined(
              e.sourcePosition,
              e.getMovedRangeStart()
            )),
            (i.end = i.end._getCombined(
              e.sourcePosition,
              e.getMovedRangeStart()
            )),
            E([i], o)
          );
        const c = Object(m.a)(
          t.sourcePosition.getParentPath(),
          e.sourcePosition.getParentPath()
        );
        if ("prefix" == c || "extension" == c)
          return (
            (i.start = i.start._getTransformedByMove(
              e.sourcePosition,
              e.targetPosition,
              e.howMany
            )),
            (i.end = i.end._getTransformedByMove(
              e.sourcePosition,
              e.targetPosition,
              e.howMany
            )),
            E([i], o)
          );
        "remove" != t.type ||
        "remove" == e.type ||
        n.aWasUndone ||
        n.forceWeakRemove
          ? "remove" == t.type ||
            "remove" != e.type ||
            n.bWasUndone ||
            n.forceWeakRemove ||
            (r = !1)
          : (r = !0);
        const l = [],
          u = i.getDifference(s);
        for (const t of u) {
          (t.start = t.start._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany
          )),
            (t.end = t.end._getTransformedByDeletion(
              e.sourcePosition,
              e.howMany
            ));
          const n =
              "same" ==
              Object(m.a)(
                t.start.getParentPath(),
                e.getMovedRangeStart().getParentPath()
              ),
            i = t._getTransformedByInsertion(
              e.getMovedRangeStart(),
              e.howMany,
              n
            );
          l.push(...i);
        }
        const f = i.getIntersection(s);
        return (
          null !== f &&
            r &&
            ((f.start = f.start._getCombined(
              e.sourcePosition,
              e.getMovedRangeStart()
            )),
            (f.end = f.end._getCombined(
              e.sourcePosition,
              e.getMovedRangeStart()
            )),
            0 === l.length
              ? l.push(f)
              : 1 == l.length
              ? s.start.isBefore(i.start) || s.start.isEqual(i.start)
                ? l.unshift(f)
                : l.push(f)
              : l.splice(1, 0, f)),
          0 === l.length ? [new d.a(t.baseVersion)] : E(l, o)
        );
      }),
      p(a.a, u.a, (t, e, n) => {
        let i = t.targetPosition.clone();
        (t.targetPosition.isEqual(e.insertionPosition) &&
          e.graveyardPosition &&
          "moveTargetAfter" != n.abRelation) ||
          (i = t.targetPosition._getTransformedBySplitOperation(e));
        const s = h.a._createFromPositionAndShift(t.sourcePosition, t.howMany);
        if (s.end.isEqual(e.insertionPosition))
          return (
            e.graveyardPosition || t.howMany++, (t.targetPosition = i), [t]
          );
        if (
          s.start.hasSameParentAs(e.splitPosition) &&
          s.containsPosition(e.splitPosition)
        ) {
          let t = new h.a(e.splitPosition, s.end);
          t = t._getTransformedBySplitOperation(e);
          return E([new h.a(s.start, e.splitPosition), t], i);
        }
        t.targetPosition.isEqual(e.splitPosition) &&
          "insertAtSource" == n.abRelation &&
          (i = e.moveTargetPosition),
          t.targetPosition.isEqual(e.insertionPosition) &&
            "insertBetween" == n.abRelation &&
            (i = t.targetPosition);
        const o = [s._getTransformedBySplitOperation(e)];
        if (e.graveyardPosition) {
          const i =
            s.start.isEqual(e.graveyardPosition) ||
            s.containsPosition(e.graveyardPosition);
          t.howMany > 1 &&
            i &&
            !n.aWasUndone &&
            o.push(h.a._createFromPositionAndShift(e.insertionPosition, 1));
        }
        return E(o, i);
      }),
      p(a.a, l.a, (t, e, n) => {
        const i = h.a._createFromPositionAndShift(t.sourcePosition, t.howMany);
        if (
          e.deletionPosition.hasSameParentAs(t.sourcePosition) &&
          i.containsPosition(e.sourcePosition)
        )
          if ("remove" != t.type || n.forceWeakRemove) {
            if (1 == t.howMany)
              return n.bWasUndone
                ? ((t.sourcePosition = e.graveyardPosition.clone()),
                  (t.targetPosition =
                    t.targetPosition._getTransformedByMergeOperation(e)),
                  [t])
                : [new d.a(0)];
          } else if (!n.aWasUndone) {
            const n = [];
            let i = e.graveyardPosition.clone(),
              s = e.targetPosition._getTransformedByMergeOperation(e);
            t.howMany > 1 &&
              (n.push(
                new a.a(t.sourcePosition, t.howMany - 1, t.targetPosition, 0)
              ),
              (i = i._getTransformedByMove(
                t.sourcePosition,
                t.targetPosition,
                t.howMany - 1
              )),
              (s = s._getTransformedByMove(
                t.sourcePosition,
                t.targetPosition,
                t.howMany - 1
              )));
            const o = e.deletionPosition._getCombined(
                t.sourcePosition,
                t.targetPosition
              ),
              r = new a.a(i, 1, o, 0),
              c = r.getMovedRangeStart().path.slice();
            c.push(0);
            const l = new f.a(r.targetPosition.root, c);
            s = s._getTransformedByMove(i, o, 1);
            const u = new a.a(s, e.howMany, l, 0);
            return n.push(r), n.push(u), n;
          }
        const s = h.a
          ._createFromPositionAndShift(t.sourcePosition, t.howMany)
          ._getTransformedByMergeOperation(e);
        return (
          (t.sourcePosition = s.start),
          (t.howMany = s.end.offset - s.start.offset),
          (t.targetPosition =
            t.targetPosition._getTransformedByMergeOperation(e)),
          [t]
        );
      }),
      p(
        o.a,
        i.a,
        (t, e) => (
          (t.position = t.position._getTransformedByInsertOperation(e)), [t]
        )
      ),
      p(o.a, l.a, (t, e) =>
        t.position.isEqual(e.deletionPosition)
          ? ((t.position = e.graveyardPosition.clone()),
            (t.position.stickiness = "toNext"),
            [t])
          : ((t.position = t.position._getTransformedByMergeOperation(e)), [t])
      ),
      p(
        o.a,
        a.a,
        (t, e) => (
          (t.position = t.position._getTransformedByMoveOperation(e)), [t]
        )
      ),
      p(o.a, o.a, (t, e, n) => {
        if (t.position.isEqual(e.position)) {
          if (!n.aIsStrong) return [new d.a(0)];
          t.oldName = e.newName;
        }
        return [t];
      }),
      p(o.a, u.a, (t, e) => {
        const n = t.position.path,
          i = e.splitPosition.getParentPath();
        if ("same" == Object(m.a)(n, i) && !e.graveyardPosition) {
          const e = new o.a(
            t.position.getShiftedBy(1),
            t.oldName,
            t.newName,
            0
          );
          return [t, e];
        }
        return (
          (t.position = t.position._getTransformedBySplitOperation(e)), [t]
        );
      }),
      p(c.a, c.a, (t, e, n) => {
        if (t.root === e.root && t.key === e.key) {
          if (!n.aIsStrong || t.newValue === e.newValue) return [new d.a(0)];
          t.oldValue = e.newValue;
        }
        return [t];
      }),
      p(
        u.a,
        i.a,
        (t, e) => (
          t.splitPosition.hasSameParentAs(e.position) &&
            t.splitPosition.offset < e.position.offset &&
            (t.howMany += e.howMany),
          (t.splitPosition =
            t.splitPosition._getTransformedByInsertOperation(e)),
          (t.insertionPosition =
            t.insertionPosition._getTransformedByInsertOperation(e)),
          [t]
        )
      ),
      p(u.a, l.a, (t, e, n) => {
        if (
          !t.graveyardPosition &&
          !n.bWasUndone &&
          t.splitPosition.hasSameParentAs(e.sourcePosition)
        ) {
          const n = e.graveyardPosition.path.slice();
          n.push(0);
          const i = new f.a(e.graveyardPosition.root, n),
            s = u.a.getInsertionPosition(new f.a(e.graveyardPosition.root, n)),
            o = new u.a(i, 0, s, null, 0);
          return (
            (t.splitPosition =
              t.splitPosition._getTransformedByMergeOperation(e)),
            (t.insertionPosition = u.a.getInsertionPosition(t.splitPosition)),
            (t.graveyardPosition = o.insertionPosition.clone()),
            (t.graveyardPosition.stickiness = "toNext"),
            [o, t]
          );
        }
        return (
          t.splitPosition.hasSameParentAs(e.deletionPosition) &&
            !t.splitPosition.isAfter(e.deletionPosition) &&
            t.howMany--,
          t.splitPosition.hasSameParentAs(e.targetPosition) &&
            (t.howMany += e.howMany),
          (t.splitPosition =
            t.splitPosition._getTransformedByMergeOperation(e)),
          (t.insertionPosition = u.a.getInsertionPosition(t.splitPosition)),
          t.graveyardPosition &&
            (t.graveyardPosition =
              t.graveyardPosition._getTransformedByMergeOperation(e)),
          [t]
        );
      }),
      p(u.a, a.a, (t, e, n) => {
        const i = h.a._createFromPositionAndShift(e.sourcePosition, e.howMany);
        if (t.graveyardPosition) {
          const s =
            i.start.isEqual(t.graveyardPosition) ||
            i.containsPosition(t.graveyardPosition);
          if (!n.bWasUndone && s) {
            const n = t.splitPosition._getTransformedByMoveOperation(e),
              i = t.graveyardPosition._getTransformedByMoveOperation(e),
              s = i.path.slice();
            s.push(0);
            const o = new f.a(i.root, s);
            return [new a.a(n, t.howMany, o, 0)];
          }
          t.graveyardPosition =
            t.graveyardPosition._getTransformedByMoveOperation(e);
        }
        const s = t.splitPosition.isEqual(e.targetPosition);
        if (
          s &&
          ("insertAtSource" == n.baRelation || "splitBefore" == n.abRelation)
        )
          return (
            (t.howMany += e.howMany),
            (t.splitPosition = t.splitPosition._getTransformedByDeletion(
              e.sourcePosition,
              e.howMany
            )),
            (t.insertionPosition = u.a.getInsertionPosition(t.splitPosition)),
            [t]
          );
        if (s && n.abRelation && n.abRelation.howMany) {
          const { howMany: e, offset: i } = n.abRelation;
          return (
            (t.howMany += e),
            (t.splitPosition = t.splitPosition.getShiftedBy(i)),
            [t]
          );
        }
        if (
          t.splitPosition.hasSameParentAs(e.sourcePosition) &&
          i.containsPosition(t.splitPosition)
        ) {
          const n =
            e.howMany - (t.splitPosition.offset - e.sourcePosition.offset);
          return (
            (t.howMany -= n),
            t.splitPosition.hasSameParentAs(e.targetPosition) &&
              t.splitPosition.offset < e.targetPosition.offset &&
              (t.howMany += e.howMany),
            (t.splitPosition = e.sourcePosition.clone()),
            (t.insertionPosition = u.a.getInsertionPosition(t.splitPosition)),
            [t]
          );
        }
        return (
          e.sourcePosition.isEqual(e.targetPosition) ||
            (t.splitPosition.hasSameParentAs(e.sourcePosition) &&
              t.splitPosition.offset <= e.sourcePosition.offset &&
              (t.howMany -= e.howMany),
            t.splitPosition.hasSameParentAs(e.targetPosition) &&
              t.splitPosition.offset < e.targetPosition.offset &&
              (t.howMany += e.howMany)),
          (t.splitPosition.stickiness = "toNone"),
          (t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e)),
          (t.splitPosition.stickiness = "toNext"),
          t.graveyardPosition
            ? (t.insertionPosition =
                t.insertionPosition._getTransformedByMoveOperation(e))
            : (t.insertionPosition = u.a.getInsertionPosition(t.splitPosition)),
          [t]
        );
      }),
      p(u.a, u.a, (t, e, n) => {
        if (t.splitPosition.isEqual(e.splitPosition)) {
          if (!t.graveyardPosition && !e.graveyardPosition) return [new d.a(0)];
          if (
            t.graveyardPosition &&
            e.graveyardPosition &&
            t.graveyardPosition.isEqual(e.graveyardPosition)
          )
            return [new d.a(0)];
          if ("splitBefore" == n.abRelation)
            return (
              (t.howMany = 0),
              (t.graveyardPosition =
                t.graveyardPosition._getTransformedBySplitOperation(e)),
              [t]
            );
        }
        if (
          t.graveyardPosition &&
          e.graveyardPosition &&
          t.graveyardPosition.isEqual(e.graveyardPosition)
        ) {
          const i = "$graveyard" == t.splitPosition.root.rootName,
            s = "$graveyard" == e.splitPosition.root.rootName,
            o = i && !s;
          if ((s && !i) || (!o && n.aIsStrong)) {
            const n = [];
            return (
              e.howMany &&
                n.push(
                  new a.a(e.moveTargetPosition, e.howMany, e.splitPosition, 0)
                ),
              t.howMany &&
                n.push(
                  new a.a(t.splitPosition, t.howMany, t.moveTargetPosition, 0)
                ),
              n
            );
          }
          return [new d.a(0)];
        }
        if (
          (t.graveyardPosition &&
            (t.graveyardPosition =
              t.graveyardPosition._getTransformedBySplitOperation(e)),
          t.splitPosition.isEqual(e.insertionPosition) &&
            "splitBefore" == n.abRelation)
        )
          return t.howMany++, [t];
        if (
          e.splitPosition.isEqual(t.insertionPosition) &&
          "splitBefore" == n.baRelation
        ) {
          const n = e.insertionPosition.path.slice();
          n.push(0);
          const i = new f.a(e.insertionPosition.root, n);
          return [t, new a.a(t.insertionPosition, 1, i, 0)];
        }
        return (
          t.splitPosition.hasSameParentAs(e.splitPosition) &&
            t.splitPosition.offset < e.splitPosition.offset &&
            (t.howMany -= e.howMany),
          (t.splitPosition =
            t.splitPosition._getTransformedBySplitOperation(e)),
          (t.insertionPosition = u.a.getInsertionPosition(t.splitPosition)),
          [t]
        );
      });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return f;
    });
    var i = n(9),
      s = n(89),
      o = n(129),
      r = n(181),
      a = n(44),
      c = n(21),
      l = n(28),
      u = n(90),
      d = n(159),
      h = n(326);
    n(354);
    class f extends i.a {
      static get pluginName() {
        return "DragDrop";
      }
      static get requires() {
        return [u.a, r.a];
      }
      init() {
        const t = this.editor,
          e = t.editing.view;
        (this._draggedRange = null),
          (this._draggingUid = ""),
          (this._draggableElement = null),
          (this._updateDropMarkerThrottled = Object(h.a)(
            (t) => this._updateDropMarker(t),
            40
          )),
          (this._removeDropMarkerDelayed = p(
            () => this._removeDropMarker(),
            40
          )),
          (this._clearDraggableAttributesDelayed = p(
            () => this._clearDraggableAttributes(),
            40
          )),
          e.addObserver(d.a),
          e.addObserver(o.a),
          this._setupDragging(),
          this._setupContentInsertionIntegration(),
          this._setupClipboardInputIntegration(),
          this._setupDropMarker(),
          this._setupDraggableAttributeHandling(),
          this.listenTo(t, "change:isReadOnly", (t, e, n) => {
            n
              ? this.forceDisabled("readOnlyMode")
              : this.clearForceDisabled("readOnlyMode");
          }),
          this.on("change:isEnabled", (t, e, n) => {
            n || this._finalizeDragging(!1);
          }),
          c.a.isAndroid && this.forceDisabled("noAndroidSupport");
      }
      destroy() {
        return (
          this._draggedRange &&
            (this._draggedRange.detach(), (this._draggedRange = null)),
          this._updateDropMarkerThrottled.cancel(),
          this._removeDropMarkerDelayed.cancel(),
          this._clearDraggableAttributesDelayed.cancel(),
          super.destroy()
        );
      }
      _setupDragging() {
        const t = this.editor,
          e = t.model,
          n = e.document,
          i = t.editing.view,
          o = i.document;
        this.listenTo(
          o,
          "dragstart",
          (i, r) => {
            const c = n.selection;
            if (r.target && r.target.is("editableElement"))
              return void r.preventDefault();
            const u = r.target ? b(r.target) : null;
            if (u) {
              const n = t.editing.mapper.toModelElement(u);
              (this._draggedRange = s.a.fromRange(e.createRangeOn(n))),
                t.plugins.has("WidgetToolbarRepository") &&
                  t.plugins
                    .get("WidgetToolbarRepository")
                    .forceDisabled("dragDrop");
            } else if (!o.selection.isCollapsed) {
              const t = o.selection.getSelectedElement();
              (t && Object(l.d)(t)) ||
                (this._draggedRange = s.a.fromRange(c.getFirstRange()));
            }
            if (!this._draggedRange) return void r.preventDefault();
            (this._draggingUid = Object(a.a)()),
              (r.dataTransfer.effectAllowed = this.isEnabled
                ? "copyMove"
                : "copy"),
              r.dataTransfer.setData(
                "application/ckeditor5-dragging-uid",
                this._draggingUid
              );
            const d = e.createSelection(this._draggedRange.toRange()),
              h = t.data.toView(e.getSelectedContent(d));
            o.fire("clipboardOutput", {
              dataTransfer: r.dataTransfer,
              content: h,
              method: i.name,
            }),
              this.isEnabled ||
                (this._draggedRange.detach(),
                (this._draggedRange = null),
                (this._draggingUid = ""));
          },
          { priority: "low" }
        ),
          this.listenTo(
            o,
            "dragend",
            (t, e) => {
              this._finalizeDragging(
                !e.dataTransfer.isCanceled &&
                  "move" == e.dataTransfer.dropEffect
              );
            },
            { priority: "low" }
          ),
          this.listenTo(o, "dragenter", () => {
            this.isEnabled && i.focus();
          }),
          this.listenTo(o, "dragleave", () => {
            this._removeDropMarkerDelayed();
          }),
          this.listenTo(
            o,
            "dragging",
            (e, n) => {
              if (!this.isEnabled)
                return void (n.dataTransfer.dropEffect = "none");
              this._removeDropMarkerDelayed.cancel();
              const i = m(t, n.targetRanges, n.target);
              this._draggedRange || (n.dataTransfer.dropEffect = "copy"),
                c.a.isGecko ||
                  ("copy" == n.dataTransfer.effectAllowed
                    ? (n.dataTransfer.dropEffect = "copy")
                    : ["all", "copyMove"].includes(
                        n.dataTransfer.effectAllowed
                      ) && (n.dataTransfer.dropEffect = "move")),
                i && this._updateDropMarkerThrottled(i);
            },
            { priority: "low" }
          );
      }
      _setupClipboardInputIntegration() {
        const t = this.editor,
          e = t.editing.view.document;
        this.listenTo(
          e,
          "clipboardInput",
          (e, n) => {
            if ("drop" != n.method) return;
            const i = m(t, n.targetRanges, n.target);
            if ((this._removeDropMarker(), !i))
              return this._finalizeDragging(!1), void e.stop();
            this._draggedRange &&
              this._draggingUid !=
                n.dataTransfer.getData("application/ckeditor5-dragging-uid") &&
              (this._draggedRange.detach(),
              (this._draggedRange = null),
              (this._draggingUid = ""));
            if (
              "move" == g(n.dataTransfer) &&
              this._draggedRange &&
              this._draggedRange.containsRange(i, !0)
            )
              return this._finalizeDragging(!1), void e.stop();
            n.targetRanges = [t.editing.mapper.toViewRange(i)];
          },
          { priority: "high" }
        );
      }
      _setupContentInsertionIntegration() {
        const t = this.editor.plugins.get(u.a);
        t.on(
          "contentInsertion",
          (t, e) => {
            if (!this.isEnabled || "drop" !== e.method) return;
            const n = e.targetRanges.map((t) =>
              this.editor.editing.mapper.toModelRange(t)
            );
            this.editor.model.change((t) => t.setSelection(n));
          },
          { priority: "high" }
        ),
          t.on(
            "contentInsertion",
            (t, e) => {
              if (!this.isEnabled || "drop" !== e.method) return;
              const n = "move" == g(e.dataTransfer),
                i = !e.resultRange || !e.resultRange.isCollapsed;
              this._finalizeDragging(i && n);
            },
            { priority: "lowest" }
          );
      }
      _setupDraggableAttributeHandling() {
        const t = this.editor,
          e = t.editing.view,
          n = e.document;
        this.listenTo(n, "mousedown", (i, s) => {
          if (c.a.isAndroid || !s) return;
          this._clearDraggableAttributesDelayed.cancel();
          let o = b(s.target);
          if (c.a.isBlink && !t.isReadOnly && !o && !n.selection.isCollapsed) {
            const t = n.selection.getSelectedElement();
            (t && Object(l.d)(t)) || (o = n.selection.editableElement);
          }
          o &&
            (e.change((t) => {
              t.setAttribute("draggable", "true", o);
            }),
            (this._draggableElement = t.editing.mapper.toModelElement(o)));
        }),
          this.listenTo(n, "mouseup", () => {
            c.a.isAndroid || this._clearDraggableAttributesDelayed();
          });
      }
      _clearDraggableAttributes() {
        const t = this.editor.editing;
        t.view.change((e) => {
          this._draggableElement &&
            "$graveyard" != this._draggableElement.root.rootName &&
            e.removeAttribute(
              "draggable",
              t.mapper.toViewElement(this._draggableElement)
            ),
            (this._draggableElement = null);
        });
      }
      _setupDropMarker() {
        const t = this.editor;
        t.conversion.for("editingDowncast").markerToHighlight({
          model: "drop-target",
          view: { classes: ["ck-clipboard-drop-target-range"] },
        }),
          t.conversion.for("editingDowncast").markerToElement({
            model: "drop-target",
            view: (e, { writer: n }) => {
              if (t.model.schema.checkChild(e.markerRange.start, "$text"))
                return n.createUIElement(
                  "span",
                  { class: "ck ck-clipboard-drop-target-position" },
                  function (t) {
                    const e = this.toDomElement(t);
                    return (e.innerHTML = "&NoBreak;<span></span>&NoBreak;"), e;
                  }
                );
            },
          });
      }
      _updateDropMarker(t) {
        const e = this.editor,
          n = e.model.markers;
        e.model.change((e) => {
          n.has("drop-target")
            ? n.get("drop-target").getRange().isEqual(t) ||
              e.updateMarker("drop-target", { range: t })
            : e.addMarker("drop-target", {
                range: t,
                usingOperation: !1,
                affectsData: !1,
              });
        });
      }
      _removeDropMarker() {
        const t = this.editor.model;
        this._removeDropMarkerDelayed.cancel(),
          this._updateDropMarkerThrottled.cancel(),
          t.markers.has("drop-target") &&
            t.change((t) => {
              t.removeMarker("drop-target");
            });
      }
      _finalizeDragging(t) {
        const e = this.editor,
          n = e.model;
        this._removeDropMarker(),
          this._clearDraggableAttributes(),
          e.plugins.has("WidgetToolbarRepository") &&
            e.plugins
              .get("WidgetToolbarRepository")
              .clearForceDisabled("dragDrop"),
          (this._draggingUid = ""),
          this._draggedRange &&
            (t &&
              this.isEnabled &&
              n.deleteContent(n.createSelection(this._draggedRange), {
                doNotAutoparagraph: !0,
              }),
            this._draggedRange.detach(),
            (this._draggedRange = null));
      }
    }
    function m(t, e, n) {
      const i = t.model,
        s = t.editing.mapper;
      let o = null;
      const r = e ? e[0].start : null;
      if (
        (n.is("uiElement") && (n = n.parent),
        (o = (function (t, e) {
          const n = t.model,
            i = t.editing.mapper;
          if (Object(l.d)(e)) return n.createRangeOn(i.toModelElement(e));
          if (!e.is("editableElement")) {
            const t = e.findAncestor(
              (t) => Object(l.d)(t) || t.is("editableElement")
            );
            if (Object(l.d)(t)) return n.createRangeOn(i.toModelElement(t));
          }
          return null;
        })(t, n)),
        o)
      )
        return o;
      const a = (function (t, e) {
          const n = t.editing.mapper,
            i = t.editing.view,
            s = n.toModelElement(e);
          if (s) return s;
          const o = i.createPositionBefore(e),
            r = n.findMappedViewAncestor(o);
          return n.toModelElement(r);
        })(t, n),
        u = r ? s.toModelPosition(r) : null;
      return u
        ? ((o = (function (t, e, n) {
            const i = t.model;
            if (!i.schema.checkChild(n, "$block")) return null;
            const s = i.createPositionAt(n, 0),
              o = e.path.slice(0, s.path.length),
              r = i.createPositionFromPath(e.root, o).nodeAfter;
            if (r && i.schema.isObject(r)) return i.createRangeOn(r);
            return null;
          })(t, u, a)),
          o ||
            ((o = i.schema.getNearestSelectionRange(
              u,
              c.a.isGecko ? "forward" : "backward"
            )),
            o ||
              (function (t, e) {
                const n = t.model;
                for (; e; ) {
                  if (n.schema.isObject(e)) return n.createRangeOn(e);
                  e = e.parent;
                }
              })(t, u.parent)))
        : (function (t, e) {
            const n = t.model,
              i = n.schema,
              s = n.createPositionAt(e, 0);
            return i.getNearestSelectionRange(s, "forward");
          })(t, a);
    }
    function g(t) {
      return c.a.isGecko
        ? t.dropEffect
        : ["all", "copyMove"].includes(t.effectAllowed)
        ? "move"
        : "copy";
    }
    function p(t, e) {
      let n;
      function i(...s) {
        i.cancel(), (n = setTimeout(() => t(...s), e));
      }
      return (
        (i.cancel = () => {
          clearTimeout(n);
        }),
        i
      );
    }
    function b(t) {
      if (t.is("editableElement")) return null;
      if (t.hasClass("ck-widget__selection-handle")) return t.findAncestor(l.d);
      if (Object(l.d)(t)) return t;
      const e = t.findAncestor(
        (t) => Object(l.d)(t) || t.is("editableElement")
      );
      return Object(l.d)(e) ? e : null;
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(9),
      s = n(159),
      o = n(90);
    class r extends i.a {
      static get pluginName() {
        return "PastePlainText";
      }
      static get requires() {
        return [o.a];
      }
      init() {
        const t = this.editor,
          e = t.model,
          n = t.editing.view,
          i = n.document,
          r = e.document.selection;
        let a = !1;
        n.addObserver(s.a),
          this.listenTo(i, "keydown", (t, e) => {
            a = e.shiftKey;
          }),
          t.plugins.get(o.a).on("contentInsertion", (t, n) => {
            (a ||
              (function (t, e) {
                if (t.childCount > 1) return !1;
                const n = t.getChild(0);
                if (e.isObject(n)) return !1;
                return 0 == [...n.getAttributeKeys()].length;
              })(n.content, e.schema)) &&
              e.change((t) => {
                const i = Array.from(r.getAttributes()).filter(
                  ([t]) => e.schema.getAttributeProperties(t).isFormatting
                );
                r.isCollapsed || e.deleteContent(r, { doNotAutoparagraph: !0 }),
                  i.push(...r.getAttributes());
                const s = t.createRangeIn(n.content);
                for (const e of s.getItems())
                  e.is("$textProxy") && t.setAttributes(i, e);
              });
          });
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return ft;
    });
    class i {
      constructor(t = "default") {
        (this.operations = []), (this.type = t);
      }
      get baseVersion() {
        for (const t of this.operations)
          if (null !== t.baseVersion) return t.baseVersion;
        return null;
      }
      addOperation(t) {
        return (t.batch = this), this.operations.push(t), t;
      }
    }
    var s = n(48),
      o = n(40),
      r = n(3),
      a = n(57),
      c = n(0);
    class l extends o.a {
      constructor(t, e) {
        super(null), (this.sourcePosition = t.clone()), (this.howMany = e);
      }
      get type() {
        return "detach";
      }
      toJSON() {
        const t = super.toJSON();
        return (t.sourcePosition = this.sourcePosition.toJSON()), t;
      }
      _validate() {
        if (this.sourcePosition.root.document)
          throw new c.default("detach-operation-on-document-node", this);
      }
      _execute() {
        Object(a.d)(
          r.a._createFromPositionAndShift(this.sourcePosition, this.howMany)
        );
      }
      static get className() {
        return "DetachOperation";
      }
    }
    var u = n(47),
      d = n(65),
      h = n(23),
      f = n(75),
      m = n(126),
      g = n(29),
      p = n(36),
      b = n(100),
      w = n(26),
      v = n(20);
    class _ extends v.a {
      constructor(t, e, n = "main") {
        super(e), (this._document = t), (this.rootName = n);
      }
      get document() {
        return this._document;
      }
      is(t, e) {
        return e
          ? e === this.name &&
              ("rootElement" === t ||
                "model:rootElement" === t ||
                "element" === t ||
                "model:element" === t)
          : "rootElement" === t ||
              "model:rootElement" === t ||
              "element" === t ||
              "model:element" === t ||
              "node" === t ||
              "model:node" === t;
      }
      toJSON() {
        return this.rootName;
      }
    }
    var y = n(5),
      k = n(53),
      A = n(73);
    class C {
      constructor(t, e) {
        (this.model = t), (this.batch = e);
      }
      createText(t, e) {
        return new w.a(t, e);
      }
      createElement(t, e) {
        return new v.a(t, e);
      }
      createDocumentFragment() {
        return new b.a();
      }
      cloneElement(t, e = !0) {
        return t._clone(e);
      }
      insert(t, e, n = 0) {
        if (
          (this._assertWriterUsedCorrectly(), t instanceof w.a && "" == t.data)
        )
          return;
        const i = y.a._createAt(e, n);
        if (t.parent) {
          if (x(t.root, i.root)) return void this.move(r.a._createOn(t), i);
          if (t.root.document)
            throw new c.default("model-writer-insert-forbidden-move", this);
          this.remove(t);
        }
        const s = i.root.document ? i.root.document.version : null,
          o = new u.a(i, t, s);
        if (
          (t instanceof w.a && (o.shouldReceiveAttributes = !0),
          this.batch.addOperation(o),
          this.model.applyOperation(o),
          t instanceof b.a)
        )
          for (const [e, n] of t.markers) {
            const t = y.a._createAt(n.root, 0),
              s = {
                range: new r.a(
                  n.start._getCombined(t, i),
                  n.end._getCombined(t, i)
                ),
                usingOperation: !0,
                affectsData: !0,
              };
            this.model.markers.has(e)
              ? this.updateMarker(e, s)
              : this.addMarker(e, s);
          }
      }
      insertText(t, e, n, i) {
        e instanceof b.a || e instanceof v.a || e instanceof y.a
          ? this.insert(this.createText(t), e, n)
          : this.insert(this.createText(t, e), n, i);
      }
      insertElement(t, e, n, i) {
        e instanceof b.a || e instanceof v.a || e instanceof y.a
          ? this.insert(this.createElement(t), e, n)
          : this.insert(this.createElement(t, e), n, i);
      }
      append(t, e) {
        this.insert(t, e, "end");
      }
      appendText(t, e, n) {
        e instanceof b.a || e instanceof v.a
          ? this.insert(this.createText(t), e, "end")
          : this.insert(this.createText(t, e), n, "end");
      }
      appendElement(t, e, n) {
        e instanceof b.a || e instanceof v.a
          ? this.insert(this.createElement(t), e, "end")
          : this.insert(this.createElement(t, e), n, "end");
      }
      setAttribute(t, e, n) {
        if ((this._assertWriterUsedCorrectly(), n instanceof r.a)) {
          const i = n.getMinimalFlatRanges();
          for (const n of i) E(this, t, e, n);
        } else O(this, t, e, n);
      }
      setAttributes(t, e) {
        for (const [n, i] of Object(A.a)(t)) this.setAttribute(n, i, e);
      }
      removeAttribute(t, e) {
        if ((this._assertWriterUsedCorrectly(), e instanceof r.a)) {
          const n = e.getMinimalFlatRanges();
          for (const e of n) E(this, t, null, e);
        } else O(this, t, null, e);
      }
      clearAttributes(t) {
        this._assertWriterUsedCorrectly();
        const e = (t) => {
          for (const e of t.getAttributeKeys()) this.removeAttribute(e, t);
        };
        if (t instanceof r.a) for (const n of t.getItems()) e(n);
        else e(t);
      }
      move(t, e, n) {
        if ((this._assertWriterUsedCorrectly(), !(t instanceof r.a)))
          throw new c.default("writer-move-invalid-range", this);
        if (!t.isFlat) throw new c.default("writer-move-range-not-flat", this);
        const i = y.a._createAt(e, n);
        if (i.isEqual(t.start)) return;
        if (
          (this._addOperationForAffectedMarkers("move", t), !x(t.root, i.root))
        )
          throw new c.default("writer-move-different-document", this);
        const s = t.root.document ? t.root.document.version : null,
          o = new h.a(t.start, t.end.offset - t.start.offset, i, s);
        this.batch.addOperation(o), this.model.applyOperation(o);
      }
      remove(t) {
        this._assertWriterUsedCorrectly();
        const e = (t instanceof r.a ? t : r.a._createOn(t))
          .getMinimalFlatRanges()
          .reverse();
        for (const t of e)
          this._addOperationForAffectedMarkers("move", t),
            T(t.start, t.end.offset - t.start.offset, this.batch, this.model);
      }
      merge(t) {
        this._assertWriterUsedCorrectly();
        const e = t.nodeBefore,
          n = t.nodeAfter;
        if (
          (this._addOperationForAffectedMarkers("merge", t),
          !(e instanceof v.a))
        )
          throw new c.default("writer-merge-no-element-before", this);
        if (!(n instanceof v.a))
          throw new c.default("writer-merge-no-element-after", this);
        t.root.document ? this._merge(t) : this._mergeDetached(t);
      }
      createPositionFromPath(t, e, n) {
        return this.model.createPositionFromPath(t, e, n);
      }
      createPositionAt(t, e) {
        return this.model.createPositionAt(t, e);
      }
      createPositionAfter(t) {
        return this.model.createPositionAfter(t);
      }
      createPositionBefore(t) {
        return this.model.createPositionBefore(t);
      }
      createRange(t, e) {
        return this.model.createRange(t, e);
      }
      createRangeIn(t) {
        return this.model.createRangeIn(t);
      }
      createRangeOn(t) {
        return this.model.createRangeOn(t);
      }
      createSelection(t, e, n) {
        return this.model.createSelection(t, e, n);
      }
      _mergeDetached(t) {
        const e = t.nodeBefore,
          n = t.nodeAfter;
        this.move(r.a._createIn(n), y.a._createAt(e, "end")), this.remove(n);
      }
      _merge(t) {
        const e = y.a._createAt(t.nodeBefore, "end"),
          n = y.a._createAt(t.nodeAfter, 0),
          i = t.root.document.graveyard,
          s = new y.a(i, [0]),
          o = t.root.document.version,
          r = new p.a(n, t.nodeAfter.maxOffset, e, s, o);
        this.batch.addOperation(r), this.model.applyOperation(r);
      }
      rename(t, e) {
        if ((this._assertWriterUsedCorrectly(), !(t instanceof v.a)))
          throw new c.default("writer-rename-not-element-instance", this);
        const n = t.root.document ? t.root.document.version : null,
          i = new f.a(y.a._createBefore(t), t.name, e, n);
        this.batch.addOperation(i), this.model.applyOperation(i);
      }
      split(t, e) {
        this._assertWriterUsedCorrectly();
        let n,
          i,
          s = t.parent;
        if (!s.parent)
          throw new c.default("writer-split-element-no-parent", this);
        if (
          (e || (e = s.parent),
          !t.parent.getAncestors({ includeSelf: !0 }).includes(e))
        )
          throw new c.default("writer-split-invalid-limit-element", this);
        do {
          const e = s.root.document ? s.root.document.version : null,
            o = s.maxOffset - t.offset,
            r = g.a.getInsertionPosition(t),
            a = new g.a(t, o, r, null, e);
          this.batch.addOperation(a),
            this.model.applyOperation(a),
            n || i || ((n = s), (i = t.parent.nextSibling)),
            (s = (t = this.createPositionAfter(t.parent)).parent);
        } while (s !== e);
        return {
          position: t,
          range: new r.a(y.a._createAt(n, "end"), y.a._createAt(i, 0)),
        };
      }
      wrap(t, e) {
        if ((this._assertWriterUsedCorrectly(), !t.isFlat))
          throw new c.default("writer-wrap-range-not-flat", this);
        const n = e instanceof v.a ? e : new v.a(e);
        if (n.childCount > 0)
          throw new c.default("writer-wrap-element-not-empty", this);
        if (null !== n.parent)
          throw new c.default("writer-wrap-element-attached", this);
        this.insert(n, t.start);
        const i = new r.a(t.start.getShiftedBy(1), t.end.getShiftedBy(1));
        this.move(i, y.a._createAt(n, 0));
      }
      unwrap(t) {
        if ((this._assertWriterUsedCorrectly(), null === t.parent))
          throw new c.default("writer-unwrap-element-no-parent", this);
        this.move(r.a._createIn(t), this.createPositionAfter(t)),
          this.remove(t);
      }
      addMarker(t, e) {
        if (
          (this._assertWriterUsedCorrectly(),
          !e || "boolean" != typeof e.usingOperation)
        )
          throw new c.default("writer-addmarker-no-usingoperation", this);
        const n = e.usingOperation,
          i = e.range,
          s = void 0 !== e.affectsData && e.affectsData;
        if (this.model.markers.has(t))
          throw new c.default("writer-addmarker-marker-exists", this);
        if (!i) throw new c.default("writer-addmarker-no-range", this);
        return n
          ? (P(this, t, null, i, s), this.model.markers.get(t))
          : this.model.markers._set(t, i, n, s);
      }
      updateMarker(t, e) {
        this._assertWriterUsedCorrectly();
        const n = "string" == typeof t ? t : t.name,
          i = this.model.markers.get(n);
        if (!i)
          throw new c.default("writer-updatemarker-marker-not-exists", this);
        if (!e) return void this.model.markers._refresh(i);
        const s = "boolean" == typeof e.usingOperation,
          o = "boolean" == typeof e.affectsData,
          r = o ? e.affectsData : i.affectsData;
        if (!s && !e.range && !o)
          throw new c.default("writer-updatemarker-wrong-options", this);
        const a = i.getRange(),
          l = e.range ? e.range : a;
        s && e.usingOperation !== i.managedUsingOperations
          ? e.usingOperation
            ? P(this, n, null, l, r)
            : (P(this, n, a, null, r), this.model.markers._set(n, l, void 0, r))
          : i.managedUsingOperations
          ? P(this, n, a, l, r)
          : this.model.markers._set(n, l, void 0, r);
      }
      removeMarker(t) {
        this._assertWriterUsedCorrectly();
        const e = "string" == typeof t ? t : t.name;
        if (!this.model.markers.has(e))
          throw new c.default("writer-removemarker-no-marker", this);
        const n = this.model.markers.get(e);
        if (!n.managedUsingOperations)
          return void this.model.markers._remove(e);
        P(this, e, n.getRange(), null, n.affectsData);
      }
      setSelection(t, e, n) {
        this._assertWriterUsedCorrectly(),
          this.model.document.selection._setTo(t, e, n);
      }
      setSelectionFocus(t, e) {
        this._assertWriterUsedCorrectly(),
          this.model.document.selection._setFocus(t, e);
      }
      setSelectionAttribute(t, e) {
        if ((this._assertWriterUsedCorrectly(), "string" == typeof t))
          this._setSelectionAttribute(t, e);
        else
          for (const [e, n] of Object(A.a)(t))
            this._setSelectionAttribute(e, n);
      }
      removeSelectionAttribute(t) {
        if ((this._assertWriterUsedCorrectly(), "string" == typeof t))
          this._removeSelectionAttribute(t);
        else for (const e of t) this._removeSelectionAttribute(e);
      }
      overrideSelectionGravity() {
        return this.model.document.selection._overrideGravity();
      }
      restoreSelectionGravity(t) {
        this.model.document.selection._restoreGravity(t);
      }
      _setSelectionAttribute(t, e) {
        const n = this.model.document.selection;
        if (n.isCollapsed && n.anchor.parent.isEmpty) {
          const i = k.a._getStoreAttributeKey(t);
          this.setAttribute(i, e, n.anchor.parent);
        }
        n._setAttribute(t, e);
      }
      _removeSelectionAttribute(t) {
        const e = this.model.document.selection;
        if (e.isCollapsed && e.anchor.parent.isEmpty) {
          const n = k.a._getStoreAttributeKey(t);
          this.removeAttribute(n, e.anchor.parent);
        }
        e._removeAttribute(t);
      }
      _assertWriterUsedCorrectly() {
        if (this.model._currentWriter !== this)
          throw new c.default("writer-incorrect-use", this);
      }
      _addOperationForAffectedMarkers(t, e) {
        for (const n of this.model.markers) {
          if (!n.managedUsingOperations) continue;
          const i = n.getRange();
          let s = !1;
          if ("move" === t)
            s =
              e.containsPosition(i.start) ||
              e.start.isEqual(i.start) ||
              e.containsPosition(i.end) ||
              e.end.isEqual(i.end);
          else {
            const t = e.nodeBefore,
              n = e.nodeAfter,
              o = i.start.parent == t && i.start.isAtEnd,
              r = i.end.parent == n && 0 == i.end.offset,
              a = i.end.nodeAfter == n,
              c = i.start.nodeAfter == n;
            s = o || r || a || c;
          }
          s && this.updateMarker(n.name, { range: i });
        }
      }
    }
    function E(t, e, n, i) {
      const o = t.model,
        a = o.document;
      let c,
        l,
        u,
        d = i.start;
      for (const t of i.getWalker({ shallow: !0 }))
        (u = t.item.getAttribute(e)),
          c && l != u && (l != n && h(), (d = c)),
          (c = t.nextPosition),
          (l = u);
      function h() {
        const i = new r.a(d, c),
          u = i.root.document ? a.version : null,
          h = new s.a(i, e, l, n, u);
        t.batch.addOperation(h), o.applyOperation(h);
      }
      c instanceof y.a && c != d && l != n && h();
    }
    function O(t, e, n, i) {
      const o = t.model,
        a = o.document,
        c = i.getAttribute(e);
      let l, u;
      if (c != n) {
        if (i.root === i) {
          const t = i.document ? a.version : null;
          u = new m.a(i, e, c, n, t);
        } else {
          l = new r.a(y.a._createBefore(i), t.createPositionAfter(i));
          const o = l.root.document ? a.version : null;
          u = new s.a(l, e, c, n, o);
        }
        t.batch.addOperation(u), o.applyOperation(u);
      }
    }
    function P(t, e, n, i, s) {
      const o = t.model,
        r = o.document,
        a = new d.a(e, n, i, o.markers, s, r.version);
      t.batch.addOperation(a), o.applyOperation(a);
    }
    function T(t, e, n, i) {
      let s;
      if (t.root.document) {
        const n = i.document,
          o = new y.a(n.graveyard, [0]);
        s = new h.a(t, e, o, n.version);
      } else s = new l(t, e);
      n.addOperation(s), i.applyOperation(s);
    }
    function x(t, e) {
      return t === e || (t instanceof _ && e instanceof _);
    }
    var S = n(222);
    class I {
      constructor(t) {
        (this._markerCollection = t),
          (this._changesInElement = new Map()),
          (this._elementSnapshots = new Map()),
          (this._changedMarkers = new Map()),
          (this._changeCount = 0),
          (this._cachedChanges = null),
          (this._cachedChangesWithGraveyard = null);
      }
      get isEmpty() {
        return (
          0 == this._changesInElement.size && 0 == this._changedMarkers.size
        );
      }
      refreshItem(t) {
        if (this._isInInsertedElement(t.parent)) return;
        this._markRemove(t.parent, t.startOffset, t.offsetSize),
          this._markInsert(t.parent, t.startOffset, t.offsetSize);
        const e = r.a._createOn(t);
        for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
          const e = t.getRange();
          this.bufferMarkerChange(t.name, e, e, t.affectsData);
        }
        this._cachedChanges = null;
      }
      bufferOperation(t) {
        switch (t.type) {
          case "insert":
            if (this._isInInsertedElement(t.position.parent)) return;
            this._markInsert(
              t.position.parent,
              t.position.offset,
              t.nodes.maxOffset
            );
            break;
          case "addAttribute":
          case "removeAttribute":
          case "changeAttribute":
            for (const e of t.range.getItems({ shallow: !0 }))
              this._isInInsertedElement(e.parent) || this._markAttribute(e);
            break;
          case "remove":
          case "move":
          case "reinsert": {
            if (
              t.sourcePosition.isEqual(t.targetPosition) ||
              t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition)
            )
              return;
            const e = this._isInInsertedElement(t.sourcePosition.parent),
              n = this._isInInsertedElement(t.targetPosition.parent);
            e ||
              this._markRemove(
                t.sourcePosition.parent,
                t.sourcePosition.offset,
                t.howMany
              ),
              n ||
                this._markInsert(
                  t.targetPosition.parent,
                  t.getMovedRangeStart().offset,
                  t.howMany
                );
            break;
          }
          case "rename": {
            if (this._isInInsertedElement(t.position.parent)) return;
            this._markRemove(t.position.parent, t.position.offset, 1),
              this._markInsert(t.position.parent, t.position.offset, 1);
            const e = r.a._createFromPositionAndShift(t.position, 1);
            for (const t of this._markerCollection.getMarkersIntersectingRange(
              e
            )) {
              const e = t.getRange();
              this.bufferMarkerChange(t.name, e, e, t.affectsData);
            }
            break;
          }
          case "split": {
            const e = t.splitPosition.parent;
            this._isInInsertedElement(e) ||
              this._markRemove(e, t.splitPosition.offset, t.howMany),
              this._isInInsertedElement(t.insertionPosition.parent) ||
                this._markInsert(
                  t.insertionPosition.parent,
                  t.insertionPosition.offset,
                  1
                ),
              t.graveyardPosition &&
                this._markRemove(
                  t.graveyardPosition.parent,
                  t.graveyardPosition.offset,
                  1
                );
            break;
          }
          case "merge": {
            const e = t.sourcePosition.parent;
            this._isInInsertedElement(e.parent) ||
              this._markRemove(e.parent, e.startOffset, 1);
            const n = t.graveyardPosition.parent;
            this._markInsert(n, t.graveyardPosition.offset, 1);
            const i = t.targetPosition.parent;
            this._isInInsertedElement(i) ||
              this._markInsert(i, t.targetPosition.offset, e.maxOffset);
            break;
          }
        }
        this._cachedChanges = null;
      }
      bufferMarkerChange(t, e, n, i) {
        const s = this._changedMarkers.get(t);
        s
          ? ((s.newRange = n),
            (s.affectsData = i),
            null == s.oldRange &&
              null == s.newRange &&
              this._changedMarkers.delete(t))
          : this._changedMarkers.set(t, {
              oldRange: e,
              newRange: n,
              affectsData: i,
            });
      }
      getMarkersToRemove() {
        const t = [];
        for (const [e, n] of this._changedMarkers)
          null != n.oldRange && t.push({ name: e, range: n.oldRange });
        return t;
      }
      getMarkersToAdd() {
        const t = [];
        for (const [e, n] of this._changedMarkers)
          null != n.newRange && t.push({ name: e, range: n.newRange });
        return t;
      }
      getChangedMarkers() {
        return Array.from(this._changedMarkers).map((t) => ({
          name: t[0],
          data: { oldRange: t[1].oldRange, newRange: t[1].newRange },
        }));
      }
      hasDataChanges() {
        for (const [, t] of this._changedMarkers) if (t.affectsData) return !0;
        return this._changesInElement.size > 0;
      }
      getChanges(t = { includeChangesInGraveyard: !1 }) {
        if (this._cachedChanges)
          return t.includeChangesInGraveyard
            ? this._cachedChangesWithGraveyard.slice()
            : this._cachedChanges.slice();
        let e = [];
        for (const t of this._changesInElement.keys()) {
          const n = this._changesInElement
              .get(t)
              .sort((t, e) =>
                t.offset === e.offset
                  ? t.type != e.type
                    ? "remove" == t.type
                      ? -1
                      : 1
                    : 0
                  : t.offset < e.offset
                  ? -1
                  : 1
              ),
            i = this._elementSnapshots.get(t),
            s = R(t.getChildren()),
            o = j(i.length, n);
          let a = 0,
            c = 0;
          for (const n of o)
            if ("i" === n) e.push(this._getInsertDiff(t, a, s[a].name)), a++;
            else if ("r" === n)
              e.push(this._getRemoveDiff(t, a, i[c].name)), c++;
            else if ("a" === n) {
              const n = s[a].attributes,
                o = i[c].attributes;
              let l;
              if ("$text" == s[a].name)
                l = new r.a(y.a._createAt(t, a), y.a._createAt(t, a + 1));
              else {
                const e = t.offsetToIndex(a);
                l = new r.a(
                  y.a._createAt(t, a),
                  y.a._createAt(t.getChild(e), 0)
                );
              }
              e.push(...this._getAttributesDiff(l, o, n)), a++, c++;
            } else a++, c++;
        }
        e.sort((t, e) =>
          t.position.root != e.position.root
            ? t.position.root.rootName < e.position.root.rootName
              ? -1
              : 1
            : t.position.isEqual(e.position)
            ? t.changeCount - e.changeCount
            : t.position.isBefore(e.position)
            ? -1
            : 1
        );
        for (let t = 1, n = 0; t < e.length; t++) {
          const i = e[n],
            s = e[t],
            o =
              "remove" == i.type &&
              "remove" == s.type &&
              "$text" == i.name &&
              "$text" == s.name &&
              i.position.isEqual(s.position),
            r =
              "insert" == i.type &&
              "insert" == s.type &&
              "$text" == i.name &&
              "$text" == s.name &&
              i.position.parent == s.position.parent &&
              i.position.offset + i.length == s.position.offset,
            a =
              "attribute" == i.type &&
              "attribute" == s.type &&
              i.position.parent == s.position.parent &&
              i.range.isFlat &&
              s.range.isFlat &&
              i.position.offset + i.length == s.position.offset &&
              i.attributeKey == s.attributeKey &&
              i.attributeOldValue == s.attributeOldValue &&
              i.attributeNewValue == s.attributeNewValue;
          o || r || a
            ? (i.length++,
              a && (i.range.end = i.range.end.getShiftedBy(1)),
              (e[t] = null))
            : (n = t);
        }
        e = e.filter((t) => t);
        for (const t of e)
          delete t.changeCount,
            "attribute" == t.type && (delete t.position, delete t.length);
        return (
          (this._changeCount = 0),
          (this._cachedChangesWithGraveyard = e.slice()),
          (this._cachedChanges = e.filter(M)),
          t.includeChangesInGraveyard
            ? this._cachedChangesWithGraveyard
            : this._cachedChanges
        );
      }
      reset() {
        this._changesInElement.clear(),
          this._elementSnapshots.clear(),
          this._changedMarkers.clear(),
          (this._cachedChanges = null);
      }
      _markInsert(t, e, n) {
        const i = {
          type: "insert",
          offset: e,
          howMany: n,
          count: this._changeCount++,
        };
        this._markChange(t, i);
      }
      _markRemove(t, e, n) {
        const i = {
          type: "remove",
          offset: e,
          howMany: n,
          count: this._changeCount++,
        };
        this._markChange(t, i), this._removeAllNestedChanges(t, e, n);
      }
      _markAttribute(t) {
        const e = {
          type: "attribute",
          offset: t.startOffset,
          howMany: t.offsetSize,
          count: this._changeCount++,
        };
        this._markChange(t.parent, e);
      }
      _markChange(t, e) {
        this._makeSnapshot(t);
        const n = this._getChangesForElement(t);
        this._handleChange(e, n), n.push(e);
        for (let t = 0; t < n.length; t++)
          n[t].howMany < 1 && (n.splice(t, 1), t--);
      }
      _getChangesForElement(t) {
        let e;
        return (
          this._changesInElement.has(t)
            ? (e = this._changesInElement.get(t))
            : ((e = []), this._changesInElement.set(t, e)),
          e
        );
      }
      _makeSnapshot(t) {
        this._elementSnapshots.has(t) ||
          this._elementSnapshots.set(t, R(t.getChildren()));
      }
      _handleChange(t, e) {
        t.nodesToHandle = t.howMany;
        for (const n of e) {
          const i = t.offset + t.howMany,
            s = n.offset + n.howMany;
          if (
            "insert" == t.type &&
            ("insert" == n.type &&
              (t.offset <= n.offset
                ? (n.offset += t.howMany)
                : t.offset < s &&
                  ((n.howMany += t.nodesToHandle), (t.nodesToHandle = 0))),
            "remove" == n.type &&
              t.offset < n.offset &&
              (n.offset += t.howMany),
            "attribute" == n.type)
          )
            if (t.offset <= n.offset) n.offset += t.howMany;
            else if (t.offset < s) {
              const s = n.howMany;
              (n.howMany = t.offset - n.offset),
                e.unshift({
                  type: "attribute",
                  offset: i,
                  howMany: s - n.howMany,
                  count: this._changeCount++,
                });
            }
          if ("remove" == t.type) {
            if ("insert" == n.type)
              if (i <= n.offset) n.offset -= t.howMany;
              else if (i <= s)
                if (t.offset < n.offset) {
                  const e = i - n.offset;
                  (n.offset = t.offset),
                    (n.howMany -= e),
                    (t.nodesToHandle -= e);
                } else (n.howMany -= t.nodesToHandle), (t.nodesToHandle = 0);
              else if (t.offset <= n.offset)
                (t.nodesToHandle -= n.howMany), (n.howMany = 0);
              else if (t.offset < s) {
                const e = s - t.offset;
                (n.howMany -= e), (t.nodesToHandle -= e);
              }
            if (
              ("remove" == n.type &&
                (i <= n.offset
                  ? (n.offset -= t.howMany)
                  : t.offset < n.offset &&
                    ((t.nodesToHandle += n.howMany), (n.howMany = 0))),
              "attribute" == n.type)
            )
              if (i <= n.offset) n.offset -= t.howMany;
              else if (t.offset < n.offset) {
                const e = i - n.offset;
                (n.offset = t.offset), (n.howMany -= e);
              } else if (t.offset < s)
                if (i <= s) {
                  const i = n.howMany;
                  n.howMany = t.offset - n.offset;
                  const s = i - n.howMany - t.nodesToHandle;
                  e.unshift({
                    type: "attribute",
                    offset: t.offset,
                    howMany: s,
                    count: this._changeCount++,
                  });
                } else n.howMany -= s - t.offset;
          }
          if ("attribute" == t.type) {
            if ("insert" == n.type)
              if (t.offset < n.offset && i > n.offset) {
                if (i > s) {
                  const t = {
                    type: "attribute",
                    offset: s,
                    howMany: i - s,
                    count: this._changeCount++,
                  };
                  this._handleChange(t, e), e.push(t);
                }
                (t.nodesToHandle = n.offset - t.offset),
                  (t.howMany = t.nodesToHandle);
              } else
                t.offset >= n.offset &&
                  t.offset < s &&
                  (i > s
                    ? ((t.nodesToHandle = i - s), (t.offset = s))
                    : (t.nodesToHandle = 0));
            if ("remove" == n.type && t.offset < n.offset && i > n.offset) {
              const s = {
                type: "attribute",
                offset: n.offset,
                howMany: i - n.offset,
                count: this._changeCount++,
              };
              this._handleChange(s, e),
                e.push(s),
                (t.nodesToHandle = n.offset - t.offset),
                (t.howMany = t.nodesToHandle);
            }
            "attribute" == n.type &&
              (t.offset >= n.offset && i <= s
                ? ((t.nodesToHandle = 0), (t.howMany = 0), (t.offset = 0))
                : t.offset <= n.offset && i >= s && (n.howMany = 0));
          }
        }
        (t.howMany = t.nodesToHandle), delete t.nodesToHandle;
      }
      _getInsertDiff(t, e, n) {
        return {
          type: "insert",
          position: y.a._createAt(t, e),
          name: n,
          length: 1,
          changeCount: this._changeCount++,
        };
      }
      _getRemoveDiff(t, e, n) {
        return {
          type: "remove",
          position: y.a._createAt(t, e),
          name: n,
          length: 1,
          changeCount: this._changeCount++,
        };
      }
      _getAttributesDiff(t, e, n) {
        const i = [];
        n = new Map(n);
        for (const [s, o] of e) {
          const e = n.has(s) ? n.get(s) : null;
          e !== o &&
            i.push({
              type: "attribute",
              position: t.start,
              range: t.clone(),
              length: 1,
              attributeKey: s,
              attributeOldValue: o,
              attributeNewValue: e,
              changeCount: this._changeCount++,
            }),
            n.delete(s);
        }
        for (const [e, s] of n)
          i.push({
            type: "attribute",
            position: t.start,
            range: t.clone(),
            length: 1,
            attributeKey: e,
            attributeOldValue: null,
            attributeNewValue: s,
            changeCount: this._changeCount++,
          });
        return i;
      }
      _isInInsertedElement(t) {
        const e = t.parent;
        if (!e) return !1;
        const n = this._changesInElement.get(e),
          i = t.startOffset;
        if (n)
          for (const t of n)
            if ("insert" == t.type && i >= t.offset && i < t.offset + t.howMany)
              return !0;
        return this._isInInsertedElement(e);
      }
      _removeAllNestedChanges(t, e, n) {
        const i = new r.a(y.a._createAt(t, e), y.a._createAt(t, e + n));
        for (const t of i.getItems({ shallow: !0 }))
          t.is("element") &&
            (this._elementSnapshots.delete(t),
            this._changesInElement.delete(t),
            this._removeAllNestedChanges(t, 0, t.maxOffset));
      }
    }
    function R(t) {
      const e = [];
      for (const n of t)
        if (n.is("$text"))
          for (let t = 0; t < n.data.length; t++)
            e.push({ name: "$text", attributes: new Map(n.getAttributes()) });
        else e.push({ name: n.name, attributes: new Map(n.getAttributes()) });
      return e;
    }
    function j(t, e) {
      const n = [];
      let i = 0,
        s = 0;
      for (const t of e) {
        if (t.offset > i) {
          for (let e = 0; e < t.offset - i; e++) n.push("e");
          s += t.offset - i;
        }
        if ("insert" == t.type) {
          for (let e = 0; e < t.howMany; e++) n.push("i");
          i = t.offset + t.howMany;
        } else if ("remove" == t.type) {
          for (let e = 0; e < t.howMany; e++) n.push("r");
          (i = t.offset), (s += t.howMany);
        } else
          n.push(..."a".repeat(t.howMany).split("")),
            (i = t.offset + t.howMany),
            (s += t.howMany);
      }
      if (s < t) for (let e = 0; e < t - s - i; e++) n.push("e");
      return n;
    }
    function M(t) {
      const e = t.position && "$graveyard" == t.position.root.rootName,
        n = t.range && "$graveyard" == t.range.root.rootName;
      return !e && !n;
    }
    var V = n(265),
      N = n(51),
      B = n(11),
      D = n(6);
    function F(t, e) {
      return (
        !!(n = t.charAt(e - 1)) &&
        1 == n.length &&
        /[\ud800-\udbff]/.test(n) &&
        (function (t) {
          return !!t && 1 == t.length && /[\udc00-\udfff]/.test(t);
        })(t.charAt(e))
      );
      var n;
    }
    function z(t, e) {
      return (
        !!(n = t.charAt(e)) &&
        1 == n.length &&
        /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(
          n
        )
      );
      var n;
    }
    var L = n(355);
    class H {
      constructor(t) {
        (this.model = t),
          (this.version = 0),
          (this.history = new V.a(this)),
          (this.selection = new k.a(this)),
          (this.roots = new N.default({ idProperty: "rootName" })),
          (this.differ = new I(t.markers)),
          (this._postFixers = new Set()),
          (this._hasSelectionChangedFromTheLastChangeBlock = !1),
          this.createRoot("$root", "$graveyard"),
          this.listenTo(
            t,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              if (n.isDocumentOperation && n.baseVersion !== this.version)
                throw new c.default(
                  "model-document-applyoperation-wrong-version",
                  this,
                  { operation: n }
                );
            },
            { priority: "highest" }
          ),
          this.listenTo(
            t,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              n.isDocumentOperation && this.differ.bufferOperation(n);
            },
            { priority: "high" }
          ),
          this.listenTo(
            t,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              n.isDocumentOperation &&
                (this.version++, this.history.addOperation(n));
            },
            { priority: "low" }
          ),
          this.listenTo(this.selection, "change", () => {
            this._hasSelectionChangedFromTheLastChangeBlock = !0;
          }),
          this.listenTo(t.markers, "update", (t, e, n, i) => {
            this.differ.bufferMarkerChange(e.name, n, i, e.affectsData),
              null === n &&
                e.on("change", (t, n) => {
                  this.differ.bufferMarkerChange(
                    e.name,
                    n,
                    e.getRange(),
                    e.affectsData
                  );
                });
          });
      }
      get graveyard() {
        return this.getRoot("$graveyard");
      }
      createRoot(t = "$root", e = "main") {
        if (this.roots.get(e))
          throw new c.default("model-document-createroot-name-exists", this, {
            name: e,
          });
        const n = new _(this, t, e);
        return this.roots.add(n), n;
      }
      destroy() {
        this.selection.destroy(), this.stopListening();
      }
      getRoot(t = "main") {
        return this.roots.get(t);
      }
      getRootNames() {
        return Array.from(this.roots, (t) => t.rootName).filter(
          (t) => "$graveyard" != t
        );
      }
      registerPostFixer(t) {
        this._postFixers.add(t);
      }
      toJSON() {
        const t = Object(L.a)(this);
        return (
          (t.selection = "[engine.model.DocumentSelection]"),
          (t.model = "[engine.model.Model]"),
          t
        );
      }
      _handleChangeBlock(t) {
        this._hasDocumentChangedFromTheLastChangeBlock() &&
          (this._callPostFixers(t),
          this.selection.refresh(),
          this.differ.hasDataChanges()
            ? this.fire("change:data", t.batch)
            : this.fire("change", t.batch),
          this.selection.refresh(),
          this.differ.reset()),
          (this._hasSelectionChangedFromTheLastChangeBlock = !1);
      }
      _hasDocumentChangedFromTheLastChangeBlock() {
        return (
          !this.differ.isEmpty ||
          this._hasSelectionChangedFromTheLastChangeBlock
        );
      }
      _getDefaultRoot() {
        for (const t of this.roots) if (t !== this.graveyard) return t;
        return this.graveyard;
      }
      _getDefaultRange() {
        const t = this._getDefaultRoot(),
          e = this.model,
          n = e.schema,
          i = e.createPositionFromPath(t, [0]);
        return n.getNearestSelectionRange(i) || e.createRange(i);
      }
      _validateSelectionRange(t) {
        return W(t.start) && W(t.end);
      }
      _callPostFixers(t) {
        let e = !1;
        do {
          for (const n of this._postFixers)
            if ((this.selection.refresh(), (e = n(t)), e)) break;
        } while (e);
      }
    }
    function W(t) {
      const e = t.textNode;
      if (e) {
        const n = e.data,
          i = t.offset - e.startOffset;
        return !F(n, i) && !z(n, i);
      }
      return !0;
    }
    Object(D.default)(H, B.default);
    var q = n(89);
    class $ {
      constructor() {
        this._markers = new Map();
      }
      [Symbol.iterator]() {
        return this._markers.values();
      }
      has(t) {
        const e = t instanceof U ? t.name : t;
        return this._markers.has(e);
      }
      get(t) {
        return this._markers.get(t) || null;
      }
      _set(t, e, n = !1, i = !1) {
        const s = t instanceof U ? t.name : t;
        if (s.includes(","))
          throw new c.default("markercollection-incorrect-marker-name", this);
        const o = this._markers.get(s);
        if (o) {
          const t = o.getRange();
          let r = !1;
          return (
            t.isEqual(e) || (o._attachLiveRange(q.a.fromRange(e)), (r = !0)),
            n != o.managedUsingOperations &&
              ((o._managedUsingOperations = n), (r = !0)),
            "boolean" == typeof i &&
              i != o.affectsData &&
              ((o._affectsData = i), (r = !0)),
            r && this.fire("update:" + s, o, t, e),
            o
          );
        }
        const r = q.a.fromRange(e),
          a = new U(s, r, n, i);
        return this._markers.set(s, a), this.fire("update:" + s, a, null, e), a;
      }
      _remove(t) {
        const e = t instanceof U ? t.name : t,
          n = this._markers.get(e);
        return (
          !!n &&
          (this._markers.delete(e),
          this.fire("update:" + e, n, n.getRange(), null),
          this._destroyMarker(n),
          !0)
        );
      }
      _refresh(t) {
        const e = t instanceof U ? t.name : t,
          n = this._markers.get(e);
        if (!n)
          throw new c.default(
            "markercollection-refresh-marker-not-exists",
            this
          );
        const i = n.getRange();
        this.fire(
          "update:" + e,
          n,
          i,
          i,
          n.managedUsingOperations,
          n.affectsData
        );
      }
      *getMarkersAtPosition(t) {
        for (const e of this) e.getRange().containsPosition(t) && (yield e);
      }
      *getMarkersIntersectingRange(t) {
        for (const e of this)
          null !== e.getRange().getIntersection(t) && (yield e);
      }
      destroy() {
        for (const t of this._markers.values()) this._destroyMarker(t);
        (this._markers = null), this.stopListening();
      }
      *getMarkersGroup(t) {
        for (const e of this._markers.values())
          e.name.startsWith(t + ":") && (yield e);
      }
      _destroyMarker(t) {
        t.stopListening(), t._detachLiveRange();
      }
    }
    Object(D.default)($, B.default);
    class U {
      constructor(t, e, n, i) {
        (this.name = t),
          (this._liveRange = this._attachLiveRange(e)),
          (this._managedUsingOperations = n),
          (this._affectsData = i);
      }
      get managedUsingOperations() {
        if (!this._liveRange) throw new c.default("marker-destroyed", this);
        return this._managedUsingOperations;
      }
      get affectsData() {
        if (!this._liveRange) throw new c.default("marker-destroyed", this);
        return this._affectsData;
      }
      getStart() {
        if (!this._liveRange) throw new c.default("marker-destroyed", this);
        return this._liveRange.start.clone();
      }
      getEnd() {
        if (!this._liveRange) throw new c.default("marker-destroyed", this);
        return this._liveRange.end.clone();
      }
      getRange() {
        if (!this._liveRange) throw new c.default("marker-destroyed", this);
        return this._liveRange.toRange();
      }
      is(t) {
        return "marker" === t || "model:marker" === t;
      }
      _attachLiveRange(t) {
        return (
          this._liveRange && this._detachLiveRange(),
          t.delegate("change:range").to(this),
          t.delegate("change:content").to(this),
          (this._liveRange = t),
          t
        );
      }
      _detachLiveRange() {
        this._liveRange.stopDelegating("change:range", this),
          this._liveRange.stopDelegating("change:content", this),
          this._liveRange.detach(),
          (this._liveRange = null);
      }
    }
    Object(D.default)(U, B.default);
    var K = n(14),
      G = n(92),
      J = n(191),
      Q = n(55);
    class Y {
      constructor(t, e, n) {
        (this.model = t),
          (this.writer = e),
          (this.position = n),
          (this.canMergeWith = new Set([this.position.parent])),
          (this.schema = t.schema),
          (this._documentFragment = e.createDocumentFragment()),
          (this._documentFragmentPosition = e.createPositionAt(
            this._documentFragment,
            0
          )),
          (this._firstNode = null),
          (this._lastNode = null),
          (this._lastAutoParagraph = null),
          (this._filterAttributesOf = []),
          (this._affectedStart = null),
          (this._affectedEnd = null);
      }
      handleNodes(t) {
        for (const e of Array.from(t)) this._handleNode(e);
        this._insertPartialFragment(),
          this._lastAutoParagraph &&
            this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph),
          this._mergeOnRight(),
          this.schema.removeDisallowedAttributes(
            this._filterAttributesOf,
            this.writer
          ),
          (this._filterAttributesOf = []);
      }
      _updateLastNodeFromAutoParagraph(t) {
        const e = this.writer.createPositionAfter(this._lastNode),
          n = this.writer.createPositionAfter(t);
        if (n.isAfter(e)) {
          if (
            ((this._lastNode = t),
            this.position.parent != t || !this.position.isAtEnd)
          )
            throw new c.default(
              "insertcontent-invalid-insertion-position",
              this
            );
          (this.position = n), this._setAffectedBoundaries(this.position);
        }
      }
      getSelectionRange() {
        return this.nodeToSelect
          ? r.a._createOn(this.nodeToSelect)
          : this.model.schema.getNearestSelectionRange(this.position);
      }
      getAffectedRange() {
        return this._affectedStart
          ? new r.a(this._affectedStart, this._affectedEnd)
          : null;
      }
      destroy() {
        this._affectedStart && this._affectedStart.detach(),
          this._affectedEnd && this._affectedEnd.detach();
      }
      _handleNode(t) {
        if (this.schema.isObject(t)) return void this._handleObject(t);
        let e = this._checkAndAutoParagraphToAllowedPosition(t);
        e || ((e = this._checkAndSplitToAllowedPosition(t)), e)
          ? (this._appendToFragment(t),
            this._firstNode || (this._firstNode = t),
            (this._lastNode = t))
          : this._handleDisallowedNode(t);
      }
      _insertPartialFragment() {
        if (this._documentFragment.isEmpty) return;
        const t = Q.a.fromPosition(this.position, "toNext");
        this._setAffectedBoundaries(this.position),
          this._documentFragment.getChild(0) == this._firstNode &&
            (this.writer.insert(this._firstNode, this.position),
            this._mergeOnLeft(),
            (this.position = t.toPosition())),
          this._documentFragment.isEmpty ||
            this.writer.insert(this._documentFragment, this.position),
          (this._documentFragmentPosition = this.writer.createPositionAt(
            this._documentFragment,
            0
          )),
          (this.position = t.toPosition()),
          t.detach();
      }
      _handleObject(t) {
        this._checkAndSplitToAllowedPosition(t)
          ? this._appendToFragment(t)
          : this._tryAutoparagraphing(t);
      }
      _handleDisallowedNode(t) {
        t.is("element")
          ? this.handleNodes(t.getChildren())
          : this._tryAutoparagraphing(t);
      }
      _appendToFragment(t) {
        if (!this.schema.checkChild(this.position, t))
          throw new c.default("insertcontent-wrong-position", this, {
            node: t,
            position: this.position,
          });
        this.writer.insert(t, this._documentFragmentPosition),
          (this._documentFragmentPosition =
            this._documentFragmentPosition.getShiftedBy(t.offsetSize)),
          this.schema.isObject(t) &&
          !this.schema.checkChild(this.position, "$text")
            ? (this.nodeToSelect = t)
            : (this.nodeToSelect = null),
          this._filterAttributesOf.push(t);
      }
      _setAffectedBoundaries(t) {
        this._affectedStart ||
          (this._affectedStart = Q.a.fromPosition(t, "toPrevious")),
          (this._affectedEnd && !this._affectedEnd.isBefore(t)) ||
            (this._affectedEnd && this._affectedEnd.detach(),
            (this._affectedEnd = Q.a.fromPosition(t, "toNext")));
      }
      _mergeOnLeft() {
        const t = this._firstNode;
        if (!(t instanceof v.a)) return;
        if (!this._canMergeLeft(t)) return;
        const e = Q.a._createBefore(t);
        e.stickiness = "toNext";
        const n = Q.a.fromPosition(this.position, "toNext");
        this._affectedStart.isEqual(e) &&
          (this._affectedStart.detach(),
          (this._affectedStart = Q.a._createAt(
            e.nodeBefore,
            "end",
            "toPrevious"
          ))),
          this._firstNode === this._lastNode &&
            ((this._firstNode = e.nodeBefore), (this._lastNode = e.nodeBefore)),
          this.writer.merge(e),
          e.isEqual(this._affectedEnd) &&
            this._firstNode === this._lastNode &&
            (this._affectedEnd.detach(),
            (this._affectedEnd = Q.a._createAt(e.nodeBefore, "end", "toNext"))),
          (this.position = n.toPosition()),
          n.detach(),
          this._filterAttributesOf.push(this.position.parent),
          e.detach();
      }
      _mergeOnRight() {
        const t = this._lastNode;
        if (!(t instanceof v.a)) return;
        if (!this._canMergeRight(t)) return;
        const e = Q.a._createAfter(t);
        if (((e.stickiness = "toNext"), !this.position.isEqual(e)))
          throw new c.default("insertcontent-invalid-insertion-position", this);
        this.position = y.a._createAt(e.nodeBefore, "end");
        const n = Q.a.fromPosition(this.position, "toPrevious");
        this._affectedEnd.isEqual(e) &&
          (this._affectedEnd.detach(),
          (this._affectedEnd = Q.a._createAt(e.nodeBefore, "end", "toNext"))),
          this._firstNode === this._lastNode &&
            ((this._firstNode = e.nodeBefore), (this._lastNode = e.nodeBefore)),
          this.writer.merge(e),
          e.getShiftedBy(-1).isEqual(this._affectedStart) &&
            this._firstNode === this._lastNode &&
            (this._affectedStart.detach(),
            (this._affectedStart = Q.a._createAt(
              e.nodeBefore,
              0,
              "toPrevious"
            ))),
          (this.position = n.toPosition()),
          n.detach(),
          this._filterAttributesOf.push(this.position.parent),
          e.detach();
      }
      _canMergeLeft(t) {
        const e = t.previousSibling;
        return (
          e instanceof v.a &&
          this.canMergeWith.has(e) &&
          this.model.schema.checkMerge(e, t)
        );
      }
      _canMergeRight(t) {
        const e = t.nextSibling;
        return (
          e instanceof v.a &&
          this.canMergeWith.has(e) &&
          this.model.schema.checkMerge(t, e)
        );
      }
      _tryAutoparagraphing(t) {
        const e = this.writer.createElement("paragraph");
        this._getAllowedIn(this.position.parent, e) &&
          this.schema.checkChild(e, t) &&
          (e._appendChild(t), this._handleNode(e));
      }
      _checkAndAutoParagraphToAllowedPosition(t) {
        if (this.schema.checkChild(this.position.parent, t)) return !0;
        if (
          !this.schema.checkChild(this.position.parent, "paragraph") ||
          !this.schema.checkChild("paragraph", t)
        )
          return !1;
        this._insertPartialFragment();
        const e = this.writer.createElement("paragraph");
        return (
          this.writer.insert(e, this.position),
          this._setAffectedBoundaries(this.position),
          (this._lastAutoParagraph = e),
          (this.position = this.writer.createPositionAt(e, 0)),
          !0
        );
      }
      _checkAndSplitToAllowedPosition(t) {
        const e = this._getAllowedIn(this.position.parent, t);
        if (!e) return !1;
        for (
          e != this.position.parent && this._insertPartialFragment();
          e != this.position.parent;

        )
          if (this.position.isAtStart) {
            const t = this.position.parent;
            (this.position = this.writer.createPositionBefore(t)),
              t.isEmpty && t.parent === e && this.writer.remove(t);
          } else if (this.position.isAtEnd)
            this.position = this.writer.createPositionAfter(
              this.position.parent
            );
          else {
            const t = this.writer.createPositionAfter(this.position.parent);
            this._setAffectedBoundaries(this.position),
              this.writer.split(this.position),
              (this.position = t),
              this.canMergeWith.add(this.position.nodeAfter);
          }
        return !0;
      }
      _getAllowedIn(t, e) {
        return this.schema.checkChild(t, e)
          ? t
          : this.schema.isLimit(t)
          ? null
          : this._getAllowedIn(t.parent, e);
      }
    }
    function X(t, e, n = {}) {
      if (e.isCollapsed) return;
      const i = e.getFirstRange();
      if ("$graveyard" == i.root.rootName) return;
      const s = t.schema;
      t.change((t) => {
        if (
          !n.doNotResetEntireContent &&
          (function (t, e) {
            const n = t.getLimitElement(e);
            if (!e.containsEntireContent(n)) return !1;
            const i = e.getFirstRange();
            if (i.start.parent == i.end.parent) return !1;
            return t.checkChild(n, "paragraph");
          })(s, e)
        )
          return void (function (t, e) {
            const n = t.model.schema.getLimitElement(e);
            t.remove(t.createRangeIn(n)), tt(t, t.createPositionAt(n, 0), e);
          })(t, e);
        const [o, r] = (function (t) {
          const e = t.root.document.model,
            n = t.start;
          let i = t.end;
          if (e.hasContent(t, { ignoreMarkers: !0 })) {
            const n = (function (t) {
              const e = t.parent,
                n = e.root.document.model.schema,
                i = e.getAncestors({ parentFirst: !0, includeSelf: !0 });
              for (const t of i) {
                if (n.isLimit(t)) return null;
                if (n.isBlock(t)) return t;
              }
            })(i);
            if (n && i.isTouching(e.createPositionAt(n, 0))) {
              const n = e.createSelection(t);
              e.modifySelection(n, { direction: "backward" });
              const s = n.getLastPosition(),
                o = e.createRange(s, i);
              e.hasContent(o, { ignoreMarkers: !0 }) || (i = s);
            }
          }
          return [
            Q.a.fromPosition(n, "toPrevious"),
            Q.a.fromPosition(i, "toNext"),
          ];
        })(i);
        o.isTouching(r) || t.remove(t.createRange(o, r)),
          n.leaveUnmerged ||
            (!(function (t, e, n) {
              const i = t.model;
              if (!Z(t.model.schema, e, n)) return;
              const [s, o] = (function (t, e) {
                const n = t.getAncestors(),
                  i = e.getAncestors();
                let s = 0;
                for (; n[s] && n[s] == i[s]; ) s++;
                return [n[s], i[s]];
              })(e, n);
              if (!s || !o) return;
              !i.hasContent(s, { ignoreMarkers: !0 }) &&
              i.hasContent(o, { ignoreMarkers: !0 })
                ? (function t(e, n, i, s) {
                    const o = n.parent,
                      r = i.parent;
                    if (o == s || r == s) return;
                    (n = e.createPositionAfter(o)),
                      (i = e.createPositionBefore(r)).isEqual(n) ||
                        e.insert(o, i);
                    for (; n.parent.isEmpty; ) {
                      const t = n.parent;
                      (n = e.createPositionBefore(t)), e.remove(t);
                    }
                    if (
                      ((i = e.createPositionBefore(r)),
                      (function (t, e) {
                        const n = e.nodeBefore,
                          i = e.nodeAfter;
                        n.name != i.name && t.rename(n, i.name);
                        t.clearAttributes(n),
                          t.setAttributes(
                            Object.fromEntries(i.getAttributes()),
                            n
                          ),
                          t.merge(e);
                      })(e, i),
                      !Z(e.model.schema, n, i))
                    )
                      return;
                    t(e, n, i, s);
                  })(t, e, n, s.parent)
                : (function t(e, n, i, s) {
                    const o = n.parent,
                      r = i.parent;
                    if (o == s || r == s) return;
                    (n = e.createPositionAfter(o)),
                      (i = e.createPositionBefore(r)).isEqual(n) ||
                        e.insert(r, n);
                    e.merge(n);
                    for (; i.parent.isEmpty; ) {
                      const t = i.parent;
                      (i = e.createPositionBefore(t)), e.remove(t);
                    }
                    if (!Z(e.model.schema, n, i)) return;
                    t(e, n, i, s);
                  })(t, e, n, s.parent);
            })(t, o, r),
            s.removeDisallowedAttributes(o.parent.getChildren(), t)),
          et(t, e, o),
          !n.doNotAutoparagraph &&
            (function (t, e) {
              const n = t.checkChild(e, "$text"),
                i = t.checkChild(e, "paragraph");
              return !n && i;
            })(s, o) &&
            tt(t, o, e),
          o.detach(),
          r.detach();
      });
    }
    function Z(t, e, n) {
      const i = e.parent,
        s = n.parent;
      return (
        i != s &&
        !t.isLimit(i) &&
        !t.isLimit(s) &&
        (function (t, e, n) {
          const i = new r.a(t, e);
          for (const t of i.getWalker()) if (n.isLimit(t.item)) return !1;
          return !0;
        })(e, n, t)
      );
    }
    function tt(t, e, n) {
      const i = t.createElement("paragraph");
      t.insert(i, e), et(t, n, t.createPositionAt(i, 0));
    }
    function et(t, e, n) {
      e instanceof k.a ? t.setSelection(n) : e.setTo(n);
    }
    var nt = n(71);
    function it(t, e) {
      const { isForward: n, walker: i, unit: s, schema: o } = t,
        { type: r, item: a, nextPosition: c } = e;
      if ("text" == r)
        return "word" === t.unit
          ? (function (t, e) {
              let n = t.position.textNode;
              if (n) {
                let i = t.position.offset - n.startOffset;
                for (; !ot(n.data, i, e) && !rt(n, i, e); ) {
                  t.next();
                  const s = e ? t.position.nodeAfter : t.position.nodeBefore;
                  if (s && s.is("$text")) {
                    const i = s.data.charAt(e ? 0 : s.data.length - 1);
                    ' ,.?!:;"-()'.includes(i) ||
                      (t.next(), (n = t.position.textNode));
                  }
                  i = t.position.offset - n.startOffset;
                }
              }
              return t.position;
            })(i, n)
          : (function (t, e) {
              const n = t.position.textNode;
              if (n) {
                const i = n.data;
                let s = t.position.offset - n.startOffset;
                for (; F(i, s) || ("character" == e && z(i, s)); )
                  t.next(), (s = t.position.offset - n.startOffset);
              }
              return t.position;
            })(i, s);
      if (r == (n ? "elementStart" : "elementEnd")) {
        if (o.isSelectable(a)) return y.a._createAt(a, n ? "after" : "before");
        if (o.checkChild(c, "$text")) return c;
      } else {
        if (o.isLimit(a)) return void i.skip(() => !0);
        if (o.checkChild(c, "$text")) return c;
      }
    }
    function st(t, e) {
      const n = t.root,
        i = y.a._createAt(n, e ? "end" : 0);
      return e ? new r.a(t, i) : new r.a(i, t);
    }
    function ot(t, e, n) {
      const i = e + (n ? 0 : -1);
      return ' ,.?!:;"-()'.includes(t.charAt(i));
    }
    function rt(t, e, n) {
      return e === (n ? t.endOffset : 0);
    }
    function at(t, e) {
      const n = [];
      Array.from(t.getItems({ direction: "backward" }))
        .map((t) => e.createRangeOn(t))
        .filter(
          (e) =>
            (e.start.isAfter(t.start) || e.start.isEqual(t.start)) &&
            (e.end.isBefore(t.end) || e.end.isEqual(t.end))
        )
        .forEach((t) => {
          n.push(t.start.parent), e.remove(t);
        }),
        n.forEach((t) => {
          let n = t;
          for (; n.parent && n.isEmpty; ) {
            const t = e.createRangeOn(n);
            (n = n.parent), e.remove(t);
          }
        });
    }
    function ct(t) {
      t.document.registerPostFixer((e) =>
        (function (t, e) {
          const n = e.document.selection,
            i = e.schema,
            s = [];
          let o = !1;
          for (const t of n.getRanges()) {
            const e = lt(t, i);
            e && !e.isEqual(t) ? (s.push(e), (o = !0)) : s.push(t);
          }
          o &&
            t.setSelection(
              (function (t) {
                const e = [...t],
                  n = new Set();
                let i = 1;
                for (; i < e.length; ) {
                  const t = e[i],
                    s = e.slice(0, i);
                  for (const [o, r] of s.entries())
                    if (!n.has(o))
                      if (t.isEqual(r)) n.add(o);
                      else if (t.isIntersecting(r)) {
                        n.add(o), n.add(i);
                        const s = t.getJoined(r);
                        e.push(s);
                      }
                  i++;
                }
                return e.filter((t, e) => !n.has(e));
              })(s),
              { backward: n.isBackward }
            );
        })(e, t)
      );
    }
    function lt(t, e) {
      return t.isCollapsed
        ? (function (t, e) {
            const n = t.start,
              i = e.getNearestSelectionRange(n);
            if (!i) {
              const t = n
                .getAncestors()
                .reverse()
                .find((t) => e.isObject(t));
              return t ? r.a._createOn(t) : null;
            }
            if (!i.isCollapsed) return i;
            const s = i.start;
            if (n.isEqual(s)) return null;
            return new r.a(s);
          })(t, e)
        : (function (t, e) {
            const { start: n, end: i } = t,
              s = e.checkChild(n, "$text"),
              o = e.checkChild(i, "$text"),
              a = e.getLimitElement(n),
              c = e.getLimitElement(i);
            if (a === c) {
              if (s && o) return null;
              if (
                (function (t, e, n) {
                  const i =
                      (t.nodeAfter && !n.isLimit(t.nodeAfter)) ||
                      n.checkChild(t, "$text"),
                    s =
                      (e.nodeBefore && !n.isLimit(e.nodeBefore)) ||
                      n.checkChild(e, "$text");
                  return i || s;
                })(n, i, e)
              ) {
                const t =
                    n.nodeAfter && e.isSelectable(n.nodeAfter)
                      ? null
                      : e.getNearestSelectionRange(n, "forward"),
                  s =
                    i.nodeBefore && e.isSelectable(i.nodeBefore)
                      ? null
                      : e.getNearestSelectionRange(i, "backward"),
                  o = t ? t.start : n,
                  a = s ? s.end : i;
                return new r.a(o, a);
              }
            }
            const l = a && !a.is("rootElement"),
              u = c && !c.is("rootElement");
            if (l || u) {
              const t =
                  n.nodeAfter &&
                  i.nodeBefore &&
                  n.nodeAfter.parent === i.nodeBefore.parent,
                s = l && (!t || !dt(n.nodeAfter, e)),
                o = u && (!t || !dt(i.nodeBefore, e));
              let d = n,
                h = i;
              return (
                s && (d = y.a._createBefore(ut(a, e))),
                o && (h = y.a._createAfter(ut(c, e))),
                new r.a(d, h)
              );
            }
            return null;
          })(t, e);
    }
    function ut(t, e) {
      let n = t,
        i = n;
      for (; e.isLimit(i) && i.parent; ) (n = i), (i = i.parent);
      return n;
    }
    function dt(t, e) {
      return t && e.isSelectable(t);
    }
    var ht = n(93);
    class ft {
      constructor() {
        (this.markers = new $()),
          (this.document = new H(this)),
          (this.schema = new S.b()),
          (this._pendingChanges = []),
          (this._currentWriter = null),
          [
            "insertContent",
            "deleteContent",
            "modifySelection",
            "getSelectedContent",
            "applyOperation",
          ].forEach((t) => this.decorate(t)),
          this.on(
            "applyOperation",
            (t, e) => {
              e[0]._validate();
            },
            { priority: "highest" }
          ),
          this.schema.register("$root", { isLimit: !0 }),
          this.schema.register("$block", { allowIn: "$root", isBlock: !0 }),
          this.schema.register("$text", {
            allowIn: "$block",
            isInline: !0,
            isContent: !0,
          }),
          this.schema.register("$clipboardHolder", {
            allowContentOf: "$root",
            allowChildren: "$text",
            isLimit: !0,
          }),
          this.schema.register("$documentFragment", {
            allowContentOf: "$root",
            allowChildren: "$text",
            isLimit: !0,
          }),
          this.schema.register("$marker"),
          this.schema.addChildCheck((t, e) => {
            if ("$marker" === e.name) return !0;
          }),
          ct(this),
          this.document.registerPostFixer(ht.a);
      }
      change(t) {
        try {
          return 0 === this._pendingChanges.length
            ? (this._pendingChanges.push({ batch: new i(), callback: t }),
              this._runPendingChanges()[0])
            : t(this._currentWriter);
        } catch (t) {
          c.default.rethrowUnexpectedError(t, this);
        }
      }
      enqueueChange(t, e) {
        try {
          "string" == typeof t
            ? (t = new i(t))
            : "function" == typeof t && ((e = t), (t = new i())),
            this._pendingChanges.push({ batch: t, callback: e }),
            1 == this._pendingChanges.length && this._runPendingChanges();
        } catch (t) {
          c.default.rethrowUnexpectedError(t, this);
        }
      }
      applyOperation(t) {
        t._execute();
      }
      insertContent(t, e, n) {
        return (function (t, e, n, i) {
          return t.change((s) => {
            let o;
            (o = n
              ? n instanceof G.a || n instanceof k.a
                ? n
                : s.createSelection(n, i)
              : t.document.selection),
              o.isCollapsed || t.deleteContent(o, { doNotAutoparagraph: !0 });
            const r = new Y(t, s, o.anchor);
            let a;
            (a = e.is("documentFragment") ? e.getChildren() : [e]),
              r.handleNodes(a);
            const c = r.getSelectionRange();
            c && (o instanceof k.a ? s.setSelection(c) : o.setTo(c));
            const l = r.getAffectedRange() || t.createRange(o.anchor);
            return r.destroy(), l;
          });
        })(this, t, e, n);
      }
      deleteContent(t, e) {
        X(this, t, e);
      }
      modifySelection(t, e) {
        !(function (t, e, n = {}) {
          const i = t.schema,
            s = "backward" != n.direction,
            o = n.unit ? n.unit : "character",
            r = e.focus,
            a = new nt.a({
              boundaries: st(r, s),
              singleCharacters: !0,
              direction: s ? "forward" : "backward",
            }),
            c = { walker: a, schema: i, isForward: s, unit: o };
          let l;
          for (; (l = a.next()); ) {
            if (l.done) return;
            const n = it(c, l.value);
            if (n)
              return void (e instanceof k.a
                ? t.change((t) => {
                    t.setSelectionFocus(n);
                  })
                : e.setFocus(n));
          }
        })(this, t, e);
      }
      getSelectedContent(t) {
        return (function (t, e) {
          return t.change((t) => {
            const n = t.createDocumentFragment(),
              i = e.getFirstRange();
            if (!i || i.isCollapsed) return n;
            const s = i.start.root,
              o = i.start.getCommonPath(i.end),
              r = s.getNodeByPath(o);
            let a;
            a =
              i.start.parent == i.end.parent
                ? i
                : t.createRange(
                    t.createPositionAt(r, i.start.path[o.length]),
                    t.createPositionAt(r, i.end.path[o.length] + 1)
                  );
            const c = a.end.offset - a.start.offset;
            for (const e of a.getItems({ shallow: !0 }))
              e.is("$textProxy")
                ? t.appendText(e.data, e.getAttributes(), n)
                : t.append(t.cloneElement(e, !0), n);
            if (a != i) {
              const e = i._getTransformedByMove(
                  a.start,
                  t.createPositionAt(n, 0),
                  c
                )[0],
                s = t.createRange(t.createPositionAt(n, 0), e.start);
              at(t.createRange(e.end, t.createPositionAt(n, "end")), t),
                at(s, t);
            }
            return n;
          });
        })(this, t);
      }
      hasContent(t, e = {}) {
        const n = t instanceof v.a ? r.a._createIn(t) : t;
        if (n.isCollapsed) return !1;
        const { ignoreWhitespaces: i = !1, ignoreMarkers: s = !1 } = e;
        if (!s)
          for (const t of this.markers.getMarkersIntersectingRange(n))
            if (t.affectsData) return !0;
        for (const t of n.getItems())
          if (this.schema.isContent(t)) {
            if (!t.is("$textProxy")) return !0;
            if (!i) return !0;
            if (-1 !== t.data.search(/\S/)) return !0;
          }
        return !1;
      }
      createPositionFromPath(t, e, n) {
        return new y.a(t, e, n);
      }
      createPositionAt(t, e) {
        return y.a._createAt(t, e);
      }
      createPositionAfter(t) {
        return y.a._createAfter(t);
      }
      createPositionBefore(t) {
        return y.a._createBefore(t);
      }
      createRange(t, e) {
        return new r.a(t, e);
      }
      createRangeIn(t) {
        return r.a._createIn(t);
      }
      createRangeOn(t) {
        return r.a._createOn(t);
      }
      createSelection(t, e, n) {
        return new G.a(t, e, n);
      }
      createBatch(t) {
        return new i(t);
      }
      createOperationFromJSON(t) {
        return J.a.fromJSON(t, this.document);
      }
      destroy() {
        this.document.destroy(), this.stopListening();
      }
      _runPendingChanges() {
        const t = [];
        for (this.fire("_beforeChanges"); this._pendingChanges.length; ) {
          const e = this._pendingChanges[0].batch;
          this._currentWriter = new C(this, e);
          const n = this._pendingChanges[0].callback(this._currentWriter);
          t.push(n),
            this.document._handleChangeBlock(this._currentWriter),
            this._pendingChanges.shift(),
            (this._currentWriter = null);
        }
        return this.fire("_afterChanges"), t;
      }
    }
    Object(D.default)(ft, K.default);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return L;
    });
    var i = n(152);
    const s = Symbol("rootName");
    class o extends i.a {
      constructor(t, e) {
        super(t, e), (this.rootName = "main");
      }
      is(t, e = null) {
        return e
          ? e === this.name &&
              ("rootElement" === t ||
                "view:rootElement" === t ||
                "editableElement" === t ||
                "view:editableElement" === t ||
                "containerElement" === t ||
                "view:containerElement" === t ||
                "element" === t ||
                "view:element" === t)
          : "rootElement" === t ||
              "view:rootElement" === t ||
              "editableElement" === t ||
              "view:editableElement" === t ||
              "containerElement" === t ||
              "view:containerElement" === t ||
              "element" === t ||
              "view:element" === t ||
              "node" === t ||
              "view:node" === t;
      }
      get rootName() {
        return this.getCustomProperty(s);
      }
      set rootName(t) {
        this._setCustomProperty(s, t);
      }
      set _name(t) {
        this.name = t;
      }
    }
    var r = n(145),
      a = n(144),
      c = n(202),
      l = n(110),
      u = n(7),
      d = n(15),
      h = n(62),
      f = n(58),
      m = n(22),
      g = n(226);
    var p = function (t, e, n) {
      var i = (n = "function" == typeof n ? n : void 0) ? n(t, e) : void 0;
      return void 0 === i ? Object(g.a)(t, e, void 0, n) : !!i;
    };
    class b extends f.a {
      constructor(t) {
        super(t),
          (this._config = {
            childList: !0,
            characterData: !0,
            characterDataOldValue: !0,
            subtree: !0,
          }),
          (this.domConverter = t.domConverter),
          (this.renderer = t._renderer),
          (this._domElements = []),
          (this._mutationObserver = new window.MutationObserver(
            this._onMutations.bind(this)
          ));
      }
      flush() {
        this._onMutations(this._mutationObserver.takeRecords());
      }
      observe(t) {
        this._domElements.push(t),
          this.isEnabled && this._mutationObserver.observe(t, this._config);
      }
      enable() {
        super.enable();
        for (const t of this._domElements)
          this._mutationObserver.observe(t, this._config);
      }
      disable() {
        super.disable(), this._mutationObserver.disconnect();
      }
      destroy() {
        super.destroy(), this._mutationObserver.disconnect();
      }
      _onMutations(t) {
        if (0 === t.length) return;
        const e = this.domConverter,
          n = new Map(),
          i = new Set();
        for (const n of t)
          if ("childList" === n.type) {
            const t = e.mapDomToView(n.target);
            if (t && (t.is("uiElement") || t.is("rawElement"))) continue;
            t && !this._isBogusBrMutation(n) && i.add(t);
          }
        for (const s of t) {
          const t = e.mapDomToView(s.target);
          if (
            (!t || (!t.is("uiElement") && !t.is("rawElement"))) &&
            "characterData" === s.type
          ) {
            const t = e.findCorrespondingViewText(s.target);
            t && !i.has(t.parent)
              ? n.set(t, {
                  type: "text",
                  oldText: t.data,
                  newText: Object(m.f)(s.target),
                  node: t,
                })
              : !t &&
                Object(m.i)(s.target) &&
                i.add(e.mapDomToView(s.target.parentNode));
          }
        }
        const s = [];
        for (const t of n.values())
          this.renderer.markToSync("text", t.node), s.push(t);
        for (const t of i) {
          const n = e.mapViewToDom(t),
            i = Array.from(t.getChildren()),
            o = Array.from(e.domChildrenToView(n, { withChildren: !1 }));
          p(i, o, a) ||
            (this.renderer.markToSync("children", t),
            s.push({
              type: "children",
              oldChildren: i,
              newChildren: o,
              node: t,
            }));
        }
        const o = t[0].target.ownerDocument.getSelection();
        let r = null;
        if (o && o.anchorNode) {
          const t = e.domPositionToView(o.anchorNode, o.anchorOffset),
            n = e.domPositionToView(o.focusNode, o.focusOffset);
          t && n && ((r = new h.a(t)), r.setFocus(n));
        }
        function a(t, e) {
          if (!Array.isArray(t))
            return (
              t === e ||
              (!(!t.is("$text") || !e.is("$text")) && t.data === e.data)
            );
        }
        s.length &&
          (this.document.fire("mutations", s, r), this.view.forceRender());
      }
      _isBogusBrMutation(t) {
        let e = null;
        return (
          null === t.nextSibling &&
            0 === t.removedNodes.length &&
            1 == t.addedNodes.length &&
            (e = this.domConverter.domToView(t.addedNodes[0], {
              withChildren: !1,
            })),
          e && e.is("element", "br")
        );
      }
    }
    var w = n(59),
      v = n(12);
    class _ extends w.a {
      constructor(t) {
        super(t), (this.domEventType = ["keydown", "keyup"]);
      }
      onDomEvent(t) {
        this.fire(t.type, t, {
          keyCode: t.keyCode,
          altKey: t.altKey,
          ctrlKey: t.ctrlKey,
          shiftKey: t.shiftKey,
          metaKey: t.metaKey,
          get keystroke() {
            return Object(v.a)(this);
          },
        });
      }
    }
    var y = n(261);
    class k extends f.a {
      constructor(t) {
        super(t),
          (this._fireSelectionChangeDoneDebounced = Object(y.a)(
            (t) => this.document.fire("selectionChangeDone", t),
            200
          ));
      }
      observe() {
        const t = this.document;
        t.on(
          "arrowKey",
          (e, n) => {
            t.selection.isFake && this.isEnabled && n.preventDefault();
          },
          { context: "$capture" }
        ),
          t.on(
            "arrowKey",
            (e, n) => {
              t.selection.isFake &&
                this.isEnabled &&
                this._handleSelectionMove(n.keyCode);
            },
            { priority: "lowest" }
          );
      }
      destroy() {
        super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
      }
      _handleSelectionMove(t) {
        const e = this.document.selection,
          n = new h.a(e.getRanges(), { backward: e.isBackward, fake: !1 });
        (t != v.f.arrowleft && t != v.f.arrowup) ||
          n.setTo(n.getFirstPosition()),
          (t != v.f.arrowright && t != v.f.arrowdown) ||
            n.setTo(n.getLastPosition());
        const i = { oldSelection: e, newSelection: n, domSelection: null };
        this.document.fire("selectionChange", i),
          this._fireSelectionChangeDoneDebounced(i);
      }
    }
    class A extends f.a {
      constructor(t) {
        super(t),
          (this.mutationObserver = t.getObserver(b)),
          (this.selection = this.document.selection),
          (this.domConverter = t.domConverter),
          (this._documents = new WeakSet()),
          (this._fireSelectionChangeDoneDebounced = Object(y.a)(
            (t) => this.document.fire("selectionChangeDone", t),
            200
          )),
          (this._clearInfiniteLoopInterval = setInterval(
            () => this._clearInfiniteLoop(),
            1e3
          )),
          (this._documentIsSelectingInactivityTimeoutDebounced = Object(y.a)(
            () => (this.document.isSelecting = !1),
            5e3
          )),
          (this._loopbackCounter = 0);
      }
      observe(t) {
        const e = t.ownerDocument,
          n = () => {
            (this.document.isSelecting = !1),
              this._documentIsSelectingInactivityTimeoutDebounced.cancel();
          };
        this.listenTo(
          t,
          "selectstart",
          () => {
            (this.document.isSelecting = !0),
              this._documentIsSelectingInactivityTimeoutDebounced();
          },
          { priority: "highest" }
        ),
          this.listenTo(t, "keydown", n, { priority: "highest" }),
          this.listenTo(t, "keyup", n, { priority: "highest" }),
          this._documents.has(e) ||
            (this.listenTo(e, "mouseup", n, { priority: "highest" }),
            this.listenTo(e, "selectionchange", (t, n) => {
              this._handleSelectionChange(n, e),
                this._documentIsSelectingInactivityTimeoutDebounced();
            }),
            this._documents.add(e));
      }
      destroy() {
        super.destroy(),
          clearInterval(this._clearInfiniteLoopInterval),
          this._fireSelectionChangeDoneDebounced.cancel(),
          this._documentIsSelectingInactivityTimeoutDebounced.cancel();
      }
      _handleSelectionChange(t, e) {
        if (!this.isEnabled) return;
        const n = e.defaultView.getSelection();
        if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) return;
        this.mutationObserver.flush();
        const i = this.domConverter.domSelectionToView(n);
        if (0 != i.rangeCount) {
          if (
            ((this.view.hasDomSelection = !0),
            !(
              (this.selection.isEqual(i) &&
                this.domConverter.isDomSelectionCorrect(n)) ||
              ++this._loopbackCounter > 60
            ))
          )
            if (this.selection.isSimilar(i)) this.view.forceRender();
            else {
              const t = {
                oldSelection: this.selection,
                newSelection: i,
                domSelection: n,
              };
              this.document.fire("selectionChange", t),
                this._fireSelectionChangeDoneDebounced(t);
            }
        } else this.view.hasDomSelection = !1;
      }
      _clearInfiniteLoop() {
        this._loopbackCounter = 0;
      }
    }
    class C extends w.a {
      constructor(t) {
        super(t),
          (this.domEventType = ["focus", "blur"]),
          (this.useCapture = !0);
        const e = this.document;
        e.on("focus", () => {
          (e.isFocused = !0),
            (this._renderTimeoutId = setTimeout(() => t.change(() => {}), 50));
        }),
          e.on("blur", (n, i) => {
            const s = e.selection.editableElement;
            (null !== s && s !== i.target) ||
              ((e.isFocused = !1), t.change(() => {}));
          });
      }
      onDomEvent(t) {
        this.fire(t.type, t);
      }
      destroy() {
        this._renderTimeoutId && clearTimeout(this._renderTimeoutId),
          super.destroy();
      }
    }
    class E extends w.a {
      constructor(t) {
        super(t),
          (this.domEventType = [
            "compositionstart",
            "compositionupdate",
            "compositionend",
          ]);
        const e = this.document;
        e.on("compositionstart", () => {
          e.isComposing = !0;
        }),
          e.on("compositionend", () => {
            e.isComposing = !1;
          });
      }
      onDomEvent(t) {
        this.fire(t.type, t);
      }
    }
    class O extends w.a {
      constructor(t) {
        super(t), (this.domEventType = ["beforeinput"]);
      }
      onDomEvent(t) {
        this.fire(t.type, t);
      }
    }
    var P = n(120),
      T = n(121);
    class x extends f.a {
      constructor(t) {
        super(t),
          this.document.on("keydown", (t, e) => {
            if (this.isEnabled && Object(T.t)(e.keyCode)) {
              const n = new P.a(
                this.document,
                "arrowKey",
                this.document.selection.getFirstRange()
              );
              this.document.fire(n, e), n.stop.called && t.stop();
            }
          });
      }
      observe() {}
    }
    var S = n(14),
      I = n(6),
      R = n(258),
      j = n(134),
      M = n(0),
      V = n(21);
    class N {
      constructor(t) {
        (this.document = new r.a(t)),
          (this.domConverter = new l.a(this.document)),
          (this.domRoots = new Map()),
          this.set("isRenderingInProgress", !1),
          this.set("hasDomSelection", !1),
          (this._renderer = new c.a(
            this.domConverter,
            this.document.selection
          )),
          this._renderer.bind("isFocused", "isSelecting").to(this.document),
          (this._initialDomRootAttributes = new WeakMap()),
          (this._observers = new Map()),
          (this._ongoingChange = !1),
          (this._postFixersInProgress = !1),
          (this._renderingDisabled = !1),
          (this._hasChangedSinceTheLastRendering = !1),
          (this._writer = new a.a(this.document)),
          this.addObserver(b),
          this.addObserver(A),
          this.addObserver(C),
          this.addObserver(_),
          this.addObserver(k),
          this.addObserver(E),
          this.addObserver(x),
          V.a.isAndroid && this.addObserver(O),
          Object(m.g)(this),
          Object(j.b)(this),
          this.on("render", () => {
            this._render(),
              this.document.fire("layoutChanged"),
              (this._hasChangedSinceTheLastRendering = !1);
          }),
          this.listenTo(this.document.selection, "change", () => {
            this._hasChangedSinceTheLastRendering = !0;
          }),
          this.listenTo(this.document, "change:isFocused", () => {
            this._hasChangedSinceTheLastRendering = !0;
          });
      }
      attachDomRoot(t, e = "main") {
        const n = this.document.getRoot(e);
        n._name = t.tagName.toLowerCase();
        const i = {};
        for (const { name: e, value: s } of Array.from(t.attributes))
          (i[e] = s),
            "class" === e
              ? this._writer.addClass(s.split(" "), n)
              : this._writer.setAttribute(e, s, n);
        this._initialDomRootAttributes.set(t, i);
        const s = () => {
          this._writer.setAttribute("contenteditable", !n.isReadOnly, n),
            n.isReadOnly
              ? this._writer.addClass("ck-read-only", n)
              : this._writer.removeClass("ck-read-only", n);
        };
        s(),
          this.domRoots.set(e, t),
          this.domConverter.bindElements(t, n),
          this._renderer.markToSync("children", n),
          this._renderer.markToSync("attributes", n),
          this._renderer.domDocuments.add(t.ownerDocument),
          n.on("change:children", (t, e) =>
            this._renderer.markToSync("children", e)
          ),
          n.on("change:attributes", (t, e) =>
            this._renderer.markToSync("attributes", e)
          ),
          n.on("change:text", (t, e) => this._renderer.markToSync("text", e)),
          n.on("change:isReadOnly", () => this.change(s)),
          n.on("change", () => {
            this._hasChangedSinceTheLastRendering = !0;
          });
        for (const n of this._observers.values()) n.observe(t, e);
      }
      detachDomRoot(t) {
        const e = this.domRoots.get(t);
        Array.from(e.attributes).forEach(({ name: t }) => e.removeAttribute(t));
        const n = this._initialDomRootAttributes.get(e);
        for (const t in n) e.setAttribute(t, n[t]);
        this.domRoots.delete(t), this.domConverter.unbindDomElement(e);
      }
      getDomRoot(t = "main") {
        return this.domRoots.get(t);
      }
      addObserver(t) {
        let e = this._observers.get(t);
        if (e) return e;
        (e = new t(this)), this._observers.set(t, e);
        for (const [t, n] of this.domRoots) e.observe(n, t);
        return e.enable(), e;
      }
      getObserver(t) {
        return this._observers.get(t);
      }
      disableObservers() {
        for (const t of this._observers.values()) t.disable();
      }
      enableObservers() {
        for (const t of this._observers.values()) t.enable();
      }
      scrollToTheSelection() {
        const t = this.document.selection.getFirstRange();
        t &&
          Object(R.a)({
            target: this.domConverter.viewRangeToDom(t),
            viewportOffset: 20,
          });
      }
      focus() {
        if (!this.document.isFocused) {
          const t = this.document.selection.editableElement;
          t && (this.domConverter.focus(t), this.forceRender());
        }
      }
      change(t) {
        if (this.isRenderingInProgress || this._postFixersInProgress)
          throw new M.default("cannot-change-view-tree", this);
        try {
          if (this._ongoingChange) return t(this._writer);
          this._ongoingChange = !0;
          const e = t(this._writer);
          return (
            (this._ongoingChange = !1),
            !this._renderingDisabled &&
              this._hasChangedSinceTheLastRendering &&
              ((this._postFixersInProgress = !0),
              this.document._callPostFixers(this._writer),
              (this._postFixersInProgress = !1),
              this.fire("render")),
            e
          );
        } catch (t) {
          M.default.rethrowUnexpectedError(t, this);
        }
      }
      forceRender() {
        (this._hasChangedSinceTheLastRendering = !0), this.change(() => {});
      }
      destroy() {
        for (const t of this._observers.values()) t.destroy();
        this.document.destroy(), this.stopListening();
      }
      createPositionAt(t, e) {
        return u.a._createAt(t, e);
      }
      createPositionAfter(t) {
        return u.a._createAfter(t);
      }
      createPositionBefore(t) {
        return u.a._createBefore(t);
      }
      createRange(t, e) {
        return new d.a(t, e);
      }
      createRangeOn(t) {
        return d.a._createOn(t);
      }
      createRangeIn(t) {
        return d.a._createIn(t);
      }
      createSelection(t, e, n) {
        return new h.a(t, e, n);
      }
      _disableRendering(t) {
        (this._renderingDisabled = t), 0 == t && this.change(() => {});
      }
      _render() {
        (this.isRenderingInProgress = !0),
          this.disableObservers(),
          this._renderer.render(),
          this.enableObservers(),
          (this.isRenderingInProgress = !1);
      }
    }
    Object(I.default)(N, S.default);
    var B = n(220),
      D = n(227),
      F = n(95),
      z = n(125);
    class L {
      constructor(t, e) {
        (this.model = t),
          (this.view = new N(e)),
          (this.mapper = new B.a()),
          (this.downcastDispatcher = new D.a({
            mapper: this.mapper,
            schema: t.schema,
          }));
        const n = this.model.document,
          i = n.selection,
          s = this.model.markers;
        this.listenTo(
          this.model,
          "_beforeChanges",
          () => {
            this.view._disableRendering(!0);
          },
          { priority: "highest" }
        ),
          this.listenTo(
            this.model,
            "_afterChanges",
            () => {
              this.view._disableRendering(!1);
            },
            { priority: "lowest" }
          ),
          this.listenTo(
            n,
            "change",
            () => {
              this.view.change((t) => {
                this.downcastDispatcher.convertChanges(n.differ, s, t),
                  this.downcastDispatcher.convertSelection(i, s, t);
              });
            },
            { priority: "low" }
          ),
          this.listenTo(
            this.view.document,
            "selectionChange",
            Object(z.a)(this.model, this.mapper)
          ),
          this.downcastDispatcher.on("insert:$text", Object(F.e)(), {
            priority: "lowest",
          }),
          this.downcastDispatcher.on("remove", Object(F.f)(), {
            priority: "low",
          }),
          this.downcastDispatcher.on("selection", Object(F.a)(), {
            priority: "high",
          }),
          this.downcastDispatcher.on("selection", Object(F.c)(), {
            priority: "low",
          }),
          this.downcastDispatcher.on("selection", Object(F.b)(), {
            priority: "low",
          }),
          this.view.document.roots
            .bindTo(this.model.document.roots)
            .using((t) => {
              if ("$graveyard" == t.rootName) return null;
              const e = new o(this.view.document, t.name);
              return (
                (e.rootName = t.rootName), this.mapper.bindElements(t, e), e
              );
            });
      }
      destroy() {
        this.view.destroy(), this.stopListening();
      }
    }
    Object(I.default)(L, S.default);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return A;
    });
    var i = n(6),
      s = n(14),
      o = n(0),
      r = n(220),
      a = n(227),
      c = n(95),
      l = n(46);
    class u {
      constructor() {
        this._consumables = new Map();
      }
      add(t, e) {
        let n;
        t.is("$text") || t.is("documentFragment")
          ? this._consumables.set(t, !0)
          : (this._consumables.has(t)
              ? (n = this._consumables.get(t))
              : ((n = new d(t)), this._consumables.set(t, n)),
            n.add(e));
      }
      test(t, e) {
        const n = this._consumables.get(t);
        return void 0 === n
          ? null
          : t.is("$text") || t.is("documentFragment")
          ? n
          : n.test(e);
      }
      consume(t, e) {
        return (
          !!this.test(t, e) &&
          (t.is("$text") || t.is("documentFragment")
            ? this._consumables.set(t, !1)
            : this._consumables.get(t).consume(e),
          !0)
        );
      }
      revert(t, e) {
        const n = this._consumables.get(t);
        void 0 !== n &&
          (t.is("$text") || t.is("documentFragment")
            ? this._consumables.set(t, !0)
            : n.revert(e));
      }
      static consumablesFromElement(t) {
        const e = {
            element: t,
            name: !0,
            attributes: [],
            classes: [],
            styles: [],
          },
          n = t.getAttributeKeys();
        for (const t of n) "style" != t && "class" != t && e.attributes.push(t);
        const i = t.getClassNames();
        for (const t of i) e.classes.push(t);
        const s = t.getStyleNames();
        for (const t of s) e.styles.push(t);
        return e;
      }
      static createFrom(t, e) {
        if ((e || (e = new u(t)), t.is("$text"))) return e.add(t), e;
        t.is("element") && e.add(t, u.consumablesFromElement(t)),
          t.is("documentFragment") && e.add(t);
        for (const n of t.getChildren()) e = u.createFrom(n, e);
        return e;
      }
    }
    class d {
      constructor(t) {
        (this.element = t),
          (this._canConsumeName = null),
          (this._consumables = {
            attributes: new Map(),
            styles: new Map(),
            classes: new Map(),
          });
      }
      add(t) {
        t.name && (this._canConsumeName = !0);
        for (const e in this._consumables) e in t && this._add(e, t[e]);
      }
      test(t) {
        if (t.name && !this._canConsumeName) return this._canConsumeName;
        for (const e in this._consumables)
          if (e in t) {
            const n = this._test(e, t[e]);
            if (!0 !== n) return n;
          }
        return !0;
      }
      consume(t) {
        t.name && (this._canConsumeName = !1);
        for (const e in this._consumables) e in t && this._consume(e, t[e]);
      }
      revert(t) {
        t.name && (this._canConsumeName = !0);
        for (const e in this._consumables) e in t && this._revert(e, t[e]);
      }
      _add(t, e) {
        const n = Object(l.a)(e) ? e : [e],
          i = this._consumables[t];
        for (const e of n) {
          if ("attributes" === t && ("class" === e || "style" === e))
            throw new o.default("viewconsumable-invalid-attribute", this);
          if ((i.set(e, !0), "styles" === t))
            for (const t of this.element.document.stylesProcessor.getRelatedStyles(
              e
            ))
              i.set(t, !0);
        }
      }
      _test(t, e) {
        const n = Object(l.a)(e) ? e : [e],
          i = this._consumables[t];
        for (const e of n)
          if ("attributes" !== t || ("class" !== e && "style" !== e)) {
            const t = i.get(e);
            if (void 0 === t) return null;
            if (!t) return !1;
          } else {
            const t = "class" == e ? "classes" : "styles",
              n = this._test(t, [...this._consumables[t].keys()]);
            if (!0 !== n) return n;
          }
        return !0;
      }
      _consume(t, e) {
        const n = Object(l.a)(e) ? e : [e],
          i = this._consumables[t];
        for (const e of n)
          if ("attributes" !== t || ("class" !== e && "style" !== e)) {
            if ((i.set(e, !1), "styles" == t))
              for (const t of this.element.document.stylesProcessor.getRelatedStyles(
                e
              ))
                i.set(t, !1);
          } else {
            const t = "class" == e ? "classes" : "styles";
            this._consume(t, [...this._consumables[t].keys()]);
          }
      }
      _revert(t, e) {
        const n = Object(l.a)(e) ? e : [e],
          i = this._consumables[t];
        for (const e of n)
          if ("attributes" !== t || ("class" !== e && "style" !== e)) {
            !1 === i.get(e) && i.set(e, !0);
          } else {
            const t = "class" == e ? "classes" : "styles";
            this._revert(t, [...this._consumables[t].keys()]);
          }
      }
    }
    var h = n(3),
      f = n(5),
      m = n(222),
      g = n(93),
      p = n(11);
    class b {
      constructor(t = {}) {
        (this._splitParts = new Map()),
          (this._cursorParents = new Map()),
          (this._modelCursor = null),
          (this.conversionApi = Object.assign({}, t)),
          (this.conversionApi.convertItem = this._convertItem.bind(this)),
          (this.conversionApi.convertChildren =
            this._convertChildren.bind(this)),
          (this.conversionApi.safeInsert = this._safeInsert.bind(this)),
          (this.conversionApi.updateConversionResult =
            this._updateConversionResult.bind(this)),
          (this.conversionApi.splitToAllowedParent =
            this._splitToAllowedParent.bind(this)),
          (this.conversionApi.getSplitParts = this._getSplitParts.bind(this));
      }
      convert(t, e, n = ["$root"]) {
        this.fire("viewCleanup", t),
          (this._modelCursor = (function (t, e) {
            let n;
            for (const i of new m.a(t)) {
              const t = {};
              for (const e of i.getAttributeKeys()) t[e] = i.getAttribute(e);
              const s = e.createElement(i.name, t);
              n && e.append(s, n), (n = f.a._createAt(s, 0));
            }
            return n;
          })(n, e)),
          (this.conversionApi.writer = e),
          (this.conversionApi.consumable = u.createFrom(t)),
          (this.conversionApi.store = {});
        const { modelRange: i } = this._convertItem(t, this._modelCursor),
          s = e.createDocumentFragment();
        if (i) {
          this._removeEmptyElements();
          for (const t of Array.from(this._modelCursor.parent.getChildren()))
            e.append(t, s);
          s.markers = (function (t, e) {
            const n = new Set(),
              i = new Map(),
              s = h.a._createIn(t).getItems();
            for (const t of s) "$marker" == t.name && n.add(t);
            for (const t of n) {
              const n = t.getAttribute("data-name"),
                s = e.createPositionBefore(t);
              i.has(n)
                ? (i.get(n).end = s.clone())
                : i.set(n, new h.a(s.clone())),
                e.remove(t);
            }
            return i;
          })(s, e);
        }
        return (
          (this._modelCursor = null),
          this._splitParts.clear(),
          this._cursorParents.clear(),
          (this.conversionApi.writer = null),
          (this.conversionApi.store = null),
          s
        );
      }
      _convertItem(t, e) {
        const n = Object.assign({
          viewItem: t,
          modelCursor: e,
          modelRange: null,
        });
        if (
          (t.is("element")
            ? this.fire("element:" + t.name, n, this.conversionApi)
            : t.is("$text")
            ? this.fire("text", n, this.conversionApi)
            : this.fire("documentFragment", n, this.conversionApi),
          n.modelRange && !(n.modelRange instanceof h.a))
        )
          throw new o.default(
            "view-conversion-dispatcher-incorrect-result",
            this
          );
        return { modelRange: n.modelRange, modelCursor: n.modelCursor };
      }
      _convertChildren(t, e) {
        let n = e.is("position") ? e : f.a._createAt(e, 0);
        const i = new h.a(n);
        for (const e of Array.from(t.getChildren())) {
          const t = this._convertItem(e, n);
          t.modelRange instanceof h.a &&
            ((i.end = t.modelRange.end), (n = t.modelCursor));
        }
        return { modelRange: i, modelCursor: n };
      }
      _safeInsert(t, e) {
        const n = this._splitToAllowedParent(t, e);
        return !!n && (this.conversionApi.writer.insert(t, n.position), !0);
      }
      _updateConversionResult(t, e) {
        const n = this._getSplitParts(t),
          i = this.conversionApi.writer;
        e.modelRange ||
          (e.modelRange = i.createRange(
            i.createPositionBefore(t),
            i.createPositionAfter(n[n.length - 1])
          ));
        const s = this._cursorParents.get(t);
        e.modelCursor = s ? i.createPositionAt(s, 0) : e.modelRange.end;
      }
      _splitToAllowedParent(t, e) {
        const { schema: n, writer: i } = this.conversionApi;
        let s = n.findAllowedParent(e, t);
        if (s) {
          if (s === e.parent) return { position: e };
          this._modelCursor.parent.getAncestors().includes(s) && (s = null);
        }
        if (!s)
          return Object(g.b)(e, t, n) ? { position: Object(g.c)(e, i) } : null;
        const o = this.conversionApi.writer.split(e, s),
          r = [];
        for (const t of o.range.getWalker())
          if ("elementEnd" == t.type) r.push(t.item);
          else {
            const e = r.pop(),
              n = t.item;
            this._registerSplitPair(e, n);
          }
        const a = o.range.end.parent;
        return (
          this._cursorParents.set(t, a),
          { position: o.position, cursorParent: a }
        );
      }
      _registerSplitPair(t, e) {
        this._splitParts.has(t) || this._splitParts.set(t, [t]);
        const n = this._splitParts.get(t);
        this._splitParts.set(e, n), n.push(e);
      }
      _getSplitParts(t) {
        let e;
        return (e = this._splitParts.has(t) ? this._splitParts.get(t) : [t]), e;
      }
      _removeEmptyElements() {
        let t = !1;
        for (const e of this._splitParts.keys())
          e.isEmpty &&
            (this.conversionApi.writer.remove(e),
            this._splitParts.delete(e),
            (t = !0));
        t && this._removeEmptyElements();
      }
    }
    Object(i.default)(b, p.default);
    var w = n(125),
      v = n(86),
      _ = n(145),
      y = n(144),
      k = n(185);
    class A {
      constructor(t, e) {
        (this.model = t),
          (this.mapper = new r.a()),
          (this.downcastDispatcher = new a.a({
            mapper: this.mapper,
            schema: t.schema,
          })),
          this.downcastDispatcher.on("insert:$text", Object(c.e)(), {
            priority: "lowest",
          }),
          (this.upcastDispatcher = new b({ schema: t.schema })),
          (this.viewDocument = new _.a(e)),
          (this.stylesProcessor = e),
          (this.htmlProcessor = new k.a(this.viewDocument)),
          (this.processor = this.htmlProcessor),
          (this._viewWriter = new y.a(this.viewDocument)),
          this.upcastDispatcher.on("text", Object(w.b)(), {
            priority: "lowest",
          }),
          this.upcastDispatcher.on("element", Object(w.c)(), {
            priority: "lowest",
          }),
          this.upcastDispatcher.on("documentFragment", Object(w.c)(), {
            priority: "lowest",
          }),
          this.decorate("init"),
          this.decorate("set"),
          this.decorate("get"),
          this.on(
            "init",
            () => {
              this.fire("ready");
            },
            { priority: "lowest" }
          ),
          this.on(
            "ready",
            () => {
              this.model.enqueueChange("transparent", g.a);
            },
            { priority: "lowest" }
          );
      }
      get(t = {}) {
        const { rootName: e = "main", trim: n = "empty" } = t;
        if (!this._checkIfRootsExists([e]))
          throw new o.default("datacontroller-get-non-existent-root", this);
        const i = this.model.document.getRoot(e);
        return "empty" !== n ||
          this.model.hasContent(i, { ignoreWhitespaces: !0 })
          ? this.stringify(i, t)
          : "";
      }
      stringify(t, e = {}) {
        const n = this.toView(t, e);
        return this.processor.toData(n);
      }
      toView(t, e = {}) {
        const n = this.viewDocument,
          i = this._viewWriter;
        this.mapper.clearBindings();
        const s = h.a._createIn(t),
          o = new v.a(n);
        this.mapper.bindElements(t, o),
          (this.downcastDispatcher.conversionApi.options = e),
          this.downcastDispatcher.convertInsert(s, i);
        const r = t.is("documentFragment")
          ? Array.from(t.markers)
          : (function (t) {
              const e = [],
                n = t.root.document;
              if (!n) return [];
              const i = h.a._createIn(t);
              for (const t of n.model.markers) {
                const n = t.getRange(),
                  s = n.isCollapsed,
                  o = n.start.isEqual(i.start) || n.end.isEqual(i.end);
                if (s && o) e.push([t.name, n]);
                else {
                  const s = i.getIntersection(n);
                  s && e.push([t.name, s]);
                }
              }
              return e.sort(([t, e], [n, i]) => {
                if ("after" !== e.end.compareWith(i.start)) return 1;
                if ("before" !== e.start.compareWith(i.end)) return -1;
                switch (e.start.compareWith(i.start)) {
                  case "before":
                    return 1;
                  case "after":
                    return -1;
                  default:
                    switch (e.end.compareWith(i.end)) {
                      case "before":
                        return 1;
                      case "after":
                        return -1;
                      default:
                        return n.localeCompare(t);
                    }
                }
              });
            })(t);
        for (const [t, e] of r)
          this.downcastDispatcher.convertMarkerAdd(t, e, i);
        return delete this.downcastDispatcher.conversionApi.options, o;
      }
      init(t) {
        if (this.model.document.version)
          throw new o.default("datacontroller-init-document-not-empty", this);
        let e = {};
        if (
          ("string" == typeof t ? (e.main = t) : (e = t),
          !this._checkIfRootsExists(Object.keys(e)))
        )
          throw new o.default("datacontroller-init-non-existent-root", this);
        return (
          this.model.enqueueChange("transparent", (t) => {
            for (const n of Object.keys(e)) {
              const i = this.model.document.getRoot(n);
              t.insert(this.parse(e[n], i), i, 0);
            }
          }),
          Promise.resolve()
        );
      }
      set(t, e = {}) {
        let n = {};
        if (
          ("string" == typeof t ? (n.main = t) : (n = t),
          !this._checkIfRootsExists(Object.keys(n)))
        )
          throw new o.default("datacontroller-set-non-existent-root", this);
        const i = e.batchType || "default";
        this.model.enqueueChange(i, (t) => {
          t.setSelection(null),
            t.removeSelectionAttribute(
              this.model.document.selection.getAttributeKeys()
            );
          for (const e of Object.keys(n)) {
            const i = this.model.document.getRoot(e);
            t.remove(t.createRangeIn(i)), t.insert(this.parse(n[e], i), i, 0);
          }
        });
      }
      parse(t, e = "$root") {
        const n = this.processor.toView(t);
        return this.toModel(n, e);
      }
      toModel(t, e = "$root") {
        return this.model.change((n) => this.upcastDispatcher.convert(t, n, e));
      }
      addStyleProcessorRules(t) {
        t(this.stylesProcessor);
      }
      registerRawContentMatcher(t) {
        this.processor &&
          this.processor !== this.htmlProcessor &&
          this.processor.registerRawContentMatcher(t),
          this.htmlProcessor.registerRawContentMatcher(t);
      }
      destroy() {
        this.stopListening();
      }
      _checkIfRootsExists(t) {
        for (const e of t)
          if (!this.model.document.getRootNames().includes(e)) return !1;
        return !0;
      }
    }
    Object(i.default)(A, s.default);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return p;
    });
    var i = n(25),
      s = n(7),
      o = n(22),
      r = n(6),
      a = n(83);
    function c(t, e, n) {
      t.insertBefore(n, t.childNodes[e] || null);
    }
    function l(t) {
      const e = t.parentNode;
      e && e.removeChild(t);
    }
    var u = n(14),
      d = n(0),
      h = n(42),
      f = n(105),
      m = n(218),
      g = n(21);
    n(328);
    class p {
      constructor(t, e) {
        (this.domDocuments = new Set()),
          (this.domConverter = t),
          (this.markedAttributes = new Set()),
          (this.markedChildren = new Set()),
          (this.markedTexts = new Set()),
          (this.selection = e),
          this.set("isFocused", !1),
          this.set("isSelecting", !1),
          g.a.isBlink &&
            !g.a.isAndroid &&
            this.on("change:isSelecting", () => {
              this.isSelecting || this.render();
            }),
          (this._inlineFiller = null),
          (this._fakeSelectionContainer = null);
      }
      markToSync(t, e) {
        if ("text" === t)
          this.domConverter.mapViewToDom(e.parent) && this.markedTexts.add(e);
        else {
          if (!this.domConverter.mapViewToDom(e)) return;
          if ("attributes" === t) this.markedAttributes.add(e);
          else {
            if ("children" !== t)
              throw new d.default("view-renderer-unknown-type", this);
            this.markedChildren.add(e);
          }
        }
      }
      render() {
        let t;
        const e = !(g.a.isBlink && !g.a.isAndroid) || !this.isSelecting;
        for (const t of this.markedChildren) this._updateChildrenMappings(t);
        e
          ? (this._inlineFiller &&
              !this._isSelectionInInlineFiller() &&
              this._removeInlineFiller(),
            this._inlineFiller
              ? (t = this._getInlineFillerPosition())
              : this._needsInlineFillerAtSelection() &&
                ((t = this.selection.getFirstPosition()),
                this.markedChildren.add(t.parent)))
          : this._inlineFiller &&
            this._inlineFiller.parentNode &&
            (t = this.domConverter.domPositionToView(this._inlineFiller));
        for (const t of this.markedAttributes) this._updateAttrs(t);
        for (const e of this.markedChildren)
          this._updateChildren(e, { inlineFillerPosition: t });
        for (const e of this.markedTexts)
          !this.markedChildren.has(e.parent) &&
            this.domConverter.mapViewToDom(e.parent) &&
            this._updateText(e, { inlineFillerPosition: t });
        if (e)
          if (t) {
            const e = this.domConverter.viewPositionToDom(t),
              n = e.parent.ownerDocument;
            Object(o.i)(e.parent)
              ? (this._inlineFiller = e.parent)
              : (this._inlineFiller = b(n, e.parent, e.offset));
          } else this._inlineFiller = null;
        this._updateFocus(),
          this._updateSelection(),
          this.markedTexts.clear(),
          this.markedAttributes.clear(),
          this.markedChildren.clear();
      }
      _updateChildrenMappings(t) {
        const e = this.domConverter.mapViewToDom(t);
        if (!e) return;
        const n = Array.from(this.domConverter.mapViewToDom(t).childNodes),
          i = Array.from(
            this.domConverter.viewChildrenToDom(t, e.ownerDocument, {
              withChildren: !1,
            })
          ),
          s = this._diffNodeLists(n, i),
          o = this._findReplaceActions(s, n, i);
        if (-1 !== o.indexOf("replace")) {
          const e = { equal: 0, insert: 0, delete: 0 };
          for (const s of o)
            if ("replace" === s) {
              const s = e.equal + e.insert,
                o = e.equal + e.delete,
                r = t.getChild(s);
              !r ||
                r.is("uiElement") ||
                r.is("rawElement") ||
                this._updateElementMappings(r, n[o]),
                l(i[s]),
                e.equal++;
            } else e[s]++;
        }
      }
      _updateElementMappings(t, e) {
        this.domConverter.unbindDomElement(e),
          this.domConverter.bindElements(e, t),
          this.markedChildren.add(t),
          this.markedAttributes.add(t);
      }
      _getInlineFillerPosition() {
        const t = this.selection.getFirstPosition();
        return t.parent.is("$text")
          ? s.a._createBefore(this.selection.getFirstPosition().parent)
          : t;
      }
      _isSelectionInInlineFiller() {
        if (1 != this.selection.rangeCount || !this.selection.isCollapsed)
          return !1;
        const t = this.selection.getFirstPosition(),
          e = this.domConverter.viewPositionToDom(t);
        return !!(e && Object(h.a)(e.parent) && Object(o.i)(e.parent));
      }
      _removeInlineFiller() {
        const t = this._inlineFiller;
        if (!Object(o.i)(t))
          throw new d.default("view-renderer-filler-was-lost", this);
        Object(o.h)(t) ? t.remove() : (t.data = t.data.substr(o.c)),
          (this._inlineFiller = null);
      }
      _needsInlineFillerAtSelection() {
        if (1 != this.selection.rangeCount || !this.selection.isCollapsed)
          return !1;
        const t = this.selection.getFirstPosition(),
          e = t.parent,
          n = t.offset;
        if (!this.domConverter.mapViewToDom(e.root)) return !1;
        if (!e.is("element")) return !1;
        if (
          !(function (t) {
            if ("false" == t.getAttribute("contenteditable")) return !1;
            const e = t.findAncestor((t) => t.hasAttribute("contenteditable"));
            return !e || "true" == e.getAttribute("contenteditable");
          })(e)
        )
          return !1;
        if (n === e.getFillerOffset()) return !1;
        const s = t.nodeBefore,
          o = t.nodeAfter;
        return !(s instanceof i.a || o instanceof i.a);
      }
      _updateText(t, e) {
        const n = this.domConverter.findCorrespondingDomText(t),
          i = this.domConverter.viewToDom(t, n.ownerDocument),
          s = n.data;
        let r = i.data;
        const a = e.inlineFillerPosition;
        if (
          (a && a.parent == t.parent && a.offset == t.index && (r = o.b + r),
          s != r)
        ) {
          const t = Object(m.a)(s, r);
          for (const e of t)
            "insert" === e.type
              ? n.insertData(e.index, e.values.join(""))
              : n.deleteData(e.index, e.howMany);
        }
      }
      _updateAttrs(t) {
        const e = this.domConverter.mapViewToDom(t);
        if (!e) return;
        const n = Array.from(e.attributes).map((t) => t.name),
          i = t.getAttributeKeys();
        for (const n of i)
          this.domConverter.setDomElementAttribute(e, n, t.getAttribute(n), t);
        for (const i of n)
          t.hasAttribute(i) ||
            this.domConverter.removeDomElementAttribute(e, i);
      }
      _updateChildren(t, e) {
        const n = this.domConverter.mapViewToDom(t);
        if (!n) return;
        const i = e.inlineFillerPosition,
          s = this.domConverter.mapViewToDom(t).childNodes,
          o = Array.from(
            this.domConverter.viewChildrenToDom(t, n.ownerDocument, {
              bind: !0,
            })
          );
        i && i.parent === t && b(n.ownerDocument, o, i.offset);
        const r = this._diffNodeLists(s, o);
        let a = 0;
        const u = new Set();
        for (const t of r)
          "delete" === t ? (u.add(s[a]), l(s[a])) : "equal" === t && a++;
        a = 0;
        for (const t of r)
          "insert" === t
            ? (c(n, a, o[a]), a++)
            : "equal" === t &&
              (this._markDescendantTextToSync(
                this.domConverter.domToView(o[a])
              ),
              a++);
        for (const t of u)
          t.parentNode || this.domConverter.unbindDomElement(t);
      }
      _diffNodeLists(t, e) {
        return (
          (t = (function (t, e) {
            const n = Array.from(t);
            if (0 == n.length || !e) return n;
            n[n.length - 1] == e && n.pop();
            return n;
          })(t, this._fakeSelectionContainer)),
          Object(a.a)(t, e, v.bind(null, this.domConverter))
        );
      }
      _findReplaceActions(t, e, n) {
        if (-1 === t.indexOf("insert") || -1 === t.indexOf("delete")) return t;
        let i = [],
          s = [],
          o = [];
        const r = { equal: 0, insert: 0, delete: 0 };
        for (const c of t)
          "insert" === c
            ? o.push(n[r.equal + r.insert])
            : "delete" === c
            ? s.push(e[r.equal + r.delete])
            : ((i = i.concat(
                Object(a.a)(s, o, w).map((t) => ("equal" === t ? "replace" : t))
              )),
              i.push("equal"),
              (s = []),
              (o = [])),
            r[c]++;
        return i.concat(
          Object(a.a)(s, o, w).map((t) => ("equal" === t ? "replace" : t))
        );
      }
      _markDescendantTextToSync(t) {
        if (t)
          if (t.is("$text")) this.markedTexts.add(t);
          else if (t.is("element"))
            for (const e of t.getChildren()) this._markDescendantTextToSync(e);
      }
      _updateSelection() {
        if (
          g.a.isBlink &&
          !g.a.isAndroid &&
          this.isSelecting &&
          !this.markedChildren.size
        )
          return;
        if (0 === this.selection.rangeCount)
          return this._removeDomSelection(), void this._removeFakeSelection();
        const t = this.domConverter.mapViewToDom(
          this.selection.editableElement
        );
        this.isFocused &&
          t &&
          (this.selection.isFake
            ? this._updateFakeSelection(t)
            : (this._removeFakeSelection(), this._updateDomSelection(t)));
      }
      _updateFakeSelection(t) {
        const e = t.ownerDocument;
        this._fakeSelectionContainer ||
          (this._fakeSelectionContainer = (function (t) {
            const e = t.createElement("div");
            return (
              (e.className = "ck-fake-selection-container"),
              Object.assign(e.style, {
                position: "fixed",
                top: 0,
                left: "-9999px",
                width: "42px",
              }),
              (e.textContent = " "),
              e
            );
          })(e));
        const n = this._fakeSelectionContainer;
        if (
          (this.domConverter.bindFakeSelection(n, this.selection),
          !this._fakeSelectionNeedsUpdate(t))
        )
          return;
        (n.parentElement && n.parentElement == t) || t.appendChild(n),
          (n.textContent = this.selection.fakeSelectionLabel || " ");
        const i = e.getSelection(),
          s = e.createRange();
        i.removeAllRanges(), s.selectNodeContents(n), i.addRange(s);
      }
      _updateDomSelection(t) {
        const e = t.ownerDocument.defaultView.getSelection();
        if (!this._domSelectionNeedsUpdate(e)) return;
        const n = this.domConverter.viewPositionToDom(this.selection.anchor),
          i = this.domConverter.viewPositionToDom(this.selection.focus);
        e.collapse(n.parent, n.offset),
          e.extend(i.parent, i.offset),
          g.a.isGecko &&
            (function (t, e) {
              const n = t.parent;
              if (
                n.nodeType != Node.ELEMENT_NODE ||
                t.offset != n.childNodes.length - 1
              )
                return;
              const i = n.childNodes[t.offset];
              i && "BR" == i.tagName && e.addRange(e.getRangeAt(0));
            })(i, e);
      }
      _domSelectionNeedsUpdate(t) {
        if (!this.domConverter.isDomSelectionCorrect(t)) return !0;
        const e = t && this.domConverter.domSelectionToView(t);
        return (
          (!e || !this.selection.isEqual(e)) &&
          !(!this.selection.isCollapsed && this.selection.isSimilar(e))
        );
      }
      _fakeSelectionNeedsUpdate(t) {
        const e = this._fakeSelectionContainer,
          n = t.ownerDocument.getSelection();
        return (
          !e ||
          e.parentElement !== t ||
          (n.anchorNode !== e && !e.contains(n.anchorNode)) ||
          e.textContent !== this.selection.fakeSelectionLabel
        );
      }
      _removeDomSelection() {
        for (const t of this.domDocuments) {
          if (t.getSelection().rangeCount) {
            const e = t.activeElement,
              n = this.domConverter.mapDomToView(e);
            e && n && t.getSelection().removeAllRanges();
          }
        }
      }
      _removeFakeSelection() {
        const t = this._fakeSelectionContainer;
        t && t.remove();
      }
      _updateFocus() {
        if (this.isFocused) {
          const t = this.selection.editableElement;
          t && this.domConverter.focus(t);
        }
      }
    }
    function b(t, e, n) {
      const i = e instanceof Array ? e : e.childNodes,
        s = i[n];
      if (Object(h.a)(s)) return (s.data = o.b + s.data), s;
      {
        const s = t.createTextNode(o.b);
        return Array.isArray(e) ? i.splice(n, 0, s) : c(e, n, s), s;
      }
    }
    function w(t, e) {
      return (
        Object(f.a)(t) &&
        Object(f.a)(e) &&
        !Object(h.a)(t) &&
        !Object(h.a)(e) &&
        t.nodeType !== Node.COMMENT_NODE &&
        e.nodeType !== Node.COMMENT_NODE &&
        t.tagName.toLowerCase() === e.tagName.toLowerCase()
      );
    }
    function v(t, e, n) {
      return (
        e === n ||
        (Object(h.a)(e) && Object(h.a)(n)
          ? e.data === n.data
          : !(!t.isBlockFiller(e) || !t.isBlockFiller(n)))
      );
    }
    Object(r.default)(p, u.default);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(35),
      s = n(0);
    function o(t, e, n = 1) {
      if ("number" != typeof n)
        throw new s.default("translation-service-quantity-not-a-number", null, {
          quantity: n,
        });
      const i = Object.keys(window.CKEDITOR_TRANSLATIONS).length;
      1 === i && (t = Object.keys(window.CKEDITOR_TRANSLATIONS)[0]);
      const o = e.id || e.string;
      if (
        0 === i ||
        !(function (t, e) {
          return (
            !!window.CKEDITOR_TRANSLATIONS[t] &&
            !!window.CKEDITOR_TRANSLATIONS[t].dictionary[e]
          );
        })(t, o)
      )
        return 1 !== n ? e.plural : e.string;
      const r = window.CKEDITOR_TRANSLATIONS[t].dictionary,
        a =
          window.CKEDITOR_TRANSLATIONS[t].getPluralForm ||
          ((t) => (1 === t ? 0 : 1));
      if ("string" == typeof r[o]) return r[o];
      const c = Number(a(n));
      return r[o][c];
    }
    window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {});
    var r = n(167);
    class a {
      constructor(t = {}) {
        (this.uiLanguage = t.uiLanguage || "en"),
          (this.contentLanguage = t.contentLanguage || this.uiLanguage),
          (this.uiLanguageDirection = Object(r.a)(this.uiLanguage)),
          (this.contentLanguageDirection = Object(r.a)(this.contentLanguage)),
          (this.t = (t, e) => this._t(t, e));
      }
      get language() {
        return (
          console.warn(
            "locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."
          ),
          this.uiLanguage
        );
      }
      _t(t, e = []) {
        (e = Object(i.a)(e)), "string" == typeof t && (t = { string: t });
        const n = !!t.plural ? e[0] : 1;
        return (function (t, e) {
          return t.replace(/%(\d+)/g, (t, n) => (n < e.length ? e[n] : t));
        })(o(this.uiLanguage, t, n), e);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return l;
    });
    var i = n(9),
      s = n(45),
      o = n(232);
    class r extends s.a {
      execute() {
        const t = this.editor.model,
          e = t.document;
        t.change((n) => {
          !(function (t, e, n, i) {
            const s = n.isCollapsed,
              r = n.getFirstRange(),
              c = r.start.parent,
              l = r.end.parent;
            if (i.isLimit(c) || i.isLimit(l))
              return void (s || c != l || t.deleteContent(n));
            if (s) {
              const t = Object(o.a)(e.model.schema, n.getAttributes());
              a(e, r.start), e.setSelectionAttribute(t);
            } else {
              const i = !(r.start.isAtStart && r.end.isAtEnd),
                s = c == l;
              t.deleteContent(n, { leaveUnmerged: i }),
                i && (s ? a(e, n.focus) : e.setSelection(l, 0));
            }
          })(this.editor.model, n, e.selection, t.schema),
            this.fire("afterExecute", { writer: n });
        });
      }
    }
    function a(t, e) {
      t.split(e), t.setSelection(e.parent.nextSibling, 0);
    }
    var c = n(233);
    class l extends i.a {
      static get pluginName() {
        return "Enter";
      }
      init() {
        const t = this.editor,
          e = t.editing.view,
          n = e.document;
        e.addObserver(c.a),
          t.commands.add("enter", new r(t)),
          this.listenTo(
            n,
            "enter",
            (n, i) => {
              i.preventDefault(),
                i.isSoft || (t.execute("enter"), e.scrollToTheSelection());
            },
            { priority: "low" }
          );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    (function (t) {
      var n = "object" == typeof t && t && t.Object === Object && t;
      e.a = n;
    }.call(this, n(259)));
  },
  function (t, e, n) {
    "use strict";
    e.a = function (t) {
      return t;
    };
  },
  function (t, e, n) {
    "use strict";
    e.a = function (t) {
      return (
        "number" == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991
      );
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(76),
      s = n(267),
      o = n(179);
    class r {
      constructor(t, e) {
        (this._config = {}),
          e && this.define(a(e)),
          t && this._setObjectToTarget(this._config, t);
      }
      set(t, e) {
        this._setToTarget(this._config, t, e);
      }
      define(t, e) {
        this._setToTarget(this._config, t, e, !0);
      }
      get(t) {
        return this._getFromSource(this._config, t);
      }
      *names() {
        for (const t of Object.keys(this._config)) yield t;
      }
      _setToTarget(t, e, n, s = !1) {
        if (Object(i.a)(e)) return void this._setObjectToTarget(t, e, s);
        const o = e.split(".");
        e = o.pop();
        for (const e of o) Object(i.a)(t[e]) || (t[e] = {}), (t = t[e]);
        if (Object(i.a)(n))
          return (
            Object(i.a)(t[e]) || (t[e] = {}),
            (t = t[e]),
            void this._setObjectToTarget(t, n, s)
          );
        (s && void 0 !== t[e]) || (t[e] = n);
      }
      _getFromSource(t, e) {
        const n = e.split(".");
        e = n.pop();
        for (const e of n) {
          if (!Object(i.a)(t[e])) {
            t = null;
            break;
          }
          t = t[e];
        }
        return t ? a(t[e]) : void 0;
      }
      _setObjectToTarget(t, e, n) {
        Object.keys(e).forEach((i) => {
          this._setToTarget(t, i, e[i], n);
        });
      }
    }
    function a(t) {
      return Object(s.a)(t, c);
    }
    function c(t) {
      return Object(o.a)(t) ? t : void 0;
    }
  },
  function (t, e, n) {
    "use strict";
    e.a = function (t, e) {
      return function (n) {
        return t(e(n));
      };
    };
  },
  function (t, e, n) {
    "use strict";
    (function (t) {
      var i = n(41),
        s =
          "object" == typeof exports && exports && !exports.nodeType && exports,
        o = s && "object" == typeof t && t && !t.nodeType && t,
        r = o && o.exports === s ? i.a.Buffer : void 0,
        a = r ? r.allocUnsafe : void 0;
      e.a = function (t, e) {
        if (e) return t.slice();
        var n = t.length,
          i = a ? a(n) : new t.constructor(n);
        return t.copy(i), i;
      };
    }.call(this, n(247)(t)));
  },
  function (t, e, n) {
    "use strict";
    e.a = function () {
      return [];
    };
  },
  function (t, e, n) {
    "use strict";
    e.a = function (t, e) {
      for (var n = -1, i = e.length, s = t.length; ++n < i; ) t[s + n] = e[n];
      return t;
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(151);
    e.a = function (t, e) {
      var n = e ? Object(i.a)(t.buffer) : t.buffer;
      return new t.constructor(n, t.byteOffset, t.length);
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(212),
      s = n(46);
    e.a = function (t, e, n) {
      var o = e(t);
      return Object(s.a)(t) ? o : Object(i.a)(o, n(t));
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(0),
      s = n(11),
      o = n(6);
    class r {
      constructor(t, e = [], n = []) {
        (this._context = t),
          (this._plugins = new Map()),
          (this._availablePlugins = new Map());
        for (const t of e)
          t.pluginName && this._availablePlugins.set(t.pluginName, t);
        this._contextPlugins = new Map();
        for (const [t, e] of n)
          this._contextPlugins.set(t, e),
            this._contextPlugins.set(e, t),
            t.pluginName && this._availablePlugins.set(t.pluginName, t);
      }
      *[Symbol.iterator]() {
        for (const t of this._plugins) "function" == typeof t[0] && (yield t);
      }
      get(t) {
        const e = this._plugins.get(t);
        if (!e) {
          let e = t;
          throw (
            ("function" == typeof t && (e = t.pluginName || t.name),
            new i.default("plugincollection-plugin-not-loaded", this._context, {
              plugin: e,
            }))
          );
        }
        return e;
      }
      has(t) {
        return this._plugins.has(t);
      }
      init(t, e = [], n = []) {
        const s = this,
          o = this._context;
        !(function t(e, n = new Set()) {
          e.forEach((e) => {
            c(e) &&
              (n.has(e) ||
                (n.add(e),
                e.pluginName &&
                  !s._availablePlugins.has(e.pluginName) &&
                  s._availablePlugins.set(e.pluginName, e),
                e.requires && t(e.requires, n)));
          });
        })(t),
          h(t);
        const r = [
          ...(function t(e, n = new Set()) {
            return e
              .map((t) => (c(t) ? t : s._availablePlugins.get(t)))
              .reduce(
                (e, i) =>
                  n.has(i)
                    ? e
                    : (n.add(i),
                      i.requires &&
                        (h(i.requires, i),
                        t(i.requires, n).forEach((t) => e.add(t))),
                      e.add(i)),
                new Set()
              );
          })(t.filter((t) => !u(t, e))),
        ];
        !(function (t, e) {
          for (const n of e) {
            if ("function" != typeof n)
              throw new i.default(
                "plugincollection-replace-plugin-invalid-type",
                null,
                { pluginItem: n }
              );
            const e = n.pluginName;
            if (!e)
              throw new i.default(
                "plugincollection-replace-plugin-missing-name",
                null,
                { pluginItem: n }
              );
            if (n.requires && n.requires.length)
              throw new i.default(
                "plugincollection-plugin-for-replacing-cannot-have-dependencies",
                null,
                { pluginName: e }
              );
            const o = s._availablePlugins.get(e);
            if (!o)
              throw new i.default(
                "plugincollection-plugin-for-replacing-not-exist",
                null,
                { pluginName: e }
              );
            const r = t.indexOf(o);
            if (-1 === r) {
              if (s._contextPlugins.has(o)) return;
              throw new i.default(
                "plugincollection-plugin-for-replacing-not-loaded",
                null,
                { pluginName: e }
              );
            }
            if (o.requires && o.requires.length)
              throw new i.default(
                "plugincollection-replaced-plugin-cannot-have-dependencies",
                null,
                { pluginName: e }
              );
            t.splice(r, 1, n), s._availablePlugins.set(e, n);
          }
        })(r, n);
        const a = (function (t) {
          return t.map((t) => {
            const e = s._contextPlugins.get(t) || new t(o);
            return s._add(t, e), e;
          });
        })(r);
        return f(a, "init")
          .then(() => f(a, "afterInit"))
          .then(() => a);
        function c(t) {
          return "function" == typeof t;
        }
        function l(t) {
          return c(t) && t.isContextPlugin;
        }
        function u(t, e) {
          return e.some((e) => e === t || d(t) === e || d(e) === t);
        }
        function d(t) {
          return c(t) ? t.pluginName || t.name : t;
        }
        function h(t, n = null) {
          t.map((t) => (c(t) ? t : s._availablePlugins.get(t) || t)).forEach(
            (t) => {
              !(function (t, e) {
                if (c(t)) return;
                if (e)
                  throw new i.default("plugincollection-soft-required", o, {
                    missingPlugin: t,
                    requiredBy: d(e),
                  });
                throw new i.default("plugincollection-plugin-not-found", o, {
                  plugin: t,
                });
              })(t, n),
                (function (t, e) {
                  if (!l(e)) return;
                  if (l(t)) return;
                  throw new i.default("plugincollection-context-required", o, {
                    plugin: d(t),
                    requiredBy: d(e),
                  });
                })(t, n),
                (function (t, n) {
                  if (!n) return;
                  if (!u(t, e)) return;
                  throw new i.default("plugincollection-required", o, {
                    plugin: d(t),
                    requiredBy: d(n),
                  });
                })(t, n);
            }
          );
        }
        function f(t, e) {
          return t.reduce(
            (t, n) =>
              n[e] ? (s._contextPlugins.has(n) ? t : t.then(n[e].bind(n))) : t,
            Promise.resolve()
          );
        }
      }
      destroy() {
        const t = [];
        for (const [, e] of this)
          "function" != typeof e.destroy ||
            this._contextPlugins.has(e) ||
            t.push(e.destroy());
        return Promise.all(t);
      }
      _add(t, e) {
        this._plugins.set(t, e);
        const n = t.pluginName;
        if (n) {
          if (this._plugins.has(n))
            throw new i.default("plugincollection-plugin-name-conflict", null, {
              pluginName: n,
              plugin1: this._plugins.get(n).constructor,
              plugin2: t,
            });
          this._plugins.set(n, e);
        }
      }
    }
    Object(o.default)(r, s.default);
  },
  function (t, e, n) {
    "use strict";
    var i = n(155),
      s = n(153);
    e.a = function (t, e) {
      for (var n = 0, o = (e = Object(i.a)(e, t)).length; null != t && n < o; )
        t = t[Object(s.a)(e[n++])];
      return n && n == o ? t : void 0;
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(62),
      s = n(6),
      o = n(11);
    class r {
      constructor(t = null, e, n) {
        (this._selection = new i.a()),
          this._selection.delegate("change").to(this),
          this._selection.setTo(t, e, n);
      }
      get isFake() {
        return this._selection.isFake;
      }
      get fakeSelectionLabel() {
        return this._selection.fakeSelectionLabel;
      }
      get anchor() {
        return this._selection.anchor;
      }
      get focus() {
        return this._selection.focus;
      }
      get isCollapsed() {
        return this._selection.isCollapsed;
      }
      get rangeCount() {
        return this._selection.rangeCount;
      }
      get isBackward() {
        return this._selection.isBackward;
      }
      get editableElement() {
        return this._selection.editableElement;
      }
      get _ranges() {
        return this._selection._ranges;
      }
      *getRanges() {
        yield* this._selection.getRanges();
      }
      getFirstRange() {
        return this._selection.getFirstRange();
      }
      getLastRange() {
        return this._selection.getLastRange();
      }
      getFirstPosition() {
        return this._selection.getFirstPosition();
      }
      getLastPosition() {
        return this._selection.getLastPosition();
      }
      getSelectedElement() {
        return this._selection.getSelectedElement();
      }
      isEqual(t) {
        return this._selection.isEqual(t);
      }
      isSimilar(t) {
        return this._selection.isSimilar(t);
      }
      is(t) {
        return (
          "selection" === t ||
          "documentSelection" == t ||
          "view:selection" == t ||
          "view:documentSelection" == t
        );
      }
      _setTo(t, e, n) {
        this._selection.setTo(t, e, n);
      }
      _setFocus(t, e) {
        this._selection.setFocus(t, e);
      }
    }
    Object(s.default)(r, o.default);
  },
  function (t, e, n) {
    "use strict";
    function i(t, e, n, i = !1) {
      (n =
        n ||
        function (t, e) {
          return t === e;
        }),
        Array.isArray(t) || (t = Array.prototype.slice.call(t)),
        Array.isArray(e) || (e = Array.prototype.slice.call(e));
      const r = (function (t, e, n) {
        const i = s(t, e, n);
        if (-1 === i)
          return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
        const r = o(t, i),
          a = o(e, i),
          c = s(r, a, n),
          l = t.length - c,
          u = e.length - c;
        return { firstIndex: i, lastIndexOld: l, lastIndexNew: u };
      })(t, e, n);
      return i
        ? (function (t, e) {
            const { firstIndex: n, lastIndexOld: i, lastIndexNew: s } = t;
            if (-1 === n) return Array(e).fill("equal");
            let o = [];
            n > 0 && (o = o.concat(Array(n).fill("equal")));
            s - n > 0 && (o = o.concat(Array(s - n).fill("insert")));
            i - n > 0 && (o = o.concat(Array(i - n).fill("delete")));
            s < e && (o = o.concat(Array(e - s).fill("equal")));
            return o;
          })(r, e.length)
        : (function (t, e) {
            const n = [],
              { firstIndex: i, lastIndexOld: s, lastIndexNew: o } = e;
            o - i > 0 &&
              n.push({ index: i, type: "insert", values: t.slice(i, o) });
            s - i > 0 &&
              n.push({ index: i + (o - i), type: "delete", howMany: s - i });
            return n;
          })(e, r);
    }
    function s(t, e, n) {
      for (let i = 0; i < Math.max(t.length, e.length); i++)
        if (void 0 === t[i] || void 0 === e[i] || !n(t[i], e[i])) return i;
      return -1;
    }
    function o(t, e) {
      return t.slice(e).reverse();
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    function i(t) {
      const e = t.ownerDocument.defaultView.getComputedStyle(t);
      return {
        top: parseInt(e.borderTopWidth, 10),
        right: parseInt(e.borderRightWidth, 10),
        bottom: parseInt(e.borderBottomWidth, 10),
        left: parseInt(e.borderLeftWidth, 10),
      };
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return u;
    });
    var i = n(5),
      s = n(3),
      o = n(7),
      r = n(15),
      a = n(25),
      c = n(11),
      l = n(6);
    class u {
      constructor() {
        (this._modelToViewMapping = new WeakMap()),
          (this._viewToModelMapping = new WeakMap()),
          (this._viewToModelLengthCallbacks = new Map()),
          (this._markerNameToElements = new Map()),
          (this._elementToMarkerNames = new Map()),
          (this._unboundMarkerNames = new Set()),
          this.on(
            "modelToViewPosition",
            (t, e) => {
              if (e.viewPosition) return;
              const n = this._modelToViewMapping.get(e.modelPosition.parent);
              e.viewPosition = this.findPositionIn(n, e.modelPosition.offset);
            },
            { priority: "low" }
          ),
          this.on(
            "viewToModelPosition",
            (t, e) => {
              if (e.modelPosition) return;
              const n = this.findMappedViewAncestor(e.viewPosition),
                s = this._viewToModelMapping.get(n),
                o = this._toModelOffset(
                  e.viewPosition.parent,
                  e.viewPosition.offset,
                  n
                );
              e.modelPosition = i.a._createAt(s, o);
            },
            { priority: "low" }
          );
      }
      bindElements(t, e) {
        this._modelToViewMapping.set(t, e), this._viewToModelMapping.set(e, t);
      }
      unbindViewElement(t) {
        const e = this.toModelElement(t);
        if (
          (this._viewToModelMapping.delete(t),
          this._elementToMarkerNames.has(t))
        )
          for (const e of this._elementToMarkerNames.get(t))
            this._unboundMarkerNames.add(e);
        this._modelToViewMapping.get(e) == t &&
          this._modelToViewMapping.delete(e);
      }
      unbindModelElement(t) {
        const e = this.toViewElement(t);
        this._modelToViewMapping.delete(t),
          this._viewToModelMapping.get(e) == t &&
            this._viewToModelMapping.delete(e);
      }
      bindElementToMarker(t, e) {
        const n = this._markerNameToElements.get(e) || new Set();
        n.add(t);
        const i = this._elementToMarkerNames.get(t) || new Set();
        i.add(e),
          this._markerNameToElements.set(e, n),
          this._elementToMarkerNames.set(t, i);
      }
      unbindElementFromMarkerName(t, e) {
        const n = this._markerNameToElements.get(e);
        n && (n.delete(t), 0 == n.size && this._markerNameToElements.delete(e));
        const i = this._elementToMarkerNames.get(t);
        i && (i.delete(e), 0 == i.size && this._elementToMarkerNames.delete(t));
      }
      flushUnboundMarkerNames() {
        const t = Array.from(this._unboundMarkerNames);
        return this._unboundMarkerNames.clear(), t;
      }
      clearBindings() {
        (this._modelToViewMapping = new WeakMap()),
          (this._viewToModelMapping = new WeakMap()),
          (this._markerNameToElements = new Map()),
          (this._elementToMarkerNames = new Map()),
          (this._unboundMarkerNames = new Set());
      }
      toModelElement(t) {
        return this._viewToModelMapping.get(t);
      }
      toViewElement(t) {
        return this._modelToViewMapping.get(t);
      }
      toModelRange(t) {
        return new s.a(
          this.toModelPosition(t.start),
          this.toModelPosition(t.end)
        );
      }
      toViewRange(t) {
        return new r.a(
          this.toViewPosition(t.start),
          this.toViewPosition(t.end)
        );
      }
      toModelPosition(t) {
        const e = { viewPosition: t, mapper: this };
        return this.fire("viewToModelPosition", e), e.modelPosition;
      }
      toViewPosition(t, e = { isPhantom: !1 }) {
        const n = { modelPosition: t, mapper: this, isPhantom: e.isPhantom };
        return this.fire("modelToViewPosition", n), n.viewPosition;
      }
      markerNameToElements(t) {
        const e = this._markerNameToElements.get(t);
        if (!e) return null;
        const n = new Set();
        for (const t of e)
          if (t.is("attributeElement"))
            for (const e of t.getElementsWithSameId()) n.add(e);
          else n.add(t);
        return n;
      }
      registerViewToModelLength(t, e) {
        this._viewToModelLengthCallbacks.set(t, e);
      }
      findMappedViewAncestor(t) {
        let e = t.parent;
        for (; !this._viewToModelMapping.has(e); ) e = e.parent;
        return e;
      }
      _toModelOffset(t, e, n) {
        if (n != t) {
          return (
            this._toModelOffset(t.parent, t.index, n) +
            this._toModelOffset(t, e, t)
          );
        }
        if (t.is("$text")) return e;
        let i = 0;
        for (let n = 0; n < e; n++) i += this.getModelLength(t.getChild(n));
        return i;
      }
      getModelLength(t) {
        if (this._viewToModelLengthCallbacks.get(t.name)) {
          return this._viewToModelLengthCallbacks.get(t.name)(t);
        }
        if (this._viewToModelMapping.has(t)) return 1;
        if (t.is("$text")) return t.data.length;
        if (t.is("uiElement")) return 0;
        {
          let e = 0;
          for (const n of t.getChildren()) e += this.getModelLength(n);
          return e;
        }
      }
      findPositionIn(t, e) {
        let n,
          i = 0,
          s = 0,
          r = 0;
        if (t.is("$text")) return new o.a(t, e);
        for (; s < e; )
          (n = t.getChild(r)), (i = this.getModelLength(n)), (s += i), r++;
        return s == e
          ? this._moveViewPositionToTextNode(new o.a(t, r))
          : this.findPositionIn(n, e - (s - i));
      }
      _moveViewPositionToTextNode(t) {
        const e = t.nodeBefore,
          n = t.nodeAfter;
        return e instanceof a.a
          ? new o.a(e, e.data.length)
          : n instanceof a.a
          ? new o.a(n, 0)
          : t;
      }
    }
    Object(l.default)(u, c.default);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return i;
    });
    class i {
      constructor(t) {
        this._dispatchers = t;
      }
      add(t) {
        for (const e of this._dispatchers) t(e);
        return this;
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "b", function () {
      return d;
    }),
      n.d(e, "a", function () {
        return h;
      });
    var i = n(0),
      s = n(14),
      o = n(6),
      r = n(3),
      a = n(5),
      c = n(20),
      l = n(26),
      u = n(71);
    class d {
      constructor() {
        (this._sourceDefinitions = {}),
          (this._attributeProperties = {}),
          this.decorate("checkChild"),
          this.decorate("checkAttribute"),
          this.on(
            "checkAttribute",
            (t, e) => {
              e[0] = new h(e[0]);
            },
            { priority: "highest" }
          ),
          this.on(
            "checkChild",
            (t, e) => {
              (e[0] = new h(e[0])), (e[1] = this.getDefinition(e[1]));
            },
            { priority: "highest" }
          );
      }
      register(t, e) {
        if (this._sourceDefinitions[t])
          throw new i.default("schema-cannot-register-item-twice", this, {
            itemName: t,
          });
        (this._sourceDefinitions[t] = [Object.assign({}, e)]),
          this._clearCache();
      }
      extend(t, e) {
        if (!this._sourceDefinitions[t])
          throw new i.default("schema-cannot-extend-missing-item", this, {
            itemName: t,
          });
        this._sourceDefinitions[t].push(Object.assign({}, e)),
          this._clearCache();
      }
      getDefinitions() {
        return (
          this._compiledDefinitions || this._compile(),
          this._compiledDefinitions
        );
      }
      getDefinition(t) {
        let e;
        return (
          (e =
            "string" == typeof t
              ? t
              : t.is && (t.is("$text") || t.is("$textProxy"))
              ? "$text"
              : t.name),
          this.getDefinitions()[e]
        );
      }
      isRegistered(t) {
        return !!this.getDefinition(t);
      }
      isBlock(t) {
        const e = this.getDefinition(t);
        return !(!e || !e.isBlock);
      }
      isLimit(t) {
        const e = this.getDefinition(t);
        return !!e && !(!e.isLimit && !e.isObject);
      }
      isObject(t) {
        const e = this.getDefinition(t);
        return (
          !!e && !!(e.isObject || (e.isLimit && e.isSelectable && e.isContent))
        );
      }
      isInline(t) {
        const e = this.getDefinition(t);
        return !(!e || !e.isInline);
      }
      isSelectable(t) {
        const e = this.getDefinition(t);
        return !!e && !(!e.isSelectable && !e.isObject);
      }
      isContent(t) {
        const e = this.getDefinition(t);
        return !!e && !(!e.isContent && !e.isObject);
      }
      checkChild(t, e) {
        return !!e && this._checkContextMatch(e, t);
      }
      checkAttribute(t, e) {
        const n = this.getDefinition(t.last);
        return !!n && n.allowAttributes.includes(e);
      }
      checkMerge(t, e = null) {
        if (t instanceof a.a) {
          const e = t.nodeBefore,
            n = t.nodeAfter;
          if (!(e instanceof c.a))
            throw new i.default("schema-check-merge-no-element-before", this);
          if (!(n instanceof c.a))
            throw new i.default("schema-check-merge-no-element-after", this);
          return this.checkMerge(e, n);
        }
        for (const n of e.getChildren()) if (!this.checkChild(t, n)) return !1;
        return !0;
      }
      addChildCheck(t) {
        this.on(
          "checkChild",
          (e, [n, i]) => {
            if (!i) return;
            const s = t(n, i);
            "boolean" == typeof s && (e.stop(), (e.return = s));
          },
          { priority: "high" }
        );
      }
      addAttributeCheck(t) {
        this.on(
          "checkAttribute",
          (e, [n, i]) => {
            const s = t(n, i);
            "boolean" == typeof s && (e.stop(), (e.return = s));
          },
          { priority: "high" }
        );
      }
      setAttributeProperties(t, e) {
        this._attributeProperties[t] = Object.assign(
          this.getAttributeProperties(t),
          e
        );
      }
      getAttributeProperties(t) {
        return this._attributeProperties[t] || {};
      }
      getLimitElement(t) {
        let e;
        if (t instanceof a.a) e = t.parent;
        else {
          e = (t instanceof r.a ? [t] : Array.from(t.getRanges())).reduce(
            (t, e) => {
              const n = e.getCommonAncestor();
              return t ? t.getCommonAncestor(n, { includeSelf: !0 }) : n;
            },
            null
          );
        }
        for (; !this.isLimit(e) && e.parent; ) e = e.parent;
        return e;
      }
      checkAttributeInSelection(t, e) {
        if (t.isCollapsed) {
          const n = [
            ...t.getFirstPosition().getAncestors(),
            new l.a("", t.getAttributes()),
          ];
          return this.checkAttribute(n, e);
        }
        {
          const n = t.getRanges();
          for (const t of n)
            for (const n of t) if (this.checkAttribute(n.item, e)) return !0;
        }
        return !1;
      }
      *getValidRanges(t, e) {
        t = (function* (t) {
          for (const e of t) yield* e.getMinimalFlatRanges();
        })(t);
        for (const n of t) yield* this._getValidRangesForRange(n, e);
      }
      getNearestSelectionRange(t, e = "both") {
        if (this.checkChild(t, "$text")) return new r.a(t);
        let n, i;
        const s =
          t
            .getAncestors()
            .reverse()
            .find((t) => this.isLimit(t)) || t.root;
        ("both" != e && "backward" != e) ||
          (n = new u.a({
            boundaries: r.a._createIn(s),
            startPosition: t,
            direction: "backward",
          })),
          ("both" != e && "forward" != e) ||
            (i = new u.a({ boundaries: r.a._createIn(s), startPosition: t }));
        for (const t of (function* (t, e) {
          let n = !1;
          for (; !n; ) {
            if (((n = !0), t)) {
              const e = t.next();
              e.done || ((n = !1), yield { walker: t, value: e.value });
            }
            if (e) {
              const t = e.next();
              t.done || ((n = !1), yield { walker: e, value: t.value });
            }
          }
        })(n, i)) {
          const e = t.walker == n ? "elementEnd" : "elementStart",
            i = t.value;
          if (i.type == e && this.isObject(i.item))
            return r.a._createOn(i.item);
          if (this.checkChild(i.nextPosition, "$text"))
            return new r.a(i.nextPosition);
        }
        return null;
      }
      findAllowedParent(t, e) {
        let n = t.parent;
        for (; n; ) {
          if (this.checkChild(n, e)) return n;
          if (this.isLimit(n)) return null;
          n = n.parent;
        }
        return null;
      }
      removeDisallowedAttributes(t, e) {
        for (const n of t)
          if (n.is("$text")) E(this, n, e);
          else {
            const t = r.a._createIn(n).getPositions();
            for (const n of t) {
              E(this, n.nodeBefore || n.parent, e);
            }
          }
      }
      createContext(t) {
        return new h(t);
      }
      _clearCache() {
        this._compiledDefinitions = null;
      }
      _compile() {
        const t = {},
          e = this._sourceDefinitions,
          n = Object.keys(e);
        for (const i of n) t[i] = f(e[i], i);
        for (const e of n) m(t, e);
        for (const e of n) g(t, e);
        for (const e of n) p(t, e);
        for (const e of n) b(t, e), w(t, e);
        for (const e of n) v(t, e), _(t, e), y(t, e);
        this._compiledDefinitions = t;
      }
      _checkContextMatch(t, e, n = e.length - 1) {
        const i = e.getItem(n);
        if (t.allowIn.includes(i.name)) {
          if (0 == n) return !0;
          {
            const t = this.getDefinition(i);
            return this._checkContextMatch(t, e, n - 1);
          }
        }
        return !1;
      }
      *_getValidRangesForRange(t, e) {
        let n = t.start,
          i = t.start;
        for (const s of t.getItems({ shallow: !0 }))
          s.is("element") &&
            (yield* this._getValidRangesForRange(r.a._createIn(s), e)),
            this.checkAttribute(s, e) ||
              (n.isEqual(i) || (yield new r.a(n, i)),
              (n = a.a._createAfter(s))),
            (i = a.a._createAfter(s));
        n.isEqual(i) || (yield new r.a(n, i));
      }
    }
    Object(o.default)(d, s.default);
    class h {
      constructor(t) {
        if (t instanceof h) return t;
        "string" == typeof t
          ? (t = [t])
          : Array.isArray(t) || (t = t.getAncestors({ includeSelf: !0 })),
          (this._items = t.map(C));
      }
      get length() {
        return this._items.length;
      }
      get last() {
        return this._items[this._items.length - 1];
      }
      [Symbol.iterator]() {
        return this._items[Symbol.iterator]();
      }
      push(t) {
        const e = new h([t]);
        return (e._items = [...this._items, ...e._items]), e;
      }
      getItem(t) {
        return this._items[t];
      }
      *getNames() {
        yield* this._items.map((t) => t.name);
      }
      endsWith(t) {
        return Array.from(this.getNames()).join(" ").endsWith(t);
      }
      startsWith(t) {
        return Array.from(this.getNames()).join(" ").startsWith(t);
      }
    }
    function f(t, e) {
      const n = {
        name: e,
        allowIn: [],
        allowContentOf: [],
        allowWhere: [],
        allowAttributes: [],
        allowAttributesOf: [],
        allowChildren: [],
        inheritTypesFrom: [],
      };
      return (
        (function (t, e) {
          for (const n of t) {
            const t = Object.keys(n).filter((t) => t.startsWith("is"));
            for (const i of t) e[i] = n[i];
          }
        })(t, n),
        k(t, n, "allowIn"),
        k(t, n, "allowContentOf"),
        k(t, n, "allowWhere"),
        k(t, n, "allowAttributes"),
        k(t, n, "allowAttributesOf"),
        k(t, n, "allowChildren"),
        k(t, n, "inheritTypesFrom"),
        (function (t, e) {
          for (const n of t) {
            const t = n.inheritAllFrom;
            t &&
              (e.allowContentOf.push(t),
              e.allowWhere.push(t),
              e.allowAttributesOf.push(t),
              e.inheritTypesFrom.push(t));
          }
        })(t, n),
        n
      );
    }
    function m(t, e) {
      const n = t[e];
      for (const i of n.allowChildren) {
        const n = t[i];
        n && n.allowIn.push(e);
      }
      n.allowChildren.length = 0;
    }
    function g(t, e) {
      for (const n of t[e].allowContentOf)
        if (t[n]) {
          A(t, n).forEach((t) => {
            t.allowIn.push(e);
          });
        }
      delete t[e].allowContentOf;
    }
    function p(t, e) {
      for (const n of t[e].allowWhere) {
        const i = t[n];
        if (i) {
          const n = i.allowIn;
          t[e].allowIn.push(...n);
        }
      }
      delete t[e].allowWhere;
    }
    function b(t, e) {
      for (const n of t[e].allowAttributesOf) {
        const i = t[n];
        if (i) {
          const n = i.allowAttributes;
          t[e].allowAttributes.push(...n);
        }
      }
      delete t[e].allowAttributesOf;
    }
    function w(t, e) {
      const n = t[e];
      for (const e of n.inheritTypesFrom) {
        const i = t[e];
        if (i) {
          const t = Object.keys(i).filter((t) => t.startsWith("is"));
          for (const e of t) e in n || (n[e] = i[e]);
        }
      }
      delete n.inheritTypesFrom;
    }
    function v(t, e) {
      const n = t[e],
        i = n.allowIn.filter((e) => t[e]);
      n.allowIn = Array.from(new Set(i));
    }
    function _(t, e) {
      const n = t[e];
      for (const i of n.allowIn) {
        t[i].allowChildren.push(e);
      }
    }
    function y(t, e) {
      const n = t[e];
      n.allowAttributes = Array.from(new Set(n.allowAttributes));
    }
    function k(t, e, n) {
      for (const i of t)
        "string" == typeof i[n]
          ? e[n].push(i[n])
          : Array.isArray(i[n]) && e[n].push(...i[n]);
    }
    function A(t, e) {
      const n = t[e];
      return ((i = t), Object.keys(i).map((t) => i[t])).filter((t) =>
        t.allowIn.includes(n.name)
      );
      var i;
    }
    function C(t) {
      return "string" == typeof t || t.is("documentFragment")
        ? {
            name: "string" == typeof t ? t : "$documentFragment",
            *getAttributeKeys() {},
            getAttribute() {},
          }
        : {
            name: t.is("element") ? t.name : "$text",
            *getAttributeKeys() {
              yield* t.getAttributeKeys();
            },
            getAttribute: (e) => t.getAttribute(e),
          };
    }
    function E(t, e, n) {
      for (const i of e.getAttributeKeys())
        t.checkAttribute(e, i) || n.removeAttribute(i, e);
    }
  },
  function (t, e, n) {
    "use strict";
    e.a =
      '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>';
  },
  function (t, e, n) {
    "use strict";
    e.a =
      '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return i;
    });
    class i {
      constructor(t, e = 20) {
        (this.model = t),
          (this.size = 0),
          (this.limit = e),
          (this.isLocked = !1),
          (this._changeCallback = (t, e) => {
            "transparent" != e.type && e !== this._batch && this._reset(!0);
          }),
          (this._selectionChangeCallback = () => {
            this._reset();
          }),
          this.model.document.on("change", this._changeCallback),
          this.model.document.selection.on(
            "change:range",
            this._selectionChangeCallback
          ),
          this.model.document.selection.on(
            "change:attribute",
            this._selectionChangeCallback
          );
      }
      get batch() {
        return (
          this._batch || (this._batch = this.model.createBatch()), this._batch
        );
      }
      input(t) {
        (this.size += t), this.size >= this.limit && this._reset(!0);
      }
      lock() {
        this.isLocked = !0;
      }
      unlock() {
        this.isLocked = !1;
      }
      destroy() {
        this.model.document.off("change", this._changeCallback),
          this.model.document.selection.off(
            "change:range",
            this._selectionChangeCallback
          ),
          this.model.document.selection.off(
            "change:attribute",
            this._selectionChangeCallback
          );
      }
      _reset(t) {
        (this.isLocked && !t) || ((this._batch = null), (this.size = 0));
      }
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(127),
      s = n(136);
    var o = function (t) {
      return this.__data__.set(t, "__lodash_hash_undefined__"), this;
    };
    var r = function (t) {
      return this.__data__.has(t);
    };
    function a(t) {
      var e = -1,
        n = null == t ? 0 : t.length;
      for (this.__data__ = new s.a(); ++e < n; ) this.add(t[e]);
    }
    (a.prototype.add = a.prototype.push = o), (a.prototype.has = r);
    var c = a;
    var l = function (t, e) {
      for (var n = -1, i = null == t ? 0 : t.length; ++n < i; )
        if (e(t[n], n, t)) return !0;
      return !1;
    };
    var u = function (t, e) {
      return t.has(e);
    };
    var d = function (t, e, n, i, s, o) {
        var r = 1 & n,
          a = t.length,
          d = e.length;
        if (a != d && !(r && d > a)) return !1;
        var h = o.get(t),
          f = o.get(e);
        if (h && f) return h == e && f == t;
        var m = -1,
          g = !0,
          p = 2 & n ? new c() : void 0;
        for (o.set(t, e), o.set(e, t); ++m < a; ) {
          var b = t[m],
            w = e[m];
          if (i) var v = r ? i(w, b, m, e, t, o) : i(b, w, m, t, e, o);
          if (void 0 !== v) {
            if (v) continue;
            g = !1;
            break;
          }
          if (p) {
            if (
              !l(e, function (t, e) {
                if (!u(p, e) && (b === t || s(b, t, n, i, o))) return p.push(e);
              })
            ) {
              g = !1;
              break;
            }
          } else if (b !== w && !s(b, w, n, i, o)) {
            g = !1;
            break;
          }
        }
        return o.delete(t), o.delete(e), g;
      },
      h = n(64),
      f = n(162),
      m = n(87);
    var g = function (t) {
      var e = -1,
        n = Array(t.size);
      return (
        t.forEach(function (t, i) {
          n[++e] = [i, t];
        }),
        n
      );
    };
    var p = function (t) {
        var e = -1,
          n = Array(t.size);
        return (
          t.forEach(function (t) {
            n[++e] = t;
          }),
          n
        );
      },
      b = h.a ? h.a.prototype : void 0,
      w = b ? b.valueOf : void 0;
    var v = function (t, e, n, i, s, o, r) {
        switch (n) {
          case "[object DataView]":
            if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
              return !1;
            (t = t.buffer), (e = e.buffer);
          case "[object ArrayBuffer]":
            return !(
              t.byteLength != e.byteLength || !o(new f.a(t), new f.a(e))
            );
          case "[object Boolean]":
          case "[object Date]":
          case "[object Number]":
            return Object(m.a)(+t, +e);
          case "[object Error]":
            return t.name == e.name && t.message == e.message;
          case "[object RegExp]":
          case "[object String]":
            return t == e + "";
          case "[object Map]":
            var a = g;
          case "[object Set]":
            var c = 1 & i;
            if ((a || (a = p), t.size != e.size && !c)) return !1;
            var l = r.get(t);
            if (l) return l == e;
            (i |= 2), r.set(t, e);
            var u = d(a(t), a(e), i, s, o, r);
            return r.delete(t), u;
          case "[object Symbol]":
            if (w) return w.call(t) == w.call(e);
        }
        return !1;
      },
      _ = n(171),
      y = Object.prototype.hasOwnProperty;
    var k = function (t, e, n, i, s, o) {
        var r = 1 & n,
          a = Object(_.a)(t),
          c = a.length;
        if (c != Object(_.a)(e).length && !r) return !1;
        for (var l = c; l--; ) {
          var u = a[l];
          if (!(r ? u in e : y.call(e, u))) return !1;
        }
        var d = o.get(t),
          h = o.get(e);
        if (d && h) return d == e && h == t;
        var f = !0;
        o.set(t, e), o.set(e, t);
        for (var m = r; ++l < c; ) {
          var g = t[(u = a[l])],
            p = e[u];
          if (i) var b = r ? i(p, g, u, e, t, o) : i(g, p, u, t, e, o);
          if (!(void 0 === b ? g === p || s(g, p, n, i, o) : b)) {
            f = !1;
            break;
          }
          m || (m = "constructor" == u);
        }
        if (f && !m) {
          var w = t.constructor,
            v = e.constructor;
          w == v ||
            !("constructor" in t) ||
            !("constructor" in e) ||
            ("function" == typeof w &&
              w instanceof w &&
              "function" == typeof v &&
              v instanceof v) ||
            (f = !1);
        }
        return o.delete(t), o.delete(e), f;
      },
      A = n(103),
      C = n(46),
      E = n(102),
      O = n(158),
      P = "[object Object]",
      T = Object.prototype.hasOwnProperty;
    var x = function (t, e, n, s, o, r) {
        var a = Object(C.a)(t),
          c = Object(C.a)(e),
          l = a ? "[object Array]" : Object(A.a)(t),
          u = c ? "[object Array]" : Object(A.a)(e),
          h = (l = "[object Arguments]" == l ? P : l) == P,
          f = (u = "[object Arguments]" == u ? P : u) == P,
          m = l == u;
        if (m && Object(E.a)(t)) {
          if (!Object(E.a)(e)) return !1;
          (a = !0), (h = !1);
        }
        if (m && !h)
          return (
            r || (r = new i.a()),
            a || Object(O.a)(t) ? d(t, e, n, s, o, r) : v(t, e, l, n, s, o, r)
          );
        if (!(1 & n)) {
          var g = h && T.call(t, "__wrapped__"),
            p = f && T.call(e, "__wrapped__");
          if (g || p) {
            var b = g ? t.value() : t,
              w = p ? e.value() : e;
            return r || (r = new i.a()), o(b, w, n, s, r);
          }
        }
        return !!m && (r || (r = new i.a()), k(t, e, n, s, o, r));
      },
      S = n(38);
    e.a = function t(e, n, i, s, o) {
      return (
        e === n ||
        (null == e || null == n || (!Object(S.a)(e) && !Object(S.a)(n))
          ? e != e && n != n
          : x(e, n, i, s, t, o))
      );
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return u;
    });
    var i = n(60);
    class s {
      constructor() {
        (this._consumable = new Map()), (this._textProxyRegistry = new Map());
      }
      add(t, e) {
        (e = o(e)),
          t instanceof i.a && (t = this._getSymbolForTextProxy(t)),
          this._consumable.has(t) || this._consumable.set(t, new Map()),
          this._consumable.get(t).set(e, !0);
      }
      consume(t, e) {
        return (
          (e = o(e)),
          t instanceof i.a && (t = this._getSymbolForTextProxy(t)),
          !!this.test(t, e) && (this._consumable.get(t).set(e, !1), !0)
        );
      }
      test(t, e) {
        (e = o(e)), t instanceof i.a && (t = this._getSymbolForTextProxy(t));
        const n = this._consumable.get(t);
        if (void 0 === n) return null;
        const s = n.get(e);
        return void 0 === s ? null : s;
      }
      revert(t, e) {
        (e = o(e)), t instanceof i.a && (t = this._getSymbolForTextProxy(t));
        const n = this.test(t, e);
        return !1 === n
          ? (this._consumable.get(t).set(e, !0), !0)
          : !0 !== n && null;
      }
      _getSymbolForTextProxy(t) {
        let e = null;
        const n = this._textProxyRegistry.get(t.startOffset);
        if (n) {
          const i = n.get(t.endOffset);
          i && (e = i.get(t.parent));
        }
        return (
          e ||
            (e = this._addSymbolForTextProxy(
              t.startOffset,
              t.endOffset,
              t.parent
            )),
          e
        );
      }
      _addSymbolForTextProxy(t, e, n) {
        const i = Symbol("textProxySymbol");
        let s, o;
        return (
          (s = this._textProxyRegistry.get(t)),
          s || ((s = new Map()), this._textProxyRegistry.set(t, s)),
          (o = s.get(e)),
          o || ((o = new Map()), s.set(e, o)),
          o.set(n, i),
          i
        );
      }
    }
    function o(t) {
      const e = t.split(":");
      return "addMarker" == e[0] || "removeMarker" == e[0]
        ? t
        : e.length > 1
        ? e[0] + ":" + e[1]
        : e[0];
    }
    var r = n(3),
      a = n(5),
      c = n(11),
      l = n(6);
    class u {
      constructor(t) {
        (this.conversionApi = Object.assign({ dispatcher: this }, t)),
          (this._reconversionEventsMapping = new Map());
      }
      convertChanges(t, e, n) {
        for (const e of t.getMarkersToRemove())
          this.convertMarkerRemove(e.name, e.range, n);
        const i = this._mapChangesWithAutomaticReconversion(t);
        for (const t of i)
          "insert" === t.type
            ? this.convertInsert(
                r.a._createFromPositionAndShift(t.position, t.length),
                n
              )
            : "remove" === t.type
            ? this.convertRemove(t.position, t.length, t.name, n)
            : "reconvert" === t.type
            ? this.reconvertElement(t.element, n)
            : this.convertAttribute(
                t.range,
                t.attributeKey,
                t.attributeOldValue,
                t.attributeNewValue,
                n
              );
        for (const t of this.conversionApi.mapper.flushUnboundMarkerNames()) {
          const i = e.get(t).getRange();
          this.convertMarkerRemove(t, i, n), this.convertMarkerAdd(t, i, n);
        }
        for (const e of t.getMarkersToAdd())
          this.convertMarkerAdd(e.name, e.range, n);
      }
      convertInsert(t, e) {
        (this.conversionApi.writer = e),
          (this.conversionApi.consumable = this._createInsertConsumable(t));
        for (const e of Array.from(t).map(h))
          this._convertInsertWithAttributes(e);
        this._clearConversionApi();
      }
      convertRemove(t, e, n, i) {
        (this.conversionApi.writer = i),
          this.fire(
            "remove:" + n,
            { position: t, length: e },
            this.conversionApi
          ),
          this._clearConversionApi();
      }
      convertAttribute(t, e, n, i, s) {
        (this.conversionApi.writer = s),
          (this.conversionApi.consumable = this._createConsumableForRange(
            t,
            "attribute:" + e
          ));
        for (const s of t) {
          const t = {
            item: s.item,
            range: r.a._createFromPositionAndShift(
              s.previousPosition,
              s.length
            ),
            attributeKey: e,
            attributeOldValue: n,
            attributeNewValue: i,
          };
          this._testAndFire("attribute:" + e, t);
        }
        this._clearConversionApi();
      }
      reconvertElement(t, e) {
        const n = r.a._createOn(t);
        (this.conversionApi.writer = e),
          (this.conversionApi.consumable = this._createInsertConsumable(n));
        const i = this.conversionApi.mapper,
          s = i.toViewElement(t);
        e.remove(s), this._convertInsertWithAttributes({ item: t, range: n });
        const o = i.toViewElement(t);
        for (const n of r.a._createIn(t)) {
          const { item: t } = n,
            s = f(t, i);
          s
            ? s.root !== o.root &&
              e.move(e.createRangeOn(s), i.toViewPosition(a.a._createBefore(t)))
            : this._convertInsertWithAttributes(h(n));
        }
        i.unbindViewElement(s), this._clearConversionApi();
      }
      convertSelection(t, e, n) {
        const i = Array.from(e.getMarkersAtPosition(t.getFirstPosition()));
        if (
          ((this.conversionApi.writer = n),
          (this.conversionApi.consumable = this._createSelectionConsumable(
            t,
            i
          )),
          this.fire("selection", { selection: t }, this.conversionApi),
          t.isCollapsed)
        ) {
          for (const e of i) {
            const n = e.getRange();
            if (!d(t.getFirstPosition(), e, this.conversionApi.mapper))
              continue;
            const i = { item: t, markerName: e.name, markerRange: n };
            this.conversionApi.consumable.test(t, "addMarker:" + e.name) &&
              this.fire("addMarker:" + e.name, i, this.conversionApi);
          }
          for (const e of t.getAttributeKeys()) {
            const n = {
              item: t,
              range: t.getFirstRange(),
              attributeKey: e,
              attributeOldValue: null,
              attributeNewValue: t.getAttribute(e),
            };
            this.conversionApi.consumable.test(
              t,
              "attribute:" + n.attributeKey
            ) &&
              this.fire(
                "attribute:" + n.attributeKey + ":$text",
                n,
                this.conversionApi
              );
          }
          this._clearConversionApi();
        } else this._clearConversionApi();
      }
      convertMarkerAdd(t, e, n) {
        if ("$graveyard" == e.root.rootName) return;
        this.conversionApi.writer = n;
        const i = "addMarker:" + t,
          o = new s();
        if (
          (o.add(e, i),
          (this.conversionApi.consumable = o),
          this.fire(i, { markerName: t, markerRange: e }, this.conversionApi),
          o.test(e, i))
        ) {
          this.conversionApi.consumable = this._createConsumableForRange(e, i);
          for (const n of e.getItems()) {
            if (!this.conversionApi.consumable.test(n, i)) continue;
            const s = {
              item: n,
              range: r.a._createOn(n),
              markerName: t,
              markerRange: e,
            };
            this.fire(i, s, this.conversionApi);
          }
          this._clearConversionApi();
        } else this._clearConversionApi();
      }
      convertMarkerRemove(t, e, n) {
        "$graveyard" != e.root.rootName &&
          ((this.conversionApi.writer = n),
          this.fire(
            "removeMarker:" + t,
            { markerName: t, markerRange: e },
            this.conversionApi
          ),
          this._clearConversionApi());
      }
      _mapReconversionTriggerEvent(t, e) {
        this._reconversionEventsMapping.set(e, t);
      }
      _createInsertConsumable(t) {
        const e = new s();
        for (const n of t) {
          const t = n.item;
          e.add(t, "insert");
          for (const n of t.getAttributeKeys()) e.add(t, "attribute:" + n);
        }
        return e;
      }
      _createConsumableForRange(t, e) {
        const n = new s();
        for (const i of t.getItems()) n.add(i, e);
        return n;
      }
      _createSelectionConsumable(t, e) {
        const n = new s();
        n.add(t, "selection");
        for (const i of e) n.add(t, "addMarker:" + i.name);
        for (const e of t.getAttributeKeys()) n.add(t, "attribute:" + e);
        return n;
      }
      _testAndFire(t, e) {
        this.conversionApi.consumable.test(e.item, t) &&
          this.fire(
            (function (t, e) {
              const n = e.item.name || "$text";
              return `${t}:${n}`;
            })(t, e),
            e,
            this.conversionApi
          );
      }
      _clearConversionApi() {
        delete this.conversionApi.writer, delete this.conversionApi.consumable;
      }
      _convertInsertWithAttributes(t) {
        this._testAndFire("insert", t);
        for (const e of t.item.getAttributeKeys())
          (t.attributeKey = e),
            (t.attributeOldValue = null),
            (t.attributeNewValue = t.item.getAttribute(e)),
            this._testAndFire("attribute:" + e, t);
      }
      _mapChangesWithAutomaticReconversion(t) {
        const e = new Set(),
          n = [];
        for (const i of t.getChanges()) {
          const t = i.position || i.range.start,
            s = t.parent;
          if (Object(a.d)(t, s)) {
            n.push(i);
            continue;
          }
          const o = "attribute" === i.type ? Object(a.b)(t, s, null) : s;
          if (o.is("$text")) {
            n.push(i);
            continue;
          }
          let r;
          if (
            ((r =
              "attribute" === i.type
                ? `attribute:${i.attributeKey}:${o.name}`
                : `${i.type}:${i.name}`),
            this._isReconvertTriggerEvent(r, o.name))
          ) {
            if (e.has(o)) continue;
            e.add(o), n.push({ type: "reconvert", element: o });
          } else n.push(i);
        }
        return n;
      }
      _isReconvertTriggerEvent(t, e) {
        return this._reconversionEventsMapping.get(t) === e;
      }
    }
    function d(t, e, n) {
      const i = e.getRange(),
        s = Array.from(t.getAncestors());
      s.shift(), s.reverse();
      return !s.some((t) => {
        if (i.containsItem(t)) {
          return !!n.toViewElement(t).getCustomProperty("addHighlight");
        }
      });
    }
    function h(t) {
      return {
        item: t.item,
        range: r.a._createFromPositionAndShift(t.previousPosition, t.length),
      };
    }
    function f(t, e) {
      if (t.is("textProxy")) {
        const n = e.toViewPosition(a.a._createBefore(t)).parent;
        return n.is("$text") ? n : null;
      }
      return e.toViewElement(t);
    }
    Object(l.default)(u, c.default);
  },
  function (t, e, n) {
    "use strict";
    var i = function (t, e) {
        for (var n = -1, i = Array(t); ++n < t; ) i[n] = e(n);
        return i;
      },
      s = n(173),
      o = n(46),
      r = n(102),
      a = n(146),
      c = n(158),
      l = Object.prototype.hasOwnProperty;
    e.a = function (t, e) {
      var n = Object(o.a)(t),
        u = !n && Object(s.a)(t),
        d = !n && !u && Object(r.a)(t),
        h = !n && !u && !d && Object(c.a)(t),
        f = n || u || d || h,
        m = f ? i(t.length, String) : [],
        g = m.length;
      for (var p in t)
        (!e && !l.call(t, p)) ||
          (f &&
            ("length" == p ||
              (d && ("offset" == p || "parent" == p)) ||
              (h &&
                ("buffer" == p || "byteLength" == p || "byteOffset" == p)) ||
              Object(a.a)(p, g))) ||
          m.push(p);
      return m;
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(30),
      s = Object.create,
      o = (function () {
        function t() {}
        return function (e) {
          if (!Object(i.a)(e)) return {};
          if (s) return s(e);
          t.prototype = e;
          var n = new t();
          return (t.prototype = void 0), n;
        };
      })(),
      r = n(150),
      a = n(149);
    e.a = function (t) {
      return "function" != typeof t.constructor || Object(a.a)(t)
        ? {}
        : o(Object(r.a)(t));
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return d;
    });
    var i = n(9),
      s = n(45),
      o = n(196);
    class r extends s.a {
      constructor(t) {
        super(t),
          (this._stack = []),
          (this._createdBatches = new WeakSet()),
          this.refresh(),
          this.listenTo(
            t.data,
            "set",
            (t, e) => {
              e[1] = { ...e[1] };
              const n = e[1];
              n.batchType || (n.batchType = "transparent");
            },
            { priority: "high" }
          ),
          this.listenTo(t.data, "set", (t, e) => {
            "transparent" === e[1].batchType && this.clearStack();
          });
      }
      refresh() {
        this.isEnabled = this._stack.length > 0;
      }
      addBatch(t) {
        const e = this.editor.model.document.selection,
          n = {
            ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [],
            isBackward: e.isBackward,
          };
        this._stack.push({ batch: t, selection: n }), this.refresh();
      }
      clearStack() {
        (this._stack = []), this.refresh();
      }
      _restoreSelection(t, e, n) {
        const i = this.editor.model,
          s = i.document,
          o = [],
          r = t.map((t) => t.getTransformedByOperations(n)),
          l = r.flat();
        for (const t of r) {
          const e = t
            .filter((t) => t.root != s.graveyard)
            .filter((t) => !c(t, l));
          e.length && (a(e), o.push(e[0]));
        }
        o.length &&
          i.change((t) => {
            t.setSelection(o, { backward: e });
          });
      }
      _undo(t, e) {
        const n = this.editor.model,
          i = n.document;
        this._createdBatches.add(e);
        const s = t.operations.slice().filter((t) => t.isDocumentOperation);
        s.reverse();
        for (const t of s) {
          const s = t.baseVersion + 1,
            r = Array.from(i.history.getOperations(s)),
            a = Object(o.a)([t.getReversed()], r, {
              useRelations: !0,
              document: this.editor.model.document,
              padWithNoOps: !1,
              forceWeakRemove: !0,
            }).operationsA;
          for (const s of a)
            e.addOperation(s),
              n.applyOperation(s),
              i.history.setOperationAsUndone(t, s);
        }
      }
    }
    function a(t) {
      t.sort((t, e) => (t.start.isBefore(e.start) ? -1 : 1));
      for (let e = 1; e < t.length; e++) {
        const n = t[e - 1].getJoined(t[e], !0);
        n && (e--, t.splice(e, 2, n));
      }
    }
    function c(t, e) {
      return e.some((e) => e !== t && e.containsRange(t, !0));
    }
    class l extends r {
      execute(t = null) {
        const e = t
            ? this._stack.findIndex((e) => e.batch == t)
            : this._stack.length - 1,
          n = this._stack.splice(e, 1)[0],
          i = this.editor.model.createBatch("transparent");
        this.editor.model.enqueueChange(i, () => {
          this._undo(n.batch, i);
          const t = this.editor.model.document.history.getOperations(
            n.batch.baseVersion
          );
          this._restoreSelection(n.selection.ranges, n.selection.isBackward, t),
            this.fire("revert", n.batch, i);
        }),
          this.refresh();
      }
    }
    class u extends r {
      execute() {
        const t = this._stack.pop(),
          e = this.editor.model.createBatch("transparent");
        this.editor.model.enqueueChange(e, () => {
          const n =
              t.batch.operations[t.batch.operations.length - 1].baseVersion + 1,
            i = this.editor.model.document.history.getOperations(n);
          this._restoreSelection(t.selection.ranges, t.selection.isBackward, i),
            this._undo(t.batch, e);
        }),
          this.refresh();
      }
    }
    class d extends i.a {
      static get pluginName() {
        return "UndoEditing";
      }
      constructor(t) {
        super(t), (this._batchRegistry = new WeakSet());
      }
      init() {
        const t = this.editor;
        (this._undoCommand = new l(t)),
          (this._redoCommand = new u(t)),
          t.commands.add("undo", this._undoCommand),
          t.commands.add("redo", this._redoCommand),
          this.listenTo(
            t.model,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              if (!n.isDocumentOperation) return;
              const i = n.batch,
                s = this._redoCommand._createdBatches.has(i),
                o = this._undoCommand._createdBatches.has(i);
              this._batchRegistry.has(i) ||
                ("transparent" == i.type && !s && !o) ||
                (s
                  ? this._undoCommand.addBatch(i)
                  : o ||
                    (this._undoCommand.addBatch(i),
                    this._redoCommand.clearStack()),
                this._batchRegistry.add(i));
            },
            { priority: "highest" }
          ),
          this.listenTo(this._undoCommand, "revert", (t, e, n) => {
            this._redoCommand.addBatch(n);
          }),
          t.keystrokes.set("CTRL+Z", "undo"),
          t.keystrokes.set("CTRL+Y", "redo"),
          t.keystrokes.set("CTRL+SHIFT+Z", "redo");
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return m;
    });
    var i = n(9),
      s = n(45),
      o = n(225);
    class r extends s.a {
      constructor(t, e) {
        super(t),
          (this._buffer = new o.a(t.model, e)),
          (this._batches = new WeakSet());
      }
      get buffer() {
        return this._buffer;
      }
      destroy() {
        super.destroy(), this._buffer.destroy();
      }
      execute(t = {}) {
        const e = this.editor.model,
          n = e.document,
          i = t.text || "",
          s = i.length,
          o = t.range ? e.createSelection(t.range) : n.selection,
          r = t.resultRange;
        e.enqueueChange(this._buffer.batch, (t) => {
          this._buffer.lock(),
            this._batches.add(this._buffer.batch),
            e.deleteContent(o),
            i &&
              e.insertContent(t.createText(i, n.selection.getAttributes()), o),
            r
              ? t.setSelection(r)
              : o.is("documentSelection") || t.setSelection(o),
            this._buffer.unlock(),
            this._buffer.input(s);
        });
      }
    }
    var a = n(164),
      c = n(83),
      l = n(110),
      u = n(137);
    class d {
      constructor(t) {
        (this.editor = t), (this.editing = this.editor.editing);
      }
      handle(t, e) {
        if (Object(u.a)(t)) this._handleContainerChildrenMutations(t, e);
        else
          for (const n of t)
            this._handleTextMutation(n, e), this._handleTextNodeInsertion(n);
      }
      _handleContainerChildrenMutations(t, e) {
        const n = (function (t) {
          const e = t
            .map((t) => t.node)
            .reduce((t, e) => t.getCommonAncestor(e, { includeSelf: !0 }));
          if (!e) return;
          return e
            .getAncestors({ includeSelf: !0, parentFirst: !0 })
            .find((t) => t.is("containerElement") || t.is("rootElement"));
        })(t);
        if (!n) return;
        const i = this.editor.editing.view.domConverter.mapViewToDom(n),
          s = new l.a(this.editor.editing.view.document),
          o = this.editor.data.toModel(s.domToView(i)).getChild(0),
          r = this.editor.editing.mapper.toModelElement(n);
        if (!r) return;
        const a = Array.from(o.getChildren()),
          u = Array.from(r.getChildren()),
          d = a[a.length - 1],
          m = u[u.length - 1],
          g = d && d.is("element", "softBreak"),
          p = m && !m.is("element", "softBreak");
        g && p && a.pop();
        const b = this.editor.model.schema;
        if (!h(a, b) || !h(u, b)) return;
        const w = a
            .map((t) => (t.is("$text") ? t.data : "@"))
            .join("")
            .replace(/\u00A0/g, " "),
          v = u
            .map((t) => (t.is("$text") ? t.data : "@"))
            .join("")
            .replace(/\u00A0/g, " ");
        if (v === w) return;
        const _ = Object(c.a)(v, w),
          { firstChangeAt: y, insertions: k, deletions: A } = f(_);
        let C = null;
        e && (C = this.editing.mapper.toModelRange(e.getFirstRange()));
        const E = w.substr(y, k),
          O = this.editor.model.createRange(
            this.editor.model.createPositionAt(r, y),
            this.editor.model.createPositionAt(r, y + A)
          );
        this.editor.execute("input", { text: E, range: O, resultRange: C });
      }
      _handleTextMutation(t, e) {
        if ("text" != t.type) return;
        const n = t.newText.replace(/\u00A0/g, " "),
          i = t.oldText.replace(/\u00A0/g, " ");
        if (i === n) return;
        const s = Object(c.a)(i, n),
          { firstChangeAt: o, insertions: r, deletions: a } = f(s);
        let l = null;
        e && (l = this.editing.mapper.toModelRange(e.getFirstRange()));
        const u = this.editing.view.createPositionAt(t.node, o),
          d = this.editing.mapper.toModelPosition(u),
          h = this.editor.model.createRange(d, d.getShiftedBy(a)),
          m = n.substr(o, r);
        this.editor.execute("input", { text: m, range: h, resultRange: l });
      }
      _handleTextNodeInsertion(t) {
        if ("children" != t.type) return;
        const e = Object(u.b)(t),
          n = this.editing.view.createPositionAt(t.node, e.index),
          i = this.editing.mapper.toModelPosition(n),
          s = e.values[0].data;
        this.editor.execute("input", {
          text: s.replace(/\u00A0/g, " "),
          range: this.editor.model.createRange(i),
        });
      }
    }
    function h(t, e) {
      return t.every((t) => e.isInline(t));
    }
    function f(t) {
      let e = null,
        n = null;
      for (let i = 0; i < t.length; i++) {
        "equal" != t[i] && ((e = null === e ? i : e), (n = i));
      }
      let i = 0,
        s = 0;
      for (let o = e; o <= n; o++)
        "insert" != t[o] && i++, "delete" != t[o] && s++;
      return { insertions: s, deletions: i, firstChangeAt: e };
    }
    class m extends i.a {
      static get pluginName() {
        return "Input";
      }
      init() {
        const t = this.editor,
          e = new r(t, t.config.get("typing.undoStep") || 20);
        t.commands.add("input", e),
          Object(a.a)(t),
          (function (t) {
            t.editing.view.document.on("mutations", (e, n, i) => {
              new d(t).handle(n, i);
            });
          })(t);
      }
      isInput(t) {
        return this.editor.commands.get("input")._batches.has(t);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    function* i(t, e) {
      for (const n of e)
        n && t.getAttributeProperties(n[0]).copyOnEnter && (yield n);
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(58),
      s = n(111),
      o = n(120),
      r = n(12);
    class a extends i.a {
      constructor(t) {
        super(t);
        const e = this.document;
        e.on("keydown", (t, n) => {
          if (this.isEnabled && n.keyCode == r.f.enter) {
            const i = new o.a(e, "enter", e.selection.getFirstRange());
            e.fire(i, new s.a(e, n.domEvent, { isSoft: n.shiftKey })),
              i.stop.called && t.stop();
          }
        });
      }
      observe() {}
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return f;
    });
    var i = n(9),
      s = n(61),
      o = n(204),
      r = n(128),
      a = n(12),
      c = n(32),
      l = n(164),
      u = n(28);
    n(352);
    const d = ["before", "after"],
      h = new DOMParser().parseFromString(
        '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>',
        "image/svg+xml"
      ).firstChild;
    class f extends i.a {
      static get pluginName() {
        return "WidgetTypeAround";
      }
      static get requires() {
        return [o.a, r.a];
      }
      constructor(t) {
        super(t), (this._currentFakeCaretModelElement = null);
      }
      init() {
        const t = this.editor,
          e = t.editing.view;
        this.on("change:isEnabled", (n, i, s) => {
          e.change((t) => {
            for (const n of e.document.roots)
              s
                ? t.removeClass("ck-widget__type-around_disabled", n)
                : t.addClass("ck-widget__type-around_disabled", n);
          }),
            s ||
              t.model.change((t) => {
                t.removeSelectionAttribute(c.a);
              });
        }),
          this._enableTypeAroundUIInjection(),
          this._enableInsertingParagraphsOnButtonClick(),
          this._enableInsertingParagraphsOnEnterKeypress(),
          this._enableInsertingParagraphsOnTypingKeystroke(),
          this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(),
          this._enableDeleteIntegration(),
          this._enableInsertContentIntegration(),
          this._enableDeleteContentIntegration();
      }
      destroy() {
        this._currentFakeCaretModelElement = null;
      }
      _insertParagraph(t, e) {
        const n = this.editor,
          i = n.editing.view;
        n.execute("insertParagraph", {
          position: n.model.createPositionAt(t, e),
        }),
          i.focus(),
          i.scrollToTheSelection();
      }
      _listenToIfEnabled(t, e, n, i) {
        this.listenTo(
          t,
          e,
          (...t) => {
            this.isEnabled && n(...t);
          },
          i
        );
      }
      _insertParagraphAccordingToFakeCaretPosition() {
        const t = this.editor.model.document.selection,
          e = Object(c.e)(t);
        if (!e) return !1;
        const n = t.getSelectedElement();
        return this._insertParagraph(n, e), !0;
      }
      _enableTypeAroundUIInjection() {
        const t = this.editor,
          e = t.model.schema,
          n = t.locale.t,
          i = {
            before: n("Insert paragraph before block"),
            after: n("Insert paragraph after block"),
          };
        t.editing.downcastDispatcher.on(
          "insert",
          (t, n, o) => {
            const r = o.mapper.toViewElement(n.item);
            Object(c.f)(r, n.item, e) &&
              (function (t, e, n) {
                const i = t.createUIElement(
                  "div",
                  { class: "ck ck-reset_all ck-widget__type-around" },
                  function (t) {
                    const n = this.toDomElement(t);
                    return (
                      (function (t, e) {
                        for (const n of d) {
                          const i = new s.a({
                            tag: "div",
                            attributes: {
                              class: [
                                "ck",
                                "ck-widget__type-around__button",
                                "ck-widget__type-around__button_" + n,
                              ],
                              title: e[n],
                            },
                            children: [t.ownerDocument.importNode(h, !0)],
                          });
                          t.appendChild(i.render());
                        }
                      })(n, e),
                      (function (t) {
                        const e = new s.a({
                          tag: "div",
                          attributes: {
                            class: ["ck", "ck-widget__type-around__fake-caret"],
                          },
                        });
                        t.appendChild(e.render());
                      })(n),
                      n
                    );
                  }
                );
                t.insert(t.createPositionAt(n, "end"), i);
              })(o.writer, i, r);
          },
          { priority: "low" }
        );
      }
      _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
        const t = this.editor,
          e = t.model,
          n = e.document.selection,
          i = e.schema,
          s = t.editing.view;
        function o(t) {
          return "ck-widget_type-around_show-fake-caret_" + t;
        }
        this._listenToIfEnabled(
          s.document,
          "arrowKey",
          (t, e) => {
            this._handleArrowKeyPress(t, e);
          },
          { context: [u.d, "$text"], priority: "high" }
        ),
          this._listenToIfEnabled(n, "change:range", (e, n) => {
            n.directChange &&
              t.model.change((t) => {
                t.removeSelectionAttribute(c.a);
              });
          }),
          this._listenToIfEnabled(e.document, "change:data", () => {
            const e = n.getSelectedElement();
            if (e) {
              const n = t.editing.mapper.toViewElement(e);
              if (Object(c.f)(n, e, i)) return;
            }
            t.model.change((t) => {
              t.removeSelectionAttribute(c.a);
            });
          }),
          this._listenToIfEnabled(
            t.editing.downcastDispatcher,
            "selection",
            (t, e, n) => {
              const s = n.writer;
              if (this._currentFakeCaretModelElement) {
                const t = n.mapper.toViewElement(
                  this._currentFakeCaretModelElement
                );
                t &&
                  (s.removeClass(d.map(o), t),
                  (this._currentFakeCaretModelElement = null));
              }
              const r = e.selection.getSelectedElement();
              if (!r) return;
              const a = n.mapper.toViewElement(r);
              if (!Object(c.f)(a, r, i)) return;
              const l = Object(c.e)(e.selection);
              l &&
                (s.addClass(o(l), a), (this._currentFakeCaretModelElement = r));
            }
          ),
          this._listenToIfEnabled(
            t.ui.focusTracker,
            "change:isFocused",
            (e, n, i) => {
              i ||
                t.model.change((t) => {
                  t.removeSelectionAttribute(c.a);
                });
            }
          );
      }
      _handleArrowKeyPress(t, e) {
        const n = this.editor,
          i = n.model,
          s = i.document.selection,
          o = i.schema,
          r = n.editing.view,
          l = e.keyCode,
          u = Object(a.e)(l, n.locale.contentLanguageDirection),
          d = r.document.selection.getSelectedElement(),
          h = n.editing.mapper.toModelElement(d);
        let f;
        Object(c.f)(d, h, o)
          ? (f = this._handleArrowKeyPressOnSelectedWidget(u))
          : s.isCollapsed
          ? (f = this._handleArrowKeyPressWhenSelectionNextToAWidget(u))
          : e.shiftKey ||
            (f = this._handleArrowKeyPressWhenNonCollapsedSelection(u)),
          f && (e.preventDefault(), t.stop());
      }
      _handleArrowKeyPressOnSelectedWidget(t) {
        const e = this.editor.model,
          n = e.document.selection,
          i = Object(c.e)(n);
        return e.change((e) => {
          if (!i)
            return e.setSelectionAttribute(c.a, t ? "after" : "before"), !0;
          if (!(i === (t ? "after" : "before")))
            return e.removeSelectionAttribute(c.a), !0;
          return !1;
        });
      }
      _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
        const e = this.editor,
          n = e.model,
          i = n.schema,
          s = e.plugins.get("Widget"),
          o = s._getObjectElementNextToSelection(t),
          r = e.editing.mapper.toViewElement(o);
        return (
          !!Object(c.f)(r, o, i) &&
          (n.change((e) => {
            s._setSelectionOverElement(o),
              e.setSelectionAttribute(c.a, t ? "before" : "after");
          }),
          !0)
        );
      }
      _handleArrowKeyPressWhenNonCollapsedSelection(t) {
        const e = this.editor,
          n = e.model,
          i = n.schema,
          s = e.editing.mapper,
          o = n.document.selection,
          r = t
            ? o.getLastPosition().nodeBefore
            : o.getFirstPosition().nodeAfter,
          a = s.toViewElement(r);
        return (
          !!Object(c.f)(a, r, i) &&
          (n.change((e) => {
            e.setSelection(r, "on"),
              e.setSelectionAttribute(c.a, t ? "after" : "before");
          }),
          !0)
        );
      }
      _enableInsertingParagraphsOnButtonClick() {
        const t = this.editor,
          e = t.editing.view;
        this._listenToIfEnabled(e.document, "mousedown", (n, i) => {
          const s = Object(c.b)(i.domTarget);
          if (!s) return;
          const o = Object(c.d)(s),
            r = Object(c.c)(s, e.domConverter),
            a = t.editing.mapper.toModelElement(r);
          this._insertParagraph(a, o), i.preventDefault(), n.stop();
        });
      }
      _enableInsertingParagraphsOnEnterKeypress() {
        const t = this.editor,
          e = t.model.document.selection,
          n = t.editing.view;
        this._listenToIfEnabled(
          n.document,
          "enter",
          (n, i) => {
            if ("atTarget" != n.eventPhase) return;
            const s = e.getSelectedElement(),
              o = t.editing.mapper.toViewElement(s),
              r = t.model.schema;
            let a;
            this._insertParagraphAccordingToFakeCaretPosition()
              ? (a = !0)
              : Object(c.f)(o, s, r) &&
                (this._insertParagraph(s, i.isSoft ? "before" : "after"),
                (a = !0)),
              a && (i.preventDefault(), n.stop());
          },
          { context: u.d }
        );
      }
      _enableInsertingParagraphsOnTypingKeystroke() {
        const t = this.editor.editing.view,
          e = [a.f.enter, a.f.delete, a.f.backspace];
        this._listenToIfEnabled(
          t.document,
          "keydown",
          (t, n) => {
            e.includes(n.keyCode) ||
              Object(l.b)(n) ||
              this._insertParagraphAccordingToFakeCaretPosition();
          },
          { priority: "high" }
        );
      }
      _enableDeleteIntegration() {
        const t = this.editor,
          e = t.editing.view,
          n = t.model,
          i = n.schema;
        this._listenToIfEnabled(
          e.document,
          "delete",
          (e, s) => {
            if ("atTarget" != e.eventPhase) return;
            const o = Object(c.e)(n.document.selection);
            if (!o) return;
            const r = s.direction,
              a = n.document.selection.getSelectedElement(),
              l = "forward" == r;
            if (("before" === o) === l)
              t.execute("delete", { selection: n.createSelection(a, "on") });
            else {
              const e = i.getNearestSelectionRange(n.createPositionAt(a, o), r);
              if (e)
                if (e.isCollapsed) {
                  const s = n.createSelection(e.start);
                  if (
                    (n.modifySelection(s, { direction: r }),
                    s.focus.isEqual(e.start))
                  ) {
                    const t = (function (t, e) {
                      let n = e;
                      for (const i of e.getAncestors({ parentFirst: !0 })) {
                        if (i.childCount > 1 || t.isLimit(i)) break;
                        n = i;
                      }
                      return n;
                    })(i, e.start.parent);
                    n.deleteContent(n.createSelection(t, "on"), {
                      doNotAutoparagraph: !0,
                    });
                  } else
                    n.change((n) => {
                      n.setSelection(e),
                        t.execute(l ? "deleteForward" : "delete");
                    });
                } else
                  n.change((n) => {
                    n.setSelection(e),
                      t.execute(l ? "deleteForward" : "delete");
                  });
            }
            s.preventDefault(), e.stop();
          },
          { context: u.d }
        );
      }
      _enableInsertContentIntegration() {
        const t = this.editor,
          e = this.editor.model,
          n = e.document.selection;
        this._listenToIfEnabled(
          t.model,
          "insertContent",
          (t, [i, s]) => {
            if (s && !s.is("documentSelection")) return;
            const o = Object(c.e)(n);
            return o
              ? (t.stop(),
                e.change((t) => {
                  const s = n.getSelectedElement(),
                    r = e.createPositionAt(s, o),
                    a = t.createSelection(r),
                    c = e.insertContent(i, a);
                  return t.setSelection(a), c;
                }))
              : void 0;
          },
          { priority: "high" }
        );
      }
      _enableDeleteContentIntegration() {
        const t = this.editor,
          e = this.editor.model.document.selection;
        this._listenToIfEnabled(
          t.model,
          "deleteContent",
          (t, [n]) => {
            if (n && !n.is("documentSelection")) return;
            Object(c.e)(e) && t.stop();
          },
          { priority: "high" }
        );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(6),
      s = n(14),
      o = n(236);
    class r {
      constructor(t, e) {
        (this.model = t),
          (this.testCallback = e),
          (this.hasMatch = !1),
          this.set("isEnabled", !0),
          this.on("change:isEnabled", () => {
            this.isEnabled
              ? this._startListening()
              : (this.stopListening(t.document.selection),
                this.stopListening(t.document));
          }),
          this._startListening();
      }
      _startListening() {
        const t = this.model.document;
        this.listenTo(t.selection, "change:range", (e, { directChange: n }) => {
          n &&
            (t.selection.isCollapsed
              ? this._evaluateTextBeforeSelection("selection")
              : this.hasMatch &&
                (this.fire("unmatched"), (this.hasMatch = !1)));
        }),
          this.listenTo(t, "change:data", (t, e) => {
            "transparent" != e.type &&
              this._evaluateTextBeforeSelection("data", { batch: e });
          });
      }
      _evaluateTextBeforeSelection(t, e = {}) {
        const n = this.model,
          i = n.document.selection,
          s = n.createRange(n.createPositionAt(i.focus.parent, 0), i.focus),
          { text: r, range: a } = Object(o.a)(s, n),
          c = this.testCallback(r);
        if (
          (!c && this.hasMatch && this.fire("unmatched"),
          (this.hasMatch = !!c),
          c)
        ) {
          const n = Object.assign(e, { text: r, range: a });
          "object" == typeof c && Object.assign(n, c),
            this.fire("matched:" + t, n);
        }
      }
    }
    Object(i.default)(r, s.default);
  },
  function (t, e, n) {
    "use strict";
    function i(t, e) {
      let n = t.start;
      return {
        text: Array.from(t.getItems()).reduce(
          (t, i) =>
            i.is("$text") || i.is("$textProxy")
              ? t + i.data
              : ((n = e.createPositionAfter(i)), ""),
          ""
        ),
        range: e.createRange(n, t.end),
      };
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    e.a = function (t, e, n) {
      var i = -1,
        s = t.length;
      e < 0 && (e = -e > s ? 0 : s + e),
        (n = n > s ? s : n) < 0 && (n += s),
        (s = e > n ? 0 : (n - e) >>> 0),
        (e >>>= 0);
      for (var o = Array(s); ++i < s; ) o[i] = t[i + e];
      return o;
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return l;
    });
    var i = n(9),
      s = n(230),
      o = n(34),
      r = n(248),
      a =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
    class c extends i.a {
      static get pluginName() {
        return "UndoUI";
      }
      init() {
        const t = this.editor,
          e = t.locale,
          n = t.t,
          i = "ltr" == e.uiLanguageDirection ? r.a : a,
          s = "ltr" == e.uiLanguageDirection ? a : r.a;
        this._addButton("undo", n("Undo"), "CTRL+Z", i),
          this._addButton("redo", n("Redo"), "CTRL+Y", s);
      }
      _addButton(t, e, n, i) {
        const s = this.editor;
        s.ui.componentFactory.add(t, (r) => {
          const a = s.commands.get(t),
            c = new o.a(r);
          return (
            c.set({ label: e, icon: i, keystroke: n, tooltip: !0 }),
            c.bind("isEnabled").to(a, "isEnabled"),
            this.listenTo(c, "execute", () => {
              s.execute(t), s.editing.view.focus();
            }),
            c
          );
        });
      }
    }
    class l extends i.a {
      static get requires() {
        return [s.a, c];
      }
      static get pluginName() {
        return "Undo";
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    }),
      n.d(e, "b", function () {
        return o;
      });
    var i = n(19);
    function s(t) {
      const e = t.getSelectedElement();
      return e && r(e) ? e : null;
    }
    function o(t) {
      let e = t.getFirstPosition().parent;
      for (; e; ) {
        if (e.is("element") && r(e)) return e;
        e = e.parent;
      }
      return null;
    }
    function r(t) {
      return !!t.getCustomProperty("table") && Object(i.e)(t);
    }
  },
  function (t, e, n) {},
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return l;
    });
    var i = n(9),
      s = n(235),
      o = n(357);
    const r = {
        copyright: { from: "(c)", to: "©" },
        registeredTrademark: { from: "(r)", to: "®" },
        trademark: { from: "(tm)", to: "™" },
        oneHalf: {
          from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i,
          to: [null, "½", null],
        },
        oneThird: {
          from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i,
          to: [null, "⅓", null],
        },
        twoThirds: {
          from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i,
          to: [null, "⅔", null],
        },
        oneForth: {
          from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i,
          to: [null, "¼", null],
        },
        threeQuarters: {
          from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i,
          to: [null, "¾", null],
        },
        lessThanOrEqual: { from: "<=", to: "≤" },
        greaterThanOrEqual: { from: ">=", to: "≥" },
        notEqual: { from: "!=", to: "≠" },
        arrowLeft: { from: "<-", to: "←" },
        arrowRight: { from: "->", to: "→" },
        horizontalEllipsis: { from: "...", to: "…" },
        enDash: { from: /(^| )(--)( )$/, to: [null, "–", null] },
        emDash: { from: /(^| )(---)( )$/, to: [null, "—", null] },
        quotesPrimary: { from: f('"'), to: [null, "“", null, "”"] },
        quotesSecondary: { from: f("'"), to: [null, "‘", null, "’"] },
        quotesPrimaryEnGb: { from: f("'"), to: [null, "‘", null, "’"] },
        quotesSecondaryEnGb: { from: f('"'), to: [null, "“", null, "”"] },
        quotesPrimaryPl: { from: f('"'), to: [null, "„", null, "”"] },
        quotesSecondaryPl: { from: f("'"), to: [null, "‚", null, "’"] },
      },
      a = {
        symbols: ["copyright", "registeredTrademark", "trademark"],
        mathematical: [
          "oneHalf",
          "oneThird",
          "twoThirds",
          "oneForth",
          "threeQuarters",
          "lessThanOrEqual",
          "greaterThanOrEqual",
          "notEqual",
          "arrowLeft",
          "arrowRight",
        ],
        typography: ["horizontalEllipsis", "enDash", "emDash"],
        quotes: ["quotesPrimary", "quotesSecondary"],
      },
      c = ["symbols", "mathematical", "typography", "quotes"];
    class l extends i.a {
      static get requires() {
        return ["Delete", "Input"];
      }
      static get pluginName() {
        return "TextTransformation";
      }
      constructor(t) {
        super(t),
          t.config.define("typing", { transformations: { include: c } });
      }
      init() {
        const t = this.editor.model.document.selection;
        t.on("change:range", () => {
          this.isEnabled = !t.anchor.parent.is("element", "codeBlock");
        }),
          this._enableTransformationWatchers();
      }
      _enableTransformationWatchers() {
        const t = this.editor,
          e = t.model,
          n = t.plugins.get("Input"),
          i = t.plugins.get("Delete"),
          o = (function (t) {
            const e = t.extra || [],
              n = t.remove || [],
              i = (t) => !n.includes(t);
            return (function (t) {
              const e = new Set();
              for (const n of t)
                if (a[n]) for (const t of a[n]) e.add(t);
                else e.add(n);
              return Array.from(e);
            })(t.include.concat(e).filter(i))
              .filter(i)
              .map((t) => r[t] || t)
              .map((t) => ({ from: u(t.from), to: d(t.to) }));
          })(t.config.get("typing.transformations")),
          c = new s.a(t.model, (t) => {
            for (const e of o) {
              if (e.from.test(t)) return { normalizedTransformation: e };
            }
          });
        c.on("matched:data", (t, s) => {
          if (!n.isInput(s.batch)) return;
          const { from: o, to: r } = s.normalizedTransformation,
            a = o.exec(s.text),
            c = r(a.slice(1)),
            l = s.range;
          let u = a.index;
          e.enqueueChange((t) => {
            for (let n = 1; n < a.length; n++) {
              const i = a[n],
                s = c[n - 1];
              if (null == s) {
                u += i.length;
                continue;
              }
              const o = l.start.getShiftedBy(u),
                r = e.createRange(o, o.getShiftedBy(i.length)),
                d = h(o);
              e.insertContent(t.createText(s, d), r), (u += s.length);
            }
            e.enqueueChange(() => {
              i.requestUndoOnBackspace();
            });
          });
        }),
          c.bind("isEnabled").to(this);
      }
    }
    function u(t) {
      return "string" == typeof t ? new RegExp(`(${Object(o.a)(t)})$`) : t;
    }
    function d(t) {
      return "string" == typeof t
        ? () => [t]
        : t instanceof Array
        ? () => t
        : t;
    }
    function h(t) {
      return (t.textNode ? t.textNode : t.nodeAfter).getAttributes();
    }
    function f(t) {
      return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`);
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(1);
    class s extends i.a {
      constructor(t, e) {
        super(t), (this._modelElementName = e);
      }
      refresh() {
        const t = this.editor.plugins.get("ImageUtils"),
          e = t.getClosestSelectedImageElement(
            this.editor.model.document.selection
          );
        "imageBlock" === this._modelElementName
          ? (this.isEnabled = t.isInlineImage(e))
          : (this.isEnabled = t.isBlockImage(e));
      }
      execute() {
        const t = this.editor,
          e = this.editor.model,
          n = t.plugins.get("ImageUtils"),
          i = n.getClosestSelectedImageElement(e.document.selection),
          s = Object.fromEntries(i.getAttributes());
        return s.src || s.uploadId
          ? e.change((t) => {
              const o = Array.from(e.markers).filter((t) =>
                  t.getRange().containsItem(i)
                ),
                r = n.insertImage(
                  s,
                  e.createSelection(i, "on"),
                  this._modelElementName
                );
              if (!r) return null;
              const a = t.createRangeOn(r);
              for (const e of o) {
                const n = e.getRange(),
                  i = "$graveyard" != n.root.rootName ? n.getJoined(a, !0) : a;
                t.updateMarker(e, { range: i });
              }
              return { oldElement: i, newElement: r };
            })
          : null;
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return c;
    });
    var i = n(1),
      s = n(293),
      o = n(2);
    class r extends i.a {
      constructor(t) {
        super(t);
        const e = t.config.get("image.insert.type");
        t.plugins.has("ImageBlockEditing") ||
          ("block" === e && Object(o.u)("image-block-plugin-required")),
          t.plugins.has("ImageInlineEditing") ||
            ("inline" === e && Object(o.u)("image-inline-plugin-required"));
      }
      refresh() {
        this.isEnabled = this.editor.plugins.get("ImageUtils").isImageAllowed();
      }
      execute(t) {
        const e = Object(o.z)(t.source),
          n = this.editor.model.document.selection,
          i = this.editor.plugins.get("ImageUtils"),
          s = Object.fromEntries(n.getAttributes());
        e.forEach((t, e) => {
          const o = n.getSelectedElement();
          if (
            ("string" == typeof t && (t = { src: t }), e && o && i.isImage(o))
          ) {
            const e = this.editor.model.createPositionAfter(o);
            i.insertImage({ ...t, ...s }, e);
          } else i.insertImage({ ...t, ...s });
        });
      }
    }
    var a = n(54);
    class c extends i.j {
      static get requires() {
        return [a.a];
      }
      static get pluginName() {
        return "ImageEditing";
      }
      init() {
        const t = this.editor,
          e = t.conversion;
        t.editing.view.addObserver(s.a),
          e
            .for("upcast")
            .attributeToAttribute({
              view: { name: "img", key: "alt" },
              model: "alt",
            })
            .attributeToAttribute({
              view: { name: "img", key: "srcset" },
              model: {
                key: "srcset",
                value: (t) => {
                  const e = { data: t.getAttribute("srcset") };
                  return (
                    t.hasAttribute("width") &&
                      (e.width = t.getAttribute("width")),
                    e
                  );
                },
              },
            });
        const n = new r(t);
        t.commands.add("insertImage", n), t.commands.add("imageInsert", n);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return d;
    });
    var i = n(1),
      s = n(77),
      o = n(13),
      r = n(108),
      a = n(243),
      c = n(242),
      l = n(54),
      u = n(85);
    class d extends i.j {
      static get requires() {
        return [a.a, l.a, s.b];
      }
      static get pluginName() {
        return "ImageBlockEditing";
      }
      init() {
        const t = this.editor;
        t.model.schema.register("imageBlock", {
          isObject: !0,
          isBlock: !0,
          allowWhere: "$block",
          allowAttributes: ["alt", "src", "srcset"],
        }),
          this._setupConversion(),
          t.plugins.has("ImageInlineEditing") &&
            (t.commands.add(
              "imageTypeBlock",
              new c.a(this.editor, "imageBlock")
            ),
            this._setupClipboardIntegration());
      }
      _setupConversion() {
        const t = this.editor,
          e = t.t,
          n = t.conversion,
          i = t.plugins.get("ImageUtils");
        n.for("dataDowncast").elementToElement({
          model: "imageBlock",
          view: (t, { writer: e }) => Object(u.a)(e, "imageBlock"),
        }),
          n.for("editingDowncast").elementToElement({
            model: "imageBlock",
            view: (t, { writer: n }) =>
              i.toImageWidget(
                Object(u.a)(n, "imageBlock"),
                n,
                e("image widget")
              ),
          }),
          n
            .for("downcast")
            .add(Object(r.a)(i, "imageBlock", "src"))
            .add(Object(r.a)(i, "imageBlock", "alt"))
            .add(Object(r.b)(i, "imageBlock")),
          n
            .for("upcast")
            .elementToElement({
              view: Object(u.c)(t, "imageBlock"),
              model: (t, { writer: e }) =>
                e.createElement(
                  "imageBlock",
                  t.hasAttribute("src") ? { src: t.getAttribute("src") } : null
                ),
            })
            .add(Object(r.c)(i));
      }
      _setupClipboardIntegration() {
        const t = this.editor,
          e = t.model,
          n = t.editing.view,
          i = t.plugins.get("ImageUtils");
        this.listenTo(
          t.plugins.get("ClipboardPipeline"),
          "inputTransformation",
          (s, r) => {
            const a = Array.from(r.content.getChildren());
            let c;
            if (!a.every(i.isInlineImageView)) return;
            c = r.targetRanges
              ? t.editing.mapper.toModelRange(r.targetRanges[0])
              : e.document.selection.getFirstRange();
            const l = e.createSelection(c);
            if ("imageBlock" === Object(u.b)(e.schema, l)) {
              const t = new o.q(n.document),
                e = a.map((e) =>
                  t.createElement("figure", { class: "image" }, e)
                );
              r.content = t.createDocumentFragment(e);
            }
          }
        );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return i;
    });
    const i = {
      tokenUrl:
        "https://33333.cke-cs.com/token/dev/ijrDsqFix838Gh3wGO3F77FSW94BwcLXprJ4APSp3XQ26xsUHTi0jcb1hoBt",
      uploadUrl: "https://33333.cke-cs.com/easyimage/upload/",
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(1),
      s = n(2);
    class o extends i.a {
      constructor(t, e) {
        super(t), (this.type = e);
      }
      refresh() {
        (this.value = this._getValue()),
          (this.isEnabled = this._checkEnabled());
      }
      execute(t = {}) {
        const e = this.editor.model,
          n = e.document,
          i = Array.from(n.selection.getSelectedBlocks()).filter((t) =>
            a(t, e.schema)
          ),
          s = void 0 !== t.forceValue ? !t.forceValue : this.value;
        e.change((t) => {
          if (s) {
            let e = i[i.length - 1].nextSibling,
              n = Number.POSITIVE_INFINITY,
              s = [];
            for (
              ;
              e && "listItem" == e.name && 0 !== e.getAttribute("listIndent");

            ) {
              const t = e.getAttribute("listIndent");
              t < n && (n = t);
              const i = t - n;
              s.push({ element: e, listIndent: i }), (e = e.nextSibling);
            }
            s = s.reverse();
            for (const e of s)
              t.setAttribute("listIndent", e.listIndent, e.element);
          }
          if (!s) {
            let t = Number.POSITIVE_INFINITY;
            for (const e of i)
              e.is("element", "listItem") &&
                e.getAttribute("listIndent") < t &&
                (t = e.getAttribute("listIndent"));
            (t = 0 === t ? 1 : t), r(i, !0, t), r(i, !1, t);
          }
          for (const e of i.reverse())
            s && "listItem" == e.name
              ? t.rename(e, "paragraph")
              : s || "listItem" == e.name
              ? s ||
                "listItem" != e.name ||
                e.getAttribute("listType") == this.type ||
                t.setAttribute("listType", this.type, e)
              : (t.setAttributes({ listType: this.type, listIndent: 0 }, e),
                t.rename(e, "listItem"));
          this.fire("_executeCleanup", i);
        });
      }
      _getValue() {
        const t = Object(s.n)(
          this.editor.model.document.selection.getSelectedBlocks()
        );
        return (
          !!t &&
          t.is("element", "listItem") &&
          t.getAttribute("listType") == this.type
        );
      }
      _checkEnabled() {
        if (this.value) return !0;
        const t = this.editor.model.document.selection,
          e = this.editor.model.schema,
          n = Object(s.n)(t.getSelectedBlocks());
        return !!n && a(n, e);
      }
    }
    function r(t, e, n) {
      const i = e ? t[0] : t[t.length - 1];
      if (i.is("element", "listItem")) {
        let s = i[e ? "previousSibling" : "nextSibling"],
          o = i.getAttribute("listIndent");
        for (
          ;
          s && s.is("element", "listItem") && s.getAttribute("listIndent") >= n;

        )
          o > s.getAttribute("listIndent") &&
            (o = s.getAttribute("listIndent")),
            s.getAttribute("listIndent") == o && t[e ? "unshift" : "push"](s),
            (s = s[e ? "previousSibling" : "nextSibling"]);
      }
    }
    function a(t, e) {
      return e.checkChild(t.parent, "listItem") && !e.isObject(t);
    }
  },
  function (t, e) {
    t.exports = function (t) {
      if (!t.webpackPolyfill) {
        var e = Object.create(t);
        e.children || (e.children = []),
          Object.defineProperty(e, "loaded", {
            enumerable: !0,
            get: function () {
              return e.l;
            },
          }),
          Object.defineProperty(e, "id", {
            enumerable: !0,
            get: function () {
              return e.i;
            },
          }),
          Object.defineProperty(e, "exports", { enumerable: !0 }),
          (e.webpackPolyfill = 1);
      }
      return e;
    };
  },
  function (t, e, n) {
    "use strict";
    e.a =
      '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>';
  },
  function (t, e, n) {},
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return X;
    });
    var i = n(1),
      s = n(17),
      o = n(2);
    function r() {
      return (t) => {
        t.on("element:table", (t, e, n) => {
          const i = e.viewItem;
          if (!n.consumable.test(i, { name: !0 })) return;
          const {
              rows: o,
              headingRows: r,
              headingColumns: a,
            } = (function (t) {
              const e = { headingRows: 0, headingColumns: 0 },
                n = [],
                i = [];
              let s;
              for (const o of Array.from(t.getChildren()))
                if (
                  "tbody" === o.name ||
                  "thead" === o.name ||
                  "tfoot" === o.name
                ) {
                  "thead" !== o.name || s || (s = o);
                  const t = Array.from(o.getChildren()).filter((t) =>
                    t.is("element", "tr")
                  );
                  for (const o of t)
                    if ("thead" === o.parent.name && o.parent === s)
                      e.headingRows++, n.push(o);
                    else {
                      i.push(o);
                      const t = c(o);
                      t > e.headingColumns && (e.headingColumns = t);
                    }
                }
              return (e.rows = [...n, ...i]), e;
            })(i),
            l = {};
          a && (l.headingColumns = a), r && (l.headingRows = r);
          const u = n.writer.createElement("table", l);
          if (n.safeInsert(u, e.modelCursor)) {
            if (
              (n.consumable.consume(i, { name: !0 }),
              o.forEach((t) =>
                n.convertItem(t, n.writer.createPositionAt(u, "end"))
              ),
              n.convertChildren(i, n.writer.createPositionAt(u, "end")),
              u.isEmpty)
            ) {
              const t = n.writer.createElement("tableRow");
              n.writer.insert(t, n.writer.createPositionAt(u, "end")),
                Object(s.a)(n.writer, n.writer.createPositionAt(t, "end"));
            }
            n.updateConversionResult(u, e);
          }
        });
      };
    }
    function a(t) {
      return (e) => {
        e.on(
          "element:" + t,
          (t, e, n) => {
            if (e.modelRange && e.viewItem.isEmpty) {
              const t = e.modelRange.start.nodeAfter,
                i = n.writer.createPositionAt(t, 0);
              n.writer.insertElement("paragraph", i);
            }
          },
          { priority: "low" }
        );
      };
    }
    function c(t) {
      let e = 0,
        n = 0;
      const i = Array.from(t.getChildren()).filter(
        (t) => "th" === t.name || "td" === t.name
      );
      for (; n < i.length && "th" === i[n].name; ) {
        const t = i[n];
        (e += parseInt(t.getAttribute("colspan") || 1)), n++;
      }
      return e;
    }
    var l = n(16),
      u = n(19);
    function d(t = {}) {
      return (e) =>
        e.on("insert:table", (e, n, i) => {
          const s = n.item;
          if (!i.consumable.consume(s, "insert")) return;
          i.consumable.consume(s, "attribute:headingRows:table"),
            i.consumable.consume(s, "attribute:headingColumns:table");
          const o = t && t.asWidget,
            r = i.writer.createContainerElement("figure", { class: "table" }),
            a = i.writer.createContainerElement("table");
          let c;
          var d, h;
          i.writer.insert(i.writer.createPositionAt(r, 0), a),
            o &&
              ((d = r),
              (h = i.writer).setCustomProperty("table", !0, d),
              (c = Object(u.g)(d, h, { hasSelectionHandle: !0 })));
          const f = new l.a(s),
            m = {
              headingRows: s.getAttribute("headingRows") || 0,
              headingColumns: s.getAttribute("headingColumns") || 0,
            },
            b = new Map();
          for (const e of f) {
            const { row: n, cell: o } = e,
              r = s.getChild(n),
              c = b.get(n) || p(a, r, n, m, i);
            b.set(n, c), i.consumable.consume(o, "insert");
            g(e, m, i.writer.createPositionAt(c, "end"), i, t);
          }
          for (const t of s.getChildren()) {
            const e = t.index;
            t.is("element", "tableRow") &&
              !b.has(e) &&
              b.set(e, p(a, t, e, m, i));
          }
          const w = i.mapper.toViewPosition(n.range.start);
          i.mapper.bindElements(s, o ? c : r), i.writer.insert(w, o ? c : r);
        });
    }
    function h(t, e) {
      const { writer: n } = e;
      if (t.parent.is("element", "tableCell"))
        return f(t)
          ? n.createContainerElement("span", {
              class: "ck-table-bogus-paragraph",
            })
          : n.createContainerElement("p");
    }
    function f(t) {
      return 1 === t.parent.childCount && !_(t);
    }
    function m(t, e, n) {
      const { cell: i } = t,
        s = b(t, e),
        o = n.mapper.toViewElement(i);
      o &&
        o.name !== s &&
        (function (t, e, n) {
          const i = n.writer,
            s = n.mapper.toViewElement(t),
            o = i.createEditableElement(e, s.getAttributes()),
            r = Object(u.h)(o, i);
          i.insert(i.createPositionAfter(s), r),
            i.move(i.createRangeIn(s), i.createPositionAt(r, 0)),
            i.remove(i.createRangeOn(s)),
            n.mapper.unbindViewElement(s),
            n.mapper.bindElements(t, r);
        })(i, s, n);
    }
    function g(t, e, n, i, s) {
      const o = s && s.asWidget,
        r = b(t, e),
        a = o
          ? Object(u.h)(i.writer.createEditableElement(r), i.writer)
          : i.writer.createContainerElement(r),
        c = t.cell,
        l = c.getChild(0),
        d = 1 === c.childCount && "paragraph" === l.name;
      if (
        (i.writer.insert(n, a), i.mapper.bindElements(c, a), !o && d && !_(l))
      ) {
        const t = c.getChild(0);
        i.consumable.consume(t, "insert"), i.mapper.bindElements(t, a);
      }
    }
    function p(t, e, n, i, s) {
      s.consumable.consume(e, "insert");
      const o = e.isEmpty
        ? s.writer.createEmptyElement("tr")
        : s.writer.createContainerElement("tr");
      s.mapper.bindElements(e, o);
      const r = i.headingRows,
        a = (function (t, e, n) {
          const i = w(t, e);
          return (
            i ||
            (function (t, e, n) {
              const i = n.writer.createContainerElement(t),
                s = n.writer.createPositionAt(e, "tbody" == t ? "end" : 0);
              return n.writer.insert(s, i), i;
            })(t, e, n)
          );
        })(
          (function (t, e) {
            return t < e.headingRows ? "thead" : "tbody";
          })(n, i),
          t,
          s
        ),
        c = r > 0 && n >= r ? n - r : n,
        l = s.writer.createPositionAt(a, c);
      return s.writer.insert(l, o), o;
    }
    function b(t, e) {
      const { row: n, column: i } = t,
        { headingColumns: s, headingRows: o } = e;
      if (o && o > n) return "th";
      return s && s > i ? "th" : "td";
    }
    function w(t, e) {
      for (const n of e.getChildren()) if (n.name == t) return n;
    }
    function v(t, e, n) {
      const i = w(t, e);
      i && 0 === i.childCount && n.writer.remove(n.writer.createRangeOn(i));
    }
    function _(t) {
      return !![...t.getAttributeKeys()].length;
    }
    class y extends i.a {
      refresh() {
        const t = this.editor.model,
          e = t.document.selection,
          n = t.schema;
        this.isEnabled = (function (t, e) {
          const n = t.getFirstPosition().parent,
            i = n === n.root ? n : n.parent;
          return e.checkChild(i, "table");
        })(e, n);
      }
      execute(t = {}) {
        const e = this.editor.model,
          n = e.document.selection,
          i = this.editor.plugins.get("TableUtils"),
          s = this.editor.config.get("table"),
          o = Object(u.d)(n, e),
          r = s.defaultHeadings.rows,
          a = s.defaultHeadings.columns;
        void 0 === t.headingRows && r && (t.headingRows = r),
          void 0 === t.headingColumns && a && (t.headingColumns = a),
          e.change((n) => {
            const s = i.createTable(n, t);
            e.insertContent(s, o),
              n.setSelection(n.createPositionAt(s.getNodeByPath([0, 0, 0]), 0));
          });
      }
    }
    var k = n(10);
    class A extends i.a {
      constructor(t, e = {}) {
        super(t), (this.order = e.order || "below");
      }
      refresh() {
        const t = this.editor.model.document.selection,
          e = !!Object(k.d)(t).length;
        this.isEnabled = e;
      }
      execute() {
        const t = this.editor,
          e = t.model.document.selection,
          n = t.plugins.get("TableUtils"),
          i = "above" === this.order,
          s = Object(k.d)(e),
          o = Object(k.b)(s),
          r = i ? o.first : o.last,
          a = s[0].findAncestor("table");
        n.insertRows(a, { at: i ? r : r + 1, copyStructureFromAbove: !i });
      }
    }
    class C extends i.a {
      constructor(t, e = {}) {
        super(t), (this.order = e.order || "right");
      }
      refresh() {
        const t = this.editor.model.document.selection,
          e = !!Object(k.d)(t).length;
        this.isEnabled = e;
      }
      execute() {
        const t = this.editor,
          e = t.model.document.selection,
          n = t.plugins.get("TableUtils"),
          i = "left" === this.order,
          s = Object(k.d)(e),
          o = Object(k.a)(s),
          r = i ? o.first : o.last,
          a = s[0].findAncestor("table");
        n.insertColumns(a, { columns: 1, at: i ? r : r + 1 });
      }
    }
    class E extends i.a {
      constructor(t, e = {}) {
        super(t), (this.direction = e.direction || "horizontally");
      }
      refresh() {
        const t = Object(k.d)(this.editor.model.document.selection);
        this.isEnabled = 1 === t.length;
      }
      execute() {
        const t = Object(k.d)(this.editor.model.document.selection)[0],
          e = "horizontally" === this.direction,
          n = this.editor.plugins.get("TableUtils");
        e ? n.splitCellHorizontally(t, 2) : n.splitCellVertically(t, 2);
      }
    }
    var O = n(31);
    class P extends i.a {
      constructor(t, e) {
        super(t),
          (this.direction = e.direction),
          (this.isHorizontal =
            "right" == this.direction || "left" == this.direction);
      }
      refresh() {
        const t = this._getMergeableCell();
        (this.value = t), (this.isEnabled = !!t);
      }
      execute() {
        const t = this.editor.model,
          e = t.document,
          n = Object(k.e)(e.selection)[0],
          i = this.value,
          s = this.direction;
        t.change((t) => {
          const e = "right" == s || "down" == s,
            o = e ? n : i,
            r = e ? i : n,
            a = r.parent;
          !(function (t, e, n) {
            T(t) ||
              (T(e) && n.remove(n.createRangeIn(e)),
              n.move(n.createRangeIn(t), n.createPositionAt(e, "end")));
            n.remove(t);
          })(r, o, t);
          const c = this.isHorizontal ? "colspan" : "rowspan",
            l = parseInt(n.getAttribute(c) || 1),
            u = parseInt(i.getAttribute(c) || 1);
          t.setAttribute(c, l + u, o), t.setSelection(t.createRangeIn(o));
          const d = this.editor.plugins.get("TableUtils"),
            h = a.findAncestor("table");
          Object(O.h)(h, d);
        });
      }
      _getMergeableCell() {
        const t = this.editor.model.document,
          e = Object(k.e)(t.selection)[0];
        if (!e) return;
        const n = this.editor.plugins.get("TableUtils"),
          i = this.isHorizontal
            ? (function (t, e, n) {
                const i = t.parent.parent,
                  o = "right" == e ? t.nextSibling : t.previousSibling,
                  r = (i.getAttribute("headingColumns") || 0) > 0;
                if (!o) return;
                const a = "right" == e ? t : o,
                  c = "right" == e ? o : t,
                  { column: l } = n.getCellLocation(a),
                  { column: u } = n.getCellLocation(c),
                  d = parseInt(a.getAttribute("colspan") || 1),
                  h = Object(s.b)(n, a, i),
                  f = Object(s.b)(n, c, i);
                if (r && h != f) return;
                return l + d === u ? o : void 0;
              })(e, this.direction, n)
            : (function (t, e, n) {
                const i = t.parent,
                  s = i.parent,
                  o = s.getChildIndex(i);
                if (
                  ("down" == e && o === n.getRows(s) - 1) ||
                  ("up" == e && 0 === o)
                )
                  return;
                const r = parseInt(t.getAttribute("rowspan") || 1),
                  a = s.getAttribute("headingRows") || 0,
                  c = "down" == e && o + r === a,
                  u = "up" == e && o === a;
                if (a && (c || u)) return;
                const d = parseInt(t.getAttribute("rowspan") || 1),
                  h = "down" == e ? o + d : o,
                  f = [...new l.a(s, { endRow: h })],
                  m = f.find((e) => e.cell === t).column,
                  g = f.find(
                    ({ row: t, cellHeight: n, column: i }) =>
                      i === m && ("down" == e ? t === h : h === t + n)
                  );
                return g && g.cell;
              })(e, this.direction, n);
        if (!i) return;
        const o = this.isHorizontal ? "rowspan" : "colspan",
          r = parseInt(e.getAttribute(o) || 1);
        return parseInt(i.getAttribute(o) || 1) === r ? i : void 0;
      }
    }
    function T(t) {
      return (
        1 == t.childCount &&
        t.getChild(0).is("element", "paragraph") &&
        t.getChild(0).isEmpty
      );
    }
    class x extends i.a {
      refresh() {
        const t = Object(k.d)(this.editor.model.document.selection),
          e = t[0];
        if (e) {
          const n = e.findAncestor("table"),
            i = this.editor.plugins.get("TableUtils").getRows(n) - 1,
            s = Object(k.b)(t),
            o = 0 === s.first && s.last === i;
          this.isEnabled = !o;
        } else this.isEnabled = !1;
      }
      execute() {
        const t = this.editor.model,
          e = this.editor.plugins.get("TableUtils"),
          n = Object(k.d)(t.document.selection),
          i = Object(k.b)(n),
          s = n[0],
          o = s.findAncestor("table"),
          r = e.getCellLocation(s).column;
        t.change((t) => {
          const n = i.last - i.first + 1;
          e.removeRows(o, { at: i.first, rows: n });
          const s = (function (t, e, n, i) {
            const s = t.getChild(Math.min(e, i - 1));
            let o = s.getChild(0),
              r = 0;
            for (const t of s.getChildren()) {
              if (r > n) return o;
              (o = t), (r += parseInt(t.getAttribute("colspan") || 1));
            }
            return o;
          })(o, i.first, r, e.getRows(o));
          t.setSelection(t.createPositionAt(s, 0));
        });
      }
    }
    class S extends i.a {
      refresh() {
        const t = Object(k.d)(this.editor.model.document.selection),
          e = t[0];
        if (e) {
          const n = e.findAncestor("table"),
            i = this.editor.plugins.get("TableUtils").getColumns(n),
            { first: s, last: o } = Object(k.a)(t);
          this.isEnabled = o - s < i - 1;
        } else this.isEnabled = !1;
      }
      execute() {
        const [t, e] = (function (t) {
            const e = Object(k.d)(t),
              n = e[0],
              i = e.pop(),
              s = [n, i];
            return n.isBefore(i) ? s : s.reverse();
          })(this.editor.model.document.selection),
          n = t.parent.parent,
          i = [...new l.a(n)],
          s = {
            first: i.find((e) => e.cell === t).column,
            last: i.find((t) => t.cell === e).column,
          },
          o = (function (t, e, n, i) {
            return parseInt(n.getAttribute("colspan") || 1) > 1
              ? n
              : e.previousSibling || n.nextSibling
              ? n.nextSibling || e.previousSibling
              : i.first
              ? t.reverse().find(({ column: t }) => t < i.first).cell
              : t.reverse().find(({ column: t }) => t > i.last).cell;
          })(i, t, e, s);
        this.editor.model.change((t) => {
          const e = s.last - s.first + 1;
          this.editor.plugins
            .get("TableUtils")
            .removeColumns(n, { at: s.first, columns: e }),
            t.setSelection(t.createPositionAt(o, 0));
        });
      }
    }
    class I extends i.a {
      refresh() {
        const t = this.editor.model,
          e = Object(k.d)(t.document.selection),
          n = e.length > 0;
        (this.isEnabled = n),
          (this.value =
            n && e.every((t) => this._isInHeading(t, t.parent.parent)));
      }
      execute(t = {}) {
        if (t.forceValue === this.value) return;
        const e = this.editor.model,
          n = Object(k.d)(e.document.selection),
          i = n[0].findAncestor("table"),
          { first: o, last: r } = Object(k.b)(n),
          a = this.value ? o : r + 1,
          c = i.getAttribute("headingRows") || 0;
        e.change((t) => {
          if (a) {
            const e = a > c ? c : 0,
              n = Object(O.e)(i, a, e);
            for (const { cell: e } of n) Object(O.i)(e, a, t);
          }
          Object(s.c)("headingRows", a, i, t, 0);
        });
      }
      _isInHeading(t, e) {
        const n = parseInt(e.getAttribute("headingRows") || 0);
        return !!n && t.parent.index < n;
      }
    }
    class R extends i.a {
      refresh() {
        const t = this.editor.model,
          e = Object(k.d)(t.document.selection),
          n = this.editor.plugins.get("TableUtils"),
          i = e.length > 0;
        (this.isEnabled = i),
          (this.value = i && e.every((t) => Object(s.b)(n, t)));
      }
      execute(t = {}) {
        if (t.forceValue === this.value) return;
        const e = this.editor.model,
          n = Object(k.d)(e.document.selection),
          i = n[0].findAncestor("table"),
          { first: o, last: r } = Object(k.a)(n),
          a = this.value ? o : r + 1;
        e.change((t) => {
          if (a) {
            const e = Object(O.d)(i, a);
            for (const { cell: n, column: i } of e) Object(O.j)(n, i, a, t);
          }
          Object(s.c)("headingColumns", a, i, t, 0);
        });
      }
    }
    var j = n(98);
    class M extends i.a {
      refresh() {
        const t = Object(k.c)(this.editor.model.document.selection);
        this.isEnabled = Object(k.f)(t, this.editor.plugins.get(j.a));
      }
      execute() {
        const t = this.editor.model,
          e = this.editor.plugins.get(j.a);
        t.change((n) => {
          const i = Object(k.c)(t.document.selection),
            o = i.shift(),
            { mergeWidth: r, mergeHeight: a } = (function (t, e, n) {
              let i = 0,
                s = 0;
              for (const t of e) {
                const { row: e, column: o } = n.getCellLocation(t);
                (i = B(t, o, i, "colspan")), (s = B(t, e, s, "rowspan"));
              }
              const { row: o, column: r } = n.getCellLocation(t);
              return { mergeWidth: i - r, mergeHeight: s - o };
            })(o, i, e);
          Object(s.c)("colspan", r, o, n), Object(s.c)("rowspan", a, o, n);
          for (const t of i) V(t, o, n);
          const c = o.findAncestor("table");
          Object(O.h)(c, e), n.setSelection(o, "in");
        });
      }
    }
    function V(t, e, n) {
      N(t) ||
        (N(e) && n.remove(n.createRangeIn(e)),
        n.move(n.createRangeIn(t), n.createPositionAt(e, "end"))),
        n.remove(t);
    }
    function N(t) {
      return (
        1 == t.childCount &&
        t.getChild(0).is("element", "paragraph") &&
        t.getChild(0).isEmpty
      );
    }
    function B(t, e, n, i) {
      const s = parseInt(t.getAttribute(i) || 1);
      return Math.max(n, e + s);
    }
    class D extends i.a {
      constructor(t) {
        super(t), (this.affectsData = !1);
      }
      refresh() {
        const t = Object(k.d)(this.editor.model.document.selection);
        this.isEnabled = t.length > 0;
      }
      execute() {
        const t = this.editor.model,
          e = Object(k.d)(t.document.selection),
          n = Object(k.b)(e),
          i = e[0].findAncestor("table"),
          s = [];
        for (let e = n.first; e <= n.last; e++)
          for (const n of i.getChild(e).getChildren())
            s.push(t.createRangeOn(n));
        t.change((t) => {
          t.setSelection(s);
        });
      }
    }
    class F extends i.a {
      constructor(t) {
        super(t), (this.affectsData = !1);
      }
      refresh() {
        const t = Object(k.d)(this.editor.model.document.selection);
        this.isEnabled = t.length > 0;
      }
      execute() {
        const t = this.editor.model,
          e = Object(k.d)(t.document.selection),
          n = e[0],
          i = e.pop(),
          s = n.findAncestor("table"),
          o = this.editor.plugins.get("TableUtils"),
          r = o.getCellLocation(n),
          a = o.getCellLocation(i),
          c = Math.min(r.column, a.column),
          u = Math.max(r.column, a.column),
          d = [];
        for (const e of new l.a(s, { startColumn: c, endColumn: u }))
          d.push(t.createRangeOn(e.cell));
        t.change((t) => {
          t.setSelection(d);
        });
      }
    }
    function z(t) {
      t.document.registerPostFixer((e) =>
        (function (t, e) {
          const n = e.document.differ.getChanges();
          let i = !1;
          const s = new Set();
          for (const e of n) {
            let n;
            "table" == e.name &&
              "insert" == e.type &&
              (n = e.position.nodeAfter),
              ("tableRow" != e.name && "tableCell" != e.name) ||
                (n = e.position.findAncestor("table")),
              W(e) && (n = e.range.start.findAncestor("table")),
              n &&
                !s.has(n) &&
                ((i = L(n, t) || i), (i = H(n, t) || i), s.add(n));
          }
          return i;
        })(e, t)
      );
    }
    function L(t, e) {
      let n = !1;
      const i = (function (t) {
        const e = parseInt(t.getAttribute("headingRows") || 0),
          n = Array.from(t.getChildren()).reduce(
            (t, e) => (e.is("element", "tableRow") ? t + 1 : t),
            0
          ),
          i = [];
        for (const { row: s, cell: o, cellHeight: r } of new l.a(t)) {
          if (r < 2) continue;
          const t = s < e ? e : n;
          if (s + r > t) {
            const e = t - s;
            i.push({ cell: o, rowspan: e });
          }
        }
        return i;
      })(t);
      if (i.length) {
        n = !0;
        for (const t of i) Object(s.c)("rowspan", t.rowspan, t.cell, e, 1);
      }
      return n;
    }
    function H(t, e) {
      let n = !1;
      const i = (function (t) {
          const e = new Array(t.childCount).fill(0);
          for (const { rowIndex: n } of new l.a(t, { includeAllSlots: !0 }))
            e[n]++;
          return e;
        })(t),
        o = [];
      for (const [e, n] of i.entries())
        !n && t.getChild(e).is("element", "tableRow") && o.push(e);
      if (o.length) {
        n = !0;
        for (const n of o.reverse()) e.remove(t.getChild(n)), i.splice(n, 1);
      }
      const r = i.filter((e, n) => t.getChild(n).is("element", "tableRow")),
        a = r[0];
      if (!r.every((t) => t === a)) {
        const i = r.reduce((t, e) => (e > t ? e : t), 0);
        for (const [o, a] of r.entries()) {
          const r = i - a;
          if (r) {
            for (let n = 0; n < r; n++)
              Object(s.a)(e, e.createPositionAt(t.getChild(o), "end"));
            n = !0;
          }
        }
      }
      return n;
    }
    function W(t) {
      const e = "attribute" === t.type,
        n = t.attributeKey;
      return e && ("headingRows" === n || "colspan" === n || "rowspan" === n);
    }
    function q(t) {
      t.document.registerPostFixer((e) =>
        (function (t, e) {
          const n = e.document.differ.getChanges();
          let i = !1;
          for (const e of n)
            "insert" == e.type &&
              "table" == e.name &&
              (i = $(e.position.nodeAfter, t) || i),
              "insert" == e.type &&
                "tableRow" == e.name &&
                (i = U(e.position.nodeAfter, t) || i),
              "insert" == e.type &&
                "tableCell" == e.name &&
                (i = K(e.position.nodeAfter, t) || i),
              G(e) && (i = K(e.position.parent, t) || i);
          return i;
        })(e, t)
      );
    }
    function $(t, e) {
      let n = !1;
      for (const i of t.getChildren())
        i.is("element", "tableRow") && (n = U(i, e) || n);
      return n;
    }
    function U(t, e) {
      let n = !1;
      for (const i of t.getChildren()) n = K(i, e) || n;
      return n;
    }
    function K(t, e) {
      if (0 == t.childCount) return e.insertElement("paragraph", t), !0;
      const n = Array.from(t.getChildren()).filter((t) => t.is("$text"));
      for (const t of n) e.wrap(e.createRangeOn(t), "paragraph");
      return !!n.length;
    }
    function G(t) {
      return (
        !(!t.position || !t.position.parent.is("element", "tableCell")) &&
        (("insert" == t.type && "$text" == t.name) || "remove" == t.type)
      );
    }
    function J(t, e) {
      t.document.registerPostFixer(() =>
        (function (t, e) {
          const n = new Set();
          for (const e of t.getChanges()) {
            const t =
              "attribute" == e.type ? e.range.start.parent : e.position.parent;
            t.is("element", "tableCell") && n.add(t);
          }
          for (const i of n.values())
            for (const n of [...i.getChildren()].filter((t) => Q(t, e)))
              t.refreshItem(n);
          return !1;
        })(t.document.differ, e)
      );
    }
    function Q(t, e) {
      if (!t.is("element", "paragraph")) return !1;
      const n = e.toViewElement(t);
      return !!n && f(t) !== n.is("element", "span");
    }
    function Y(t) {
      t.document.registerPostFixer(() =>
        (function (t) {
          const e = t.document.differ,
            n = new Set();
          for (const t of e.getChanges())
            if ("attribute" === t.type) {
              const e = t.range.start.nodeAfter;
              e &&
                e.is("element", "table") &&
                "headingRows" === t.attributeKey &&
                n.add(e);
            } else if ("insert" === t.type || "remove" === t.type)
              if ("tableRow" === t.name) {
                const e = t.position.findAncestor("table"),
                  i = e.getAttribute("headingRows") || 0;
                t.position.offset < i && n.add(e);
              } else if ("tableCell" === t.name) {
                const e = t.position.findAncestor("table"),
                  i = e.getAttribute("headingColumns") || 0;
                t.position.offset < i && n.add(e);
              }
          if (n.size) {
            for (const t of n.values()) e.refreshItem(t);
            return !0;
          }
          return !1;
        })(t)
      );
    }
    n(360);
    class X extends i.j {
      static get pluginName() {
        return "TableEditing";
      }
      init() {
        const t = this.editor,
          e = t.model,
          n = e.schema,
          i = t.conversion;
        n.register("table", {
          allowWhere: "$block",
          allowAttributes: ["headingRows", "headingColumns"],
          isObject: !0,
          isBlock: !0,
        }),
          n.register("tableRow", { allowIn: "table", isLimit: !0 }),
          n.register("tableCell", {
            allowIn: "tableRow",
            allowChildren: "$block",
            allowAttributes: ["colspan", "rowspan"],
            isLimit: !0,
            isSelectable: !0,
          }),
          i.for("upcast").add((t) => {
            t.on("element:figure", (t, e, n) => {
              if (
                !n.consumable.test(e.viewItem, { name: !0, classes: "table" })
              )
                return;
              const i = (function (t) {
                for (const e of t.getChildren())
                  if (e.is("element", "table")) return e;
              })(e.viewItem);
              if (!i || !n.consumable.test(i, { name: !0 })) return;
              n.consumable.consume(e.viewItem, { name: !0, classes: "table" });
              const s = n.convertItem(i, e.modelCursor),
                r = Object(o.n)(s.modelRange.getItems());
              r
                ? (n.convertChildren(
                    e.viewItem,
                    n.writer.createPositionAt(r, "end")
                  ),
                  n.updateConversionResult(r, e))
                : n.consumable.revert(e.viewItem, {
                    name: !0,
                    classes: "table",
                  });
            });
          }),
          i.for("upcast").add(r()),
          i.for("editingDowncast").add(d({ asWidget: !0 })),
          i.for("dataDowncast").add(d()),
          i.for("upcast").elementToElement({ model: "tableRow", view: "tr" }),
          i.for("upcast").add((t) => {
            t.on(
              "element:tr",
              (t, e) => {
                e.viewItem.isEmpty && 0 == e.modelCursor.index && t.stop();
              },
              { priority: "high" }
            );
          }),
          i.for("editingDowncast").add((t) =>
            t.on("insert:tableRow", (t, e, n) => {
              const i = e.item;
              if (!n.consumable.consume(i, "insert")) return;
              const s = i.parent,
                o = (function (t) {
                  for (const e of t.getChildren())
                    if ("table" === e.name) return e;
                })(n.mapper.toViewElement(s)),
                r = s.getChildIndex(i),
                a = new l.a(s, { row: r }),
                c = {
                  headingRows: s.getAttribute("headingRows") || 0,
                  headingColumns: s.getAttribute("headingColumns") || 0,
                },
                u = new Map();
              for (const t of a) {
                const e = u.get(r) || p(o, i, r, c, n);
                u.set(r, e),
                  n.consumable.consume(t.cell, "insert"),
                  g(t, c, n.writer.createPositionAt(e, "end"), n, {
                    asWidget: !0,
                  });
              }
            })
          ),
          i.for("editingDowncast").add((t) =>
            t.on(
              "remove:tableRow",
              (t, e, n) => {
                t.stop();
                const i = n.writer,
                  s = n.mapper,
                  o = s
                    .toViewPosition(e.position)
                    .getLastMatchingPosition(
                      (t) => !t.item.is("element", "tr")
                    ).nodeAfter,
                  r = o.parent.parent,
                  a = i.createRangeOn(o),
                  c = i.remove(a);
                for (const t of i.createRangeIn(c).getItems())
                  s.unbindViewElement(t);
                v("thead", r, n), v("tbody", r, n);
              },
              { priority: "higher" }
            )
          ),
          i.for("upcast").elementToElement({ model: "tableCell", view: "td" }),
          i.for("upcast").elementToElement({ model: "tableCell", view: "th" }),
          i.for("upcast").add(a("td")),
          i.for("upcast").add(a("th")),
          i.for("editingDowncast").add((t) =>
            t.on("insert:tableCell", (t, e, n) => {
              const i = e.item;
              if (!n.consumable.consume(i, "insert")) return;
              const s = i.parent,
                o = s.parent,
                r = o.getChildIndex(s),
                a = new l.a(o, { row: r }),
                c = {
                  headingRows: o.getAttribute("headingRows") || 0,
                  headingColumns: o.getAttribute("headingColumns") || 0,
                };
              for (const t of a)
                if (t.cell === i) {
                  const e = n.mapper.toViewElement(s);
                  return void g(
                    t,
                    c,
                    n.writer.createPositionAt(e, s.getChildIndex(i)),
                    n,
                    { asWidget: !0 }
                  );
                }
            })
          ),
          i.for("editingDowncast").elementToElement({
            model: "paragraph",
            view: h,
            converterPriority: "high",
          }),
          i
            .for("downcast")
            .attributeToAttribute({ model: "colspan", view: "colspan" }),
          i.for("upcast").attributeToAttribute({
            model: { key: "colspan", value: Z("colspan") },
            view: "colspan",
          }),
          i
            .for("downcast")
            .attributeToAttribute({ model: "rowspan", view: "rowspan" }),
          i.for("upcast").attributeToAttribute({
            model: { key: "rowspan", value: Z("rowspan") },
            view: "rowspan",
          }),
          i.for("editingDowncast").add((t) =>
            t.on("attribute:headingColumns:table", (t, e, n) => {
              const i = e.item;
              if (!n.consumable.consume(e.item, t.name)) return;
              const s = {
                  headingRows: i.getAttribute("headingRows") || 0,
                  headingColumns: i.getAttribute("headingColumns") || 0,
                },
                o = e.attributeOldValue,
                r = e.attributeNewValue,
                a = (o > r ? o : r) - 1;
              for (const t of new l.a(i, { endColumn: a })) m(t, s, n);
            })
          ),
          t.data.mapper.on("modelToViewPosition", (t, e) => {
            const n = e.modelPosition.parent,
              i = e.modelPosition.nodeBefore;
            if (!n.is("element", "tableCell")) return;
            if (!i || !i.is("element", "paragraph")) return;
            const s = e.mapper.toViewElement(i),
              o = e.mapper.toViewElement(n);
            s === o &&
              (e.viewPosition = e.mapper.findPositionIn(o, i.maxOffset));
          }),
          t.config.define("table.defaultHeadings.rows", 0),
          t.config.define("table.defaultHeadings.columns", 0),
          t.commands.add("insertTable", new y(t)),
          t.commands.add("insertTableRowAbove", new A(t, { order: "above" })),
          t.commands.add("insertTableRowBelow", new A(t, { order: "below" })),
          t.commands.add("insertTableColumnLeft", new C(t, { order: "left" })),
          t.commands.add(
            "insertTableColumnRight",
            new C(t, { order: "right" })
          ),
          t.commands.add("removeTableRow", new x(t)),
          t.commands.add("removeTableColumn", new S(t)),
          t.commands.add(
            "splitTableCellVertically",
            new E(t, { direction: "vertically" })
          ),
          t.commands.add(
            "splitTableCellHorizontally",
            new E(t, { direction: "horizontally" })
          ),
          t.commands.add("mergeTableCells", new M(t)),
          t.commands.add(
            "mergeTableCellRight",
            new P(t, { direction: "right" })
          ),
          t.commands.add("mergeTableCellLeft", new P(t, { direction: "left" })),
          t.commands.add("mergeTableCellDown", new P(t, { direction: "down" })),
          t.commands.add("mergeTableCellUp", new P(t, { direction: "up" })),
          t.commands.add("setTableColumnHeader", new R(t)),
          t.commands.add("setTableRowHeader", new I(t)),
          t.commands.add("selectTableRow", new D(t)),
          t.commands.add("selectTableColumn", new F(t)),
          Y(e),
          z(e),
          J(e, t.editing.mapper),
          q(e);
      }
      static get requires() {
        return [j.a];
      }
    }
    function Z(t) {
      return (e) => {
        const n = parseInt(e.getAttribute(t));
        return Number.isNaN(n) || n <= 0 ? null : n;
      };
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(1),
      s = n(296),
      o = n(4);
    class r extends i.j {
      static get pluginName() {
        return "BoldUI";
      }
      init() {
        const t = this.editor,
          e = t.t;
        t.ui.componentFactory.add("bold", (n) => {
          const i = t.commands.get("bold"),
            s = new o.e(n);
          return (
            s.set({
              label: e("Bold"),
              icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>',
              keystroke: "CTRL+B",
              tooltip: !0,
              isToggleable: !0,
            }),
            s.bind("isOn", "isEnabled").to(i, "value", "isEnabled"),
            this.listenTo(s, "execute", () => {
              t.execute("bold"), t.editing.view.focus();
            }),
            s
          );
        });
      }
    }
    class a extends i.j {
      static get requires() {
        return [s.a, r];
      }
      static get pluginName() {
        return "Bold";
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(1),
      s = n(297),
      o = n(4);
    class r extends i.j {
      static get pluginName() {
        return "ItalicUI";
      }
      init() {
        const t = this.editor,
          e = t.t;
        t.ui.componentFactory.add("italic", (n) => {
          const i = t.commands.get("italic"),
            s = new o.e(n);
          return (
            s.set({
              label: e("Italic"),
              icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>',
              keystroke: "CTRL+I",
              tooltip: !0,
              isToggleable: !0,
            }),
            s.bind("isOn", "isEnabled").to(i, "value", "isEnabled"),
            this.listenTo(s, "execute", () => {
              t.execute("italic"), t.editing.view.focus();
            }),
            s
          );
        });
      }
    }
    class a extends i.j {
      static get requires() {
        return [s.a, r];
      }
      static get pluginName() {
        return "Italic";
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return w;
    });
    var i = n(1),
      s = n(77),
      o = n(130),
      r = n(9),
      a = n(12),
      c = n(45);
    class l extends c.a {
      constructor(t) {
        super(t), (this.affectsData = !1);
      }
      execute() {
        const t = this.editor.model,
          e = t.document.selection;
        let n = t.schema.getLimitElement(e);
        if (e.containsEntireContent(n) || !u(t.schema, n))
          do {
            if (((n = n.parent), !n)) return;
          } while (!u(t.schema, n));
        t.change((t) => {
          t.setSelection(n, "in");
        });
      }
    }
    function u(t, e) {
      return (
        t.isLimit(e) &&
        (t.checkChild(e, "$text") || t.checkChild(e, "paragraph"))
      );
    }
    const d = Object(a.g)("Ctrl+A");
    class h extends r.a {
      static get pluginName() {
        return "SelectAllEditing";
      }
      init() {
        const t = this.editor,
          e = t.editing.view.document;
        t.commands.add("selectAll", new l(t)),
          this.listenTo(e, "keydown", (e, n) => {
            Object(a.a)(n) === d &&
              (t.execute("selectAll"), n.preventDefault());
          });
      }
    }
    var f = n(34);
    class m extends r.a {
      static get pluginName() {
        return "SelectAllUI";
      }
      init() {
        const t = this.editor;
        t.ui.componentFactory.add("selectAll", (e) => {
          const n = t.commands.get("selectAll"),
            i = new f.a(e),
            s = e.t;
          return (
            i.set({
              label: s("Select all"),
              icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>',
              keystroke: "Ctrl+A",
              tooltip: !0,
            }),
            i.bind("isOn", "isEnabled").to(n, "value", "isEnabled"),
            this.listenTo(i, "execute", () => {
              t.execute("selectAll"), t.editing.view.focus();
            }),
            i
          );
        });
      }
    }
    class g extends r.a {
      static get requires() {
        return [h, m];
      }
      static get pluginName() {
        return "SelectAll";
      }
    }
    var p = n(33),
      b = n(238);
    class w extends i.j {
      static get requires() {
        return [s.a, o.a, g, o.b, p.e, b.a];
      }
      static get pluginName() {
        return "Essentials";
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return i.a;
    });
    var i = n(180);
    n(274);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return l;
    });
    var i = n(256),
      s = n(49),
      o = n(289),
      r = n(290),
      a = n(1);
    class c extends a.j {
      static get pluginName() {
        return "ListUI";
      }
      init() {
        const t = this.editor.t;
        Object(s.a)(this.editor, "numberedList", t("Numbered List"), o.a),
          Object(s.a)(this.editor, "bulletedList", t("Bulleted List"), r.a);
      }
    }
    class l extends a.j {
      static get requires() {
        return [i.a, c];
      }
      static get pluginName() {
        return "List";
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return C;
    });
    var i = n(246),
      s = n(1),
      o = n(2);
    class r extends s.a {
      constructor(t, e) {
        super(t), (this._indentBy = "forward" == e ? 1 : -1);
      }
      refresh() {
        this.isEnabled = this._checkEnabled();
      }
      execute() {
        const t = this.editor.model,
          e = t.document;
        let n = Array.from(e.selection.getSelectedBlocks());
        t.change((t) => {
          const e = n[n.length - 1];
          let i = e.nextSibling;
          for (
            ;
            i &&
            "listItem" == i.name &&
            i.getAttribute("listIndent") > e.getAttribute("listIndent");

          )
            n.push(i), (i = i.nextSibling);
          this._indentBy < 0 && (n = n.reverse());
          for (const e of n) {
            const n = e.getAttribute("listIndent") + this._indentBy;
            n < 0
              ? t.rename(e, "paragraph")
              : t.setAttribute("listIndent", n, e);
          }
          this.fire("_executeCleanup", n);
        });
      }
      _checkEnabled() {
        const t = Object(o.n)(
          this.editor.model.document.selection.getSelectedBlocks()
        );
        if (!t || !t.is("element", "listItem")) return !1;
        if (this._indentBy > 0) {
          const e = t.getAttribute("listIndent"),
            n = t.getAttribute("listType");
          let i = t.previousSibling;
          for (
            ;
            i &&
            i.is("element", "listItem") &&
            i.getAttribute("listIndent") >= e;

          ) {
            if (i.getAttribute("listIndent") == e)
              return i.getAttribute("listType") == n;
            i = i.previousSibling;
          }
          return !1;
        }
        return !0;
      }
    }
    var a = n(130),
      c = n(33),
      l = n(13),
      u = n(49);
    function d(t) {
      return (e, n, i) => {
        const s = i.consumable;
        if (
          !s.test(n.item, "insert") ||
          !s.test(n.item, "attribute:listType") ||
          !s.test(n.item, "attribute:listIndent")
        )
          return;
        s.consume(n.item, "insert"),
          s.consume(n.item, "attribute:listType"),
          s.consume(n.item, "attribute:listIndent");
        const o = n.item,
          r = Object(u.c)(o, i);
        Object(u.f)(o, r, i, t);
      };
    }
    function h(t, e, n) {
      if (!n.consumable.consume(e.item, "attribute:listType")) return;
      const i = n.mapper.toViewElement(e.item),
        s = n.writer;
      s.breakContainer(s.createPositionBefore(i)),
        s.breakContainer(s.createPositionAfter(i));
      const o = i.parent,
        r = "numbered" == e.attributeNewValue ? "ol" : "ul";
      s.rename(r, o);
    }
    function f(t, e, n) {
      const i = n.mapper.toViewElement(e.item).parent,
        s = n.writer;
      Object(u.g)(s, i, i.nextSibling), Object(u.g)(s, i.previousSibling, i);
      for (const t of e.item.getChildren()) n.consumable.consume(t, "insert");
    }
    function m(t, e, n) {
      if ("listItem" != e.item.name) {
        let t = n.mapper.toViewPosition(e.range.start);
        const i = n.writer,
          s = [];
        for (
          ;
          ("ul" == t.parent.name || "ol" == t.parent.name) &&
          ((t = i.breakContainer(t)), "li" == t.parent.name);

        ) {
          const e = t,
            n = i.createPositionAt(t.parent, "end");
          if (!e.isEqual(n)) {
            const t = i.remove(i.createRange(e, n));
            s.push(t);
          }
          t = i.createPositionAfter(t.parent);
        }
        if (s.length > 0) {
          for (let e = 0; e < s.length; e++) {
            const n = t.nodeBefore;
            if (((t = i.insert(t, s[e]).end), e > 0)) {
              const e = Object(u.g)(i, n, n.nextSibling);
              e && e.parent == n && t.offset--;
            }
          }
          Object(u.g)(i, t.nodeBefore, t.nodeAfter);
        }
      }
    }
    function g(t, e, n) {
      const i = n.mapper.toViewPosition(e.position),
        s = i.nodeBefore,
        o = i.nodeAfter;
      Object(u.g)(n.writer, s, o);
    }
    function p(t, e, n) {
      if (n.consumable.consume(e.viewItem, { name: !0 })) {
        const t = n.writer,
          i = t.createElement("listItem"),
          s = (function (t) {
            let e = 0,
              n = t.parent;
            for (; n; ) {
              if (n.is("element", "li")) e++;
              else {
                const t = n.previousSibling;
                t && t.is("element", "li") && e++;
              }
              n = n.parent;
            }
            return e;
          })(e.viewItem);
        t.setAttribute("listIndent", s, i);
        const o =
          e.viewItem.parent && "ol" == e.viewItem.parent.name
            ? "numbered"
            : "bulleted";
        if ((t.setAttribute("listType", o, i), !n.safeInsert(i, e.modelCursor)))
          return;
        const r = (function (t, e, n) {
          const { writer: i, schema: s } = n;
          let o = i.createPositionAfter(t);
          for (const r of e)
            if ("ul" == r.name || "ol" == r.name)
              o = n.convertItem(r, o).modelCursor;
            else {
              const e = n.convertItem(r, i.createPositionAt(t, "end")),
                a = e.modelRange.start.nodeAfter;
              a &&
                a.is("element") &&
                !s.checkChild(t, a.name) &&
                ((t = e.modelCursor.parent.is("element", "listItem")
                  ? e.modelCursor.parent
                  : y(e.modelCursor)),
                (o = i.createPositionAfter(t)));
            }
          return o;
        })(i, e.viewItem.getChildren(), n);
        (e.modelRange = t.createRange(e.modelCursor, r)),
          n.updateConversionResult(i, e);
      }
    }
    function b(t, e, n) {
      if (n.consumable.test(e.viewItem, { name: !0 })) {
        const t = Array.from(e.viewItem.getChildren());
        for (const e of t) {
          !(e.is("element", "li") || A(e)) && e._remove();
        }
      }
    }
    function w(t, e, n) {
      if (n.consumable.test(e.viewItem, { name: !0 })) {
        if (0 === e.viewItem.childCount) return;
        const t = [...e.viewItem.getChildren()];
        let n = !1;
        for (const e of t) n && !A(e) && e._remove(), A(e) && (n = !0);
      }
    }
    function v(t) {
      return (e, n) => {
        if (n.isPhantom) return;
        const i = n.modelPosition.nodeBefore;
        if (i && i.is("element", "listItem")) {
          const e = n.mapper.toViewElement(i),
            s = e.getAncestors().find(A),
            o = t.createPositionAt(e, 0).getWalker();
          for (const t of o) {
            if ("elementStart" == t.type && t.item.is("element", "li")) {
              n.viewPosition = t.previousPosition;
              break;
            }
            if ("elementEnd" == t.type && t.item == s) {
              n.viewPosition = t.nextPosition;
              break;
            }
          }
        }
      };
    }
    function _(t, [e, n]) {
      let i,
        s = e.is("documentFragment") ? e.getChild(0) : e;
      if (
        ((i = n ? this.createSelection(n) : this.document.selection),
        s && s.is("element", "listItem"))
      ) {
        const t = i.getFirstPosition();
        let e = null;
        if (
          (t.parent.is("element", "listItem")
            ? (e = t.parent)
            : t.nodeBefore &&
              t.nodeBefore.is("element", "listItem") &&
              (e = t.nodeBefore),
          e)
        ) {
          const t = e.getAttribute("listIndent");
          if (t > 0)
            for (; s && s.is("element", "listItem"); )
              s._setAttribute("listIndent", s.getAttribute("listIndent") + t),
                (s = s.nextSibling);
        }
      }
    }
    function y(t) {
      const e = new l.p({ startPosition: t });
      let n;
      do {
        n = e.next();
      } while (!n.value.item.is("element", "listItem"));
      return n.value.item;
    }
    function k(t, e, n, i, s, o) {
      const r = Object(u.d)(e.nodeBefore, {
          sameIndent: !0,
          smallerIndent: !0,
          listIndent: t,
          foo: "b",
        }),
        a = s.mapper,
        c = s.writer,
        l = r ? r.getAttribute("listIndent") : null;
      let d;
      if (r)
        if (l == t) {
          const t = a.toViewElement(r).parent;
          d = c.createPositionAfter(t);
        } else {
          const t = o.createPositionAt(r, "end");
          d = a.toViewPosition(t);
        }
      else d = n;
      d = Object(u.h)(d);
      for (const t of [...i.getChildren()])
        A(t) &&
          ((d = c.move(c.createRangeOn(t), d).end),
          Object(u.g)(c, t, t.nextSibling),
          Object(u.g)(c, t.previousSibling, t));
    }
    function A(t) {
      return t.is("element", "ol") || t.is("element", "ul");
    }
    class C extends s.j {
      static get pluginName() {
        return "ListEditing";
      }
      static get requires() {
        return [a.a, c.a];
      }
      init() {
        const t = this.editor;
        t.model.schema.register("listItem", {
          inheritAllFrom: "$block",
          allowAttributes: ["listType", "listIndent"],
        });
        const e = t.data,
          n = t.editing;
        var s;
        t.model.document.registerPostFixer((e) =>
          (function (t, e) {
            const n = t.document.differ.getChanges(),
              i = new Map();
            let s = !1;
            for (const i of n)
              if ("insert" == i.type && "listItem" == i.name) o(i.position);
              else if ("insert" == i.type && "listItem" != i.name) {
                if ("$text" != i.name) {
                  const n = i.position.nodeAfter;
                  n.hasAttribute("listIndent") &&
                    (e.removeAttribute("listIndent", n), (s = !0)),
                    n.hasAttribute("listType") &&
                      (e.removeAttribute("listType", n), (s = !0)),
                    n.hasAttribute("listStyle") &&
                      (e.removeAttribute("listStyle", n), (s = !0));
                  for (const e of Array.from(t.createRangeIn(n)).filter((t) =>
                    t.item.is("element", "listItem")
                  ))
                    o(e.previousPosition);
                }
                o(i.position.getShiftedBy(i.length));
              } else
                "remove" == i.type && "listItem" == i.name
                  ? o(i.position)
                  : (("attribute" == i.type &&
                      "listIndent" == i.attributeKey) ||
                      ("attribute" == i.type &&
                        "listType" == i.attributeKey)) &&
                    o(i.range.start);
            for (const t of i.values()) r(t), a(t);
            return s;
            function o(t) {
              const e = t.nodeBefore;
              if (e && e.is("element", "listItem")) {
                let t = e;
                if (i.has(t)) return;
                for (
                  let e = t.previousSibling;
                  e && e.is("element", "listItem");
                  e = t.previousSibling
                )
                  if (((t = e), i.has(t))) return;
                i.set(e, t);
              } else {
                const e = t.nodeAfter;
                e && e.is("element", "listItem") && i.set(e, e);
              }
            }
            function r(t) {
              let n = 0,
                i = null;
              for (; t && t.is("element", "listItem"); ) {
                const o = t.getAttribute("listIndent");
                if (o > n) {
                  let r;
                  null === i
                    ? ((i = o - n), (r = n))
                    : (i > o && (i = o), (r = o - i)),
                    e.setAttribute("listIndent", r, t),
                    (s = !0);
                } else (i = null), (n = t.getAttribute("listIndent") + 1);
                t = t.nextSibling;
              }
            }
            function a(t) {
              let n = [],
                i = null;
              for (; t && t.is("element", "listItem"); ) {
                const o = t.getAttribute("listIndent");
                if (
                  (i &&
                    i.getAttribute("listIndent") > o &&
                    (n = n.slice(0, o + 1)),
                  0 != o)
                )
                  if (n[o]) {
                    const i = n[o];
                    t.getAttribute("listType") != i &&
                      (e.setAttribute("listType", i, t), (s = !0));
                  } else n[o] = t.getAttribute("listType");
                (i = t), (t = t.nextSibling);
              }
            }
          })(t.model, e)
        ),
          n.mapper.registerViewToModelLength("li", E),
          e.mapper.registerViewToModelLength("li", E),
          n.mapper.on("modelToViewPosition", v(n.view)),
          n.mapper.on(
            "viewToModelPosition",
            ((s = t.model),
            (t, e) => {
              const n = e.viewPosition,
                i = n.parent,
                o = e.mapper;
              if ("ul" == i.name || "ol" == i.name) {
                if (n.isAtEnd) {
                  const t = o.toModelElement(n.nodeBefore),
                    i = o.getModelLength(n.nodeBefore);
                  e.modelPosition = s.createPositionBefore(t).getShiftedBy(i);
                } else {
                  const t = o.toModelElement(n.nodeAfter);
                  e.modelPosition = s.createPositionBefore(t);
                }
                t.stop();
              } else if (
                "li" == i.name &&
                n.nodeBefore &&
                ("ul" == n.nodeBefore.name || "ol" == n.nodeBefore.name)
              ) {
                const r = o.toModelElement(i);
                let a = 1,
                  c = n.nodeBefore;
                for (; c && A(c); )
                  (a += o.getModelLength(c)), (c = c.previousSibling);
                (e.modelPosition = s.createPositionBefore(r).getShiftedBy(a)),
                  t.stop();
              }
            })
          ),
          e.mapper.on("modelToViewPosition", v(n.view)),
          t.conversion.for("editingDowncast").add((e) => {
            e.on("insert", m, { priority: "high" }),
              e.on("insert:listItem", d(t.model)),
              e.on("attribute:listType:listItem", h, { priority: "high" }),
              e.on("attribute:listType:listItem", f, { priority: "low" }),
              e.on(
                "attribute:listIndent:listItem",
                (function (t) {
                  return (e, n, i) => {
                    if (!i.consumable.consume(n.item, "attribute:listIndent"))
                      return;
                    const s = i.mapper.toViewElement(n.item),
                      o = i.writer;
                    o.breakContainer(o.createPositionBefore(s)),
                      o.breakContainer(o.createPositionAfter(s));
                    const r = s.parent,
                      a = r.previousSibling,
                      c = o.createRangeOn(r);
                    o.remove(c),
                      a && a.nextSibling && Object(u.g)(o, a, a.nextSibling),
                      k(
                        n.attributeOldValue + 1,
                        n.range.start,
                        c.start,
                        s,
                        i,
                        t
                      ),
                      Object(u.f)(n.item, s, i, t);
                    for (const t of n.item.getChildren())
                      i.consumable.consume(t, "insert");
                  };
                })(t.model)
              ),
              e.on(
                "remove:listItem",
                (function (t) {
                  return (e, n, i) => {
                    const s = i.mapper
                        .toViewPosition(n.position)
                        .getLastMatchingPosition(
                          (t) => !t.item.is("element", "li")
                        ).nodeAfter,
                      o = i.writer;
                    o.breakContainer(o.createPositionBefore(s)),
                      o.breakContainer(o.createPositionAfter(s));
                    const r = s.parent,
                      a = r.previousSibling,
                      c = o.createRangeOn(r),
                      l = o.remove(c);
                    a && a.nextSibling && Object(u.g)(o, a, a.nextSibling);
                    k(
                      i.mapper.toModelElement(s).getAttribute("listIndent") + 1,
                      n.position,
                      c.start,
                      s,
                      i,
                      t
                    );
                    for (const t of o.createRangeIn(l).getItems())
                      i.mapper.unbindViewElement(t);
                    e.stop();
                  };
                })(t.model)
              ),
              e.on("remove", g, { priority: "low" });
          }),
          t.conversion.for("dataDowncast").add((e) => {
            e.on("insert", m, { priority: "high" }),
              e.on("insert:listItem", d(t.model));
          }),
          t.conversion.for("upcast").add((t) => {
            t.on("element:ul", b, { priority: "high" }),
              t.on("element:ol", b, { priority: "high" }),
              t.on("element:li", w, { priority: "high" }),
              t.on("element:li", p);
          }),
          t.model.on("insertContent", _, { priority: "high" }),
          t.commands.add("numberedList", new i.a(t, "numbered")),
          t.commands.add("bulletedList", new i.a(t, "bulleted")),
          t.commands.add("indentList", new r(t, "forward")),
          t.commands.add("outdentList", new r(t, "backward"));
        const o = n.view.document;
        this.listenTo(
          o,
          "enter",
          (t, e) => {
            const n = this.editor.model.document,
              i = n.selection.getLastPosition().parent;
            n.selection.isCollapsed &&
              "listItem" == i.name &&
              i.isEmpty &&
              (this.editor.execute("outdentList"),
              e.preventDefault(),
              t.stop());
          },
          { context: "li" }
        ),
          this.listenTo(
            o,
            "delete",
            (t, e) => {
              if ("backward" !== e.direction) return;
              const n = this.editor.model.document.selection;
              if (!n.isCollapsed) return;
              const i = n.getFirstPosition();
              if (!i.isAtStart) return;
              const s = i.parent;
              if ("listItem" !== s.name) return;
              (s.previousSibling && "listItem" === s.previousSibling.name) ||
                (this.editor.execute("outdentList"),
                e.preventDefault(),
                t.stop());
            },
            { context: "li" }
          );
        const a = (t) => (e, n) => {
          this.editor.commands.get(t).isEnabled &&
            (this.editor.execute(t), n());
        };
        t.keystrokes.set("Tab", a("indentList")),
          t.keystrokes.set("Shift+Tab", a("outdentList"));
      }
      afterInit() {
        const t = this.editor.commands,
          e = t.get("indent"),
          n = t.get("outdent");
        e && e.registerChildCommand(t.get("indentList")),
          n && n.registerChildCommand(t.get("outdentList"));
      }
    }
    function E(t) {
      let e = 1;
      for (const n of t.getChildren())
        if ("ul" == n.name || "ol" == n.name)
          for (const t of n.getChildren()) e += E(t);
      return e;
    }
  },
  function (t, e, n) {
    "use strict";
    e.a =
      '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(135),
      s = n(18),
      o = n(42);
    function r({ target: t, viewportOffset: e = 0 }) {
      const n = f(t);
      let i = n,
        s = null;
      for (; i; ) {
        let o;
        (o = m(i == n ? t : s)), c(o, () => g(t, i));
        const r = g(t, i);
        if ((a(i, r, e), i.parent != i)) {
          if (((s = i.frameElement), (i = i.parent), !s)) return;
        } else i = null;
      }
    }
    function a(t, e, n) {
      const i = e.clone().moveBy(0, n),
        o = e.clone().moveBy(0, -n),
        r = new s.a(t).excludeScrollbarsAndBorders();
      if (![o, i].every((t) => r.contains(t))) {
        let { scrollX: s, scrollY: a } = t;
        u(o, r)
          ? (a -= r.top - e.top + n)
          : l(i, r) && (a += e.bottom - r.bottom + n),
          d(e, r)
            ? (s -= r.left - e.left + n)
            : h(e, r) && (s += e.right - r.right + n),
          t.scrollTo(s, a);
      }
    }
    function c(t, e) {
      const n = f(t);
      let i, o;
      for (; t != n.document.body; )
        (o = e()),
          (i = new s.a(t).excludeScrollbarsAndBorders()),
          i.contains(o) ||
            (u(o, i)
              ? (t.scrollTop -= i.top - o.top)
              : l(o, i) && (t.scrollTop += o.bottom - i.bottom),
            d(o, i)
              ? (t.scrollLeft -= i.left - o.left)
              : h(o, i) && (t.scrollLeft += o.right - i.right)),
          (t = t.parentNode);
    }
    function l(t, e) {
      return t.bottom > e.bottom;
    }
    function u(t, e) {
      return t.top < e.top;
    }
    function d(t, e) {
      return t.left < e.left;
    }
    function h(t, e) {
      return t.right > e.right;
    }
    function f(t) {
      return Object(i.a)(t)
        ? t.startContainer.ownerDocument.defaultView
        : t.ownerDocument.defaultView;
    }
    function m(t) {
      if (Object(i.a)(t)) {
        let e = t.commonAncestorContainer;
        return Object(o.a)(e) && (e = e.parentNode), e;
      }
      return t.parentNode;
    }
    function g(t, e) {
      const n = f(t),
        i = new s.a(t);
      if (n === e) return i;
      {
        let t = n;
        for (; t != e; ) {
          const e = t.frameElement,
            n = new s.a(e).excludeScrollbarsAndBorders();
          i.moveBy(n.left, n.top), (t = t.parent);
        }
      }
      return i;
    }
    Object.assign(
      {},
      {
        scrollViewportToShowTarget: r,
        scrollAncestorsToShowTarget: function (t) {
          c(m(t), () => new s.a(t));
        },
      }
    );
  },
  function (t, e) {
    var n;
    n = (function () {
      return this;
    })();
    try {
      n = n || new Function("return this")();
    } catch (t) {
      "object" == typeof window && (n = window);
    }
    t.exports = n;
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(6),
      s = n(14),
      o = n(174);
    class r {
      constructor(t, e) {
        e && Object(o.a)(this, e), t && this.set(t);
      }
    }
    Object(i.default)(r, s.default);
  },
  function (t, e, n) {
    "use strict";
    var i = n(30),
      s = n(41),
      o = function () {
        return s.a.Date.now();
      },
      r = /\s/;
    var a = function (t) {
        for (var e = t.length; e-- && r.test(t.charAt(e)); );
        return e;
      },
      c = /^\s+/;
    var l = function (t) {
        return t ? t.slice(0, a(t) + 1).replace(c, "") : t;
      },
      u = n(119),
      d = /^[-+]0x[0-9a-f]+$/i,
      h = /^0b[01]+$/i,
      f = /^0o[0-7]+$/i,
      m = parseInt;
    var g = function (t) {
        if ("number" == typeof t) return t;
        if (Object(u.a)(t)) return NaN;
        if (Object(i.a)(t)) {
          var e = "function" == typeof t.valueOf ? t.valueOf() : t;
          t = Object(i.a)(e) ? e + "" : e;
        }
        if ("string" != typeof t) return 0 === t ? t : +t;
        t = l(t);
        var n = h.test(t);
        return n || f.test(t) ? m(t.slice(2), n ? 2 : 8) : d.test(t) ? NaN : +t;
      },
      p = Math.max,
      b = Math.min;
    e.a = function (t, e, n) {
      var s,
        r,
        a,
        c,
        l,
        u,
        d = 0,
        h = !1,
        f = !1,
        m = !0;
      if ("function" != typeof t) throw new TypeError("Expected a function");
      function w(e) {
        var n = s,
          i = r;
        return (s = r = void 0), (d = e), (c = t.apply(i, n));
      }
      function v(t) {
        return (d = t), (l = setTimeout(y, e)), h ? w(t) : c;
      }
      function _(t) {
        var n = t - u;
        return void 0 === u || n >= e || n < 0 || (f && t - d >= a);
      }
      function y() {
        var t = o();
        if (_(t)) return k(t);
        l = setTimeout(
          y,
          (function (t) {
            var n = e - (t - u);
            return f ? b(n, a - (t - d)) : n;
          })(t)
        );
      }
      function k(t) {
        return (l = void 0), m && s ? w(t) : ((s = r = void 0), c);
      }
      function A() {
        var t = o(),
          n = _(t);
        if (((s = arguments), (r = this), (u = t), n)) {
          if (void 0 === l) return v(u);
          if (f) return clearTimeout(l), (l = setTimeout(y, e)), w(u);
        }
        return void 0 === l && (l = setTimeout(y, e)), c;
      }
      return (
        (e = g(e) || 0),
        Object(i.a)(n) &&
          ((h = !!n.leading),
          (a = (f = "maxWait" in n) ? p(g(n.maxWait) || 0, e) : a),
          (m = "trailing" in n ? !!n.trailing : m)),
        (A.cancel = function () {
          void 0 !== l && clearTimeout(l), (d = 0), (s = u = r = l = void 0);
        }),
        (A.flush = function () {
          return void 0 === l ? c : k(o());
        }),
        A
      );
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return T;
    });
    var i = n(322),
      s = n(253),
      o = n(325),
      r = n(266),
      a = n(251),
      c = n(252),
      l = n(308),
      u = n(324),
      d = n(316),
      h = n(263),
      f = n(306),
      m = n(312),
      g = n(311),
      p = n(310),
      b = n(307),
      w = n(309),
      v = n(305),
      _ = n(255),
      y = n(319),
      k = n(180),
      A = n(321),
      C = n(300),
      E = n(303),
      O = n(241),
      P = n(291);
    class T extends i.a {}
    (T.builtinPlugins = [
      s.a,
      o.a,
      r.a,
      a.a,
      c.a,
      l.a,
      u.a,
      P.a,
      d.a,
      h.a,
      f.a,
      m.a,
      g.a,
      p.a,
      b.a,
      w.a,
      v.a,
      _.a,
      y.a,
      k.a,
      A.a,
      C.a,
      E.a,
      O.a,
    ]),
      (T.defaultConfig = {
        toolbar: {
          items: [
            "heading",
            "|",
            "bold",
            "italic",
            "link",
            "bulletedList",
            "numberedList",
            "|",
            "outdent",
            "indent",
            "|",
            "uploadImage",
            "blockQuote",
            "insertTable",
            "mediaEmbed",
            "undo",
            "redo",
          ],
        },
        image: {
          toolbar: [
            "imageStyle:inline",
            "imageStyle:block",
            "imageStyle:side",
            "|",
            "toggleImageCaption",
            "imageTextAlternative",
          ],
        },
        table: {
          contentToolbar: ["tableColumn", "tableRow", "mergeTableCells"],
        },
        language: "en",
      });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return l;
    });
    var i = n(1),
      s = n(298),
      o = n(4),
      r = n(2),
      a = n(292);
    n(301);
    class c extends i.j {
      static get pluginName() {
        return "HeadingUI";
      }
      init() {
        const t = this.editor,
          e = t.t,
          n = Object(a.a)(t),
          i = e("Choose heading"),
          s = e("Heading");
        t.ui.componentFactory.add("heading", (e) => {
          const a = {},
            c = new r.b(),
            l = t.commands.get("heading"),
            u = t.commands.get("paragraph"),
            d = [l];
          for (const t of n) {
            const e = {
              type: "button",
              model: new o.u({ label: t.title, class: t.class, withText: !0 }),
            };
            "paragraph" === t.model
              ? (e.model.bind("isOn").to(u, "value"),
                e.model.set("commandName", "paragraph"),
                d.push(u))
              : (e.model.bind("isOn").to(l, "value", (e) => e === t.model),
                e.model.set({ commandName: "heading", commandValue: t.model })),
              c.add(e),
              (a[t.model] = t.title);
          }
          const h = Object(o.I)(e);
          return (
            Object(o.F)(h, c),
            h.buttonView.set({ isOn: !1, withText: !0, tooltip: s }),
            h.extendTemplate({
              attributes: { class: ["ck-heading-dropdown"] },
            }),
            h
              .bind("isEnabled")
              .toMany(d, "isEnabled", (...t) => t.some((t) => t)),
            h.buttonView.bind("label").to(l, "value", u, "value", (t, e) => {
              const n = t || (e && "paragraph");
              return a[n] ? a[n] : i;
            }),
            this.listenTo(h, "execute", (e) => {
              t.execute(
                e.source.commandName,
                e.source.commandValue
                  ? { value: e.source.commandValue }
                  : void 0
              ),
                t.editing.view.focus();
            }),
            h
          );
        });
      }
    }
    class l extends i.j {
      static get requires() {
        return [s.a, c];
      }
      static get pluginName() {
        return "Heading";
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return b;
    });
    var i = n(9),
      s = n(223),
      o = n(34),
      r = n(68);
    n(350);
    const a = Object(r.a)("px");
    class c extends o.a {
      constructor(t) {
        super(t);
        const e = this.bindTemplate;
        (this.isVisible = !1),
          (this.isToggleable = !0),
          this.set("top", 0),
          this.set("left", 0),
          this.extendTemplate({
            attributes: {
              class: "ck-block-toolbar-button",
              style: {
                top: e.to("top", (t) => a(t)),
                left: e.to("left", (t) => a(t)),
              },
            },
          });
      }
    }
    var l = n(82),
      u = n(97),
      d = n(142),
      h = n(157),
      f = n(18),
      m = n(116),
      g = n(112);
    const p = Object(r.a)("px");
    class b extends i.a {
      static get pluginName() {
        return "BlockToolbar";
      }
      constructor(t) {
        super(t),
          (this._blockToolbarConfig = Object(m.a)(
            this.editor.config.get("blockToolbar")
          )),
          (this.toolbarView = this._createToolbarView()),
          (this.panelView = this._createPanelView()),
          (this.buttonView = this._createButtonView()),
          (this._resizeObserver = null),
          Object(d.a)({
            emitter: this.panelView,
            contextElements: [this.panelView.element, this.buttonView.element],
            activator: () => this.panelView.isVisible,
            callback: () => this._hidePanel(),
          });
      }
      init() {
        const t = this.editor;
        this.listenTo(t.model.document.selection, "change:range", (t, e) => {
          e.directChange && this._hidePanel();
        }),
          this.listenTo(t.ui, "update", () => this._updateButton()),
          this.listenTo(t, "change:isReadOnly", () => this._updateButton(), {
            priority: "low",
          }),
          this.listenTo(t.ui.focusTracker, "change:isFocused", () =>
            this._updateButton()
          ),
          this.listenTo(this.buttonView, "change:isVisible", (t, e, n) => {
            n
              ? this.buttonView.listenTo(window, "resize", () =>
                  this._updateButton()
                )
              : (this.buttonView.stopListening(window, "resize"),
                this._hidePanel());
          });
      }
      afterInit() {
        const t = this.editor.ui.componentFactory,
          e = this._blockToolbarConfig;
        this.toolbarView.fillFromConfig(e, t);
        for (const t of this.toolbarView.items)
          t.on("execute", () => this._hidePanel(!0), { priority: "high" });
        e.shouldNotGroupWhenFull ||
          this.listenTo(this.editor, "ready", () => {
            const t = this.editor.ui.view.editable.element;
            this._resizeObserver = new g.a(t, () => {
              this.toolbarView.maxWidth = this._getToolbarMaxWidth();
            });
          });
      }
      destroy() {
        super.destroy(),
          this.panelView.destroy(),
          this.buttonView.destroy(),
          this.toolbarView.destroy(),
          this._resizeObserver && this._resizeObserver.destroy();
      }
      _createToolbarView() {
        const t = !this._blockToolbarConfig.shouldNotGroupWhenFull,
          e = new u.a(this.editor.locale, {
            shouldGroupWhenFull: t,
            isFloating: !0,
          });
        return (
          e.focusTracker.on("change:isFocused", (t, e, n) => {
            n || this._hidePanel();
          }),
          e
        );
      }
      _createPanelView() {
        const t = this.editor,
          e = new l.a(t.locale);
        return (
          e.content.add(this.toolbarView),
          (e.class = "ck-toolbar-container"),
          t.ui.view.body.add(e),
          t.ui.focusTracker.add(e.element),
          this.toolbarView.keystrokes.set("Esc", (t, e) => {
            this._hidePanel(!0), e();
          }),
          e
        );
      }
      _createButtonView() {
        const t = this.editor,
          e = t.t,
          n = new c(t.locale);
        return (
          n.set({ label: e("Edit block"), icon: s.a, withText: !1 }),
          n.bind("isOn").to(this.panelView, "isVisible"),
          n.bind("tooltip").to(this.panelView, "isVisible", (t) => !t),
          this.listenTo(n, "execute", () => {
            this.panelView.isVisible ? this._hidePanel(!0) : this._showPanel();
          }),
          t.ui.view.body.add(n),
          t.ui.focusTracker.add(n.element),
          n
        );
      }
      _updateButton() {
        const t = this.editor,
          e = t.model,
          n = t.editing.view;
        if (!t.ui.focusTracker.isFocused) return void this._hideButton();
        if (t.isReadOnly) return void this._hideButton();
        const i = Array.from(e.document.selection.getSelectedBlocks())[0];
        if (!i || Array.from(this.toolbarView.items).every((t) => !t.isEnabled))
          return void this._hideButton();
        const s = n.domConverter.mapViewToDom(
          t.editing.mapper.toViewElement(i)
        );
        (this.buttonView.isVisible = !0),
          this._attachButtonToElement(s),
          this.panelView.isVisible && this._showPanel();
      }
      _hideButton() {
        this.buttonView.isVisible = !1;
      }
      _showPanel() {
        const t = this.panelView.isVisible;
        this.panelView.show(),
          (this.toolbarView.maxWidth = this._getToolbarMaxWidth()),
          this.panelView.pin({
            target: this.buttonView.element,
            limiter: this.editor.ui.getEditableElement(),
          }),
          t || this.toolbarView.items.get(0).focus();
      }
      _hidePanel(t) {
        (this.panelView.isVisible = !1), t && this.editor.editing.view.focus();
      }
      _attachButtonToElement(t) {
        const e = window.getComputedStyle(t),
          n = new f.a(this.editor.ui.getEditableElement()),
          i = parseInt(e.paddingTop, 10),
          s = parseInt(e.lineHeight, 10) || 1.2 * parseInt(e.fontSize, 10),
          o = Object(h.a)({
            element: this.buttonView.element,
            target: t,
            positions: [
              (t, e) => {
                let o;
                return (
                  (o =
                    "ltr" === this.editor.locale.uiLanguageDirection
                      ? n.left - e.width
                      : n.right),
                  { top: t.top + i + (s - e.height) / 2, left: o }
                );
              },
            ],
          });
        (this.buttonView.top = o.top), (this.buttonView.left = o.left);
      }
      _getToolbarMaxWidth() {
        const t = this.editor.ui.view.editable.element,
          e = new f.a(t),
          n = new f.a(this.buttonView.element),
          i =
            "rtl" === this.editor.locale.uiLanguageDirection
              ? n.left - e.right + n.width
              : e.left - n.left;
        return p(e.width + i);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return i;
    });
    class i {
      constructor() {
        (this._operations = []),
          (this._undoPairs = new Map()),
          (this._undoneOperations = new Set());
      }
      addOperation(t) {
        this._operations.includes(t) || this._operations.push(t);
      }
      getOperations(
        t = Number.NEGATIVE_INFINITY,
        e = Number.POSITIVE_INFINITY
      ) {
        const n = [];
        for (const i of this._operations)
          i.baseVersion >= t && i.baseVersion < e && n.push(i);
        return n;
      }
      getOperation(t) {
        for (const e of this._operations) if (e.baseVersion == t) return e;
      }
      setOperationAsUndone(t, e) {
        this._undoPairs.set(e, t), this._undoneOperations.add(t);
      }
      isUndoingOperation(t) {
        return this._undoPairs.has(t);
      }
      isUndoneOperation(t) {
        return this._undoneOperations.has(t);
      }
      getUndoneOperation(t) {
        return this._undoPairs.get(t);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return u;
    });
    var i = n(1),
      s = n(33),
      o = n(13),
      r = n(2);
    function a(t, e, n, i) {
      let s,
        a = null;
      "function" == typeof i
        ? (s = i)
        : ((a = t.commands.get(i)),
          (s = () => {
            t.execute(i);
          })),
        t.model.document.on("change:data", (c, l) => {
          if ((a && !a.isEnabled) || !e.isEnabled) return;
          const u = Object(r.n)(t.model.document.selection.getRanges());
          if (!u.isCollapsed) return;
          if ("transparent" == l.type) return;
          const d = Array.from(t.model.document.differ.getChanges()),
            h = d[0];
          if (
            1 != d.length ||
            "insert" !== h.type ||
            "$text" != h.name ||
            1 != h.length
          )
            return;
          const f = h.position.parent;
          if (f.is("element", "codeBlock")) return;
          if (
            f.is("element", "listItem") &&
            "function" != typeof i &&
            !["numberedList", "bulletedList", "todoList"].includes(i)
          )
            return;
          if (a && !0 === a.value) return;
          const m = f.getChild(0),
            g = t.model.createRangeOn(m);
          if (!g.containsRange(u) && !u.end.isEqual(g.end)) return;
          const p = n.exec(m.data.substr(0, u.end.offset));
          p &&
            t.model.enqueueChange((e) => {
              const n = e.createPositionAt(f, 0),
                i = e.createPositionAt(f, p[0].length),
                r = new o.i(n, i);
              if (!1 !== s({ match: p })) {
                e.remove(r);
                const n = t.model.document.selection.getFirstRange(),
                  i = e.createRangeIn(f);
                !f.isEmpty ||
                  i.isEqual(n) ||
                  i.containsRange(n, !0) ||
                  e.remove(f);
              }
              r.detach(),
                t.model.enqueueChange(() => {
                  t.plugins.get("Delete").requestUndoOnBackspace();
                });
            });
        });
    }
    function c(t, e, n, i) {
      let s, o;
      n instanceof RegExp ? (s = n) : (o = n),
        (o =
          o ||
          ((t) => {
            let e;
            const n = [],
              i = [];
            for (; null !== (e = s.exec(t)) && !(e && e.length < 4); ) {
              let { index: t, 1: s, 2: o, 3: r } = e;
              const a = s + o + r;
              t += e[0].length - a.length;
              const c = [t, t + s.length],
                l = [
                  t + s.length + o.length,
                  t + s.length + o.length + r.length,
                ];
              n.push(c),
                n.push(l),
                i.push([t + s.length, t + s.length + o.length]);
            }
            return { remove: n, format: i };
          })),
        t.model.document.on("change:data", (n, s) => {
          if ("transparent" == s.type || !e.isEnabled) return;
          const r = t.model,
            a = r.document.selection;
          if (!a.isCollapsed) return;
          const c = Array.from(r.document.differ.getChanges()),
            u = c[0];
          if (
            1 != c.length ||
            "insert" !== u.type ||
            "$text" != u.name ||
            1 != u.length
          )
            return;
          const d = a.focus,
            h = d.parent,
            { text: f, range: m } = (function (t, e) {
              let n = t.start;
              return {
                text: Array.from(t.getItems()).reduce(
                  (t, i) =>
                    (!i.is("$text") && !i.is("$textProxy")) ||
                    i.getAttribute("code")
                      ? ((n = e.createPositionAfter(i)), "")
                      : t + i.data,
                  ""
                ),
                range: e.createRange(n, t.end),
              };
            })(r.createRange(r.createPositionAt(h, 0), d), r),
            g = o(f),
            p = l(m.start, g.format, r),
            b = l(m.start, g.remove, r);
          p.length &&
            b.length &&
            r.enqueueChange((e) => {
              if (!1 !== i(e, p)) {
                for (const t of b.reverse()) e.remove(t);
                r.enqueueChange(() => {
                  t.plugins.get("Delete").requestUndoOnBackspace();
                });
              }
            });
        });
    }
    function l(t, e, n) {
      return e
        .filter((t) => void 0 !== t[0] && void 0 !== t[1])
        .map((e) => n.createRange(t.getShiftedBy(e[0]), t.getShiftedBy(e[1])));
    }
    class u extends i.j {
      static get requires() {
        return [s.a];
      }
      static get pluginName() {
        return "Autoformat";
      }
      afterInit() {
        this._addListAutoformats(),
          this._addBasicStylesAutoformats(),
          this._addHeadingAutoformats(),
          this._addBlockQuoteAutoformats(),
          this._addCodeBlockAutoformats(),
          this._addHorizontalLineAutoformats();
      }
      _addListAutoformats() {
        const t = this.editor.commands;
        t.get("bulletedList") &&
          a(this.editor, this, /^[*-]\s$/, "bulletedList"),
          t.get("numberedList") &&
            a(this.editor, this, /^1[.|)]\s$/, "numberedList"),
          t.get("todoList") && a(this.editor, this, /^\[\s?\]\s$/, "todoList"),
          t.get("checkTodoList") &&
            a(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
              this.editor.execute("todoList"),
                this.editor.execute("checkTodoList");
            });
      }
      _addBasicStylesAutoformats() {
        const t = this.editor.commands;
        if (t.get("bold")) {
          const t = d(this.editor, "bold");
          c(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t),
            c(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t);
        }
        if (t.get("italic")) {
          const t = d(this.editor, "italic");
          c(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t),
            c(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t);
        }
        if (t.get("code")) {
          const t = d(this.editor, "code");
          c(this.editor, this, /(`)([^`]+)(`)$/g, t);
        }
        if (t.get("strikethrough")) {
          const t = d(this.editor, "strikethrough");
          c(this.editor, this, /(~~)([^~]+)(~~)$/g, t);
        }
      }
      _addHeadingAutoformats() {
        const t = this.editor.commands.get("heading");
        t &&
          t.modelElements
            .filter((t) => t.match(/^heading[1-6]$/))
            .forEach((e) => {
              const n = e[7],
                i = new RegExp(`^(#{${n}})\\s$`);
              a(this.editor, this, i, () => {
                if (!t.isEnabled || t.value === e) return !1;
                this.editor.execute("heading", { value: e });
              });
            });
      }
      _addBlockQuoteAutoformats() {
        this.editor.commands.get("blockQuote") &&
          a(this.editor, this, /^>\s$/, "blockQuote");
      }
      _addCodeBlockAutoformats() {
        const t = this.editor,
          e = t.model.document.selection;
        t.commands.get("codeBlock") &&
          a(t, this, /^```$/, () => {
            if (e.getFirstPosition().parent.is("element", "listItem"))
              return !1;
            this.editor.execute("codeBlock", { usePreviousLanguageChoice: !0 });
          });
      }
      _addHorizontalLineAutoformats() {
        this.editor.commands.get("horizontalLine") &&
          a(this.editor, this, /^---$/, "horizontalLine");
      }
    }
    function d(t, e) {
      return (n, i) => {
        if (!t.commands.get(e).isEnabled) return !1;
        const s = t.model.schema.getValidRanges(i, e);
        for (const t of s) n.setAttribute(e, !0, t);
        n.removeSelectionAttribute(e);
      };
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(154);
    e.a = function (t, e) {
      return (e = "function" == typeof e ? e : void 0), Object(i.a)(t, 5, e);
    };
  },
  function (t, e, n) {
    "use strict";
    function i(t) {
      return t instanceof HTMLTextAreaElement ? t.value : t.innerHTML;
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    const i = {
      setData(t) {
        this.data.set(t);
      },
      getData(t) {
        return this.data.get(t);
      },
    };
    e.a = i;
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return u;
    });
    var i = n(86),
      s = n(50),
      o = n(25),
      r = n(76),
      a = n(7),
      c = n(15),
      l = n(62);
    class u {
      constructor(t) {
        this.document = t;
      }
      createDocumentFragment(t) {
        return new i.a(this.document, t);
      }
      createElement(t, e, n) {
        return new s.a(this.document, t, e, n);
      }
      createText(t) {
        return new o.a(this.document, t);
      }
      clone(t, e = !1) {
        return t._clone(e);
      }
      appendChild(t, e) {
        return e._appendChild(t);
      }
      insertChild(t, e, n) {
        return n._insertChild(t, e);
      }
      removeChildren(t, e, n) {
        return n._removeChildren(t, e);
      }
      remove(t) {
        const e = t.parent;
        return e ? this.removeChildren(e.getChildIndex(t), 1, e) : [];
      }
      replace(t, e) {
        const n = t.parent;
        if (n) {
          const i = n.getChildIndex(t);
          return this.removeChildren(i, 1, n), this.insertChild(i, e, n), !0;
        }
        return !1;
      }
      unwrapElement(t) {
        const e = t.parent;
        if (e) {
          const n = e.getChildIndex(t);
          this.remove(t), this.insertChild(n, t.getChildren(), e);
        }
      }
      rename(t, e) {
        const n = new s.a(this.document, t, e.getAttributes(), e.getChildren());
        return this.replace(e, n) ? n : null;
      }
      setAttribute(t, e, n) {
        n._setAttribute(t, e);
      }
      removeAttribute(t, e) {
        e._removeAttribute(t);
      }
      addClass(t, e) {
        e._addClass(t);
      }
      removeClass(t, e) {
        e._removeClass(t);
      }
      setStyle(t, e, n) {
        Object(r.a)(t) && void 0 === n && (n = e), n._setStyle(t, e);
      }
      removeStyle(t, e) {
        e._removeStyle(t);
      }
      setCustomProperty(t, e, n) {
        n._setCustomProperty(t, e);
      }
      removeCustomProperty(t, e) {
        return e._removeCustomProperty(t);
      }
      createPositionAt(t, e) {
        return a.a._createAt(t, e);
      }
      createPositionAfter(t) {
        return a.a._createAfter(t);
      }
      createPositionBefore(t) {
        return a.a._createBefore(t);
      }
      createRange(t, e) {
        return new c.a(t, e);
      }
      createRangeOn(t) {
        return c.a._createOn(t);
      }
      createRangeIn(t) {
        return c.a._createIn(t);
      }
      createSelection(t, e, n) {
        return new l.a(t, e, n);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return b;
    });
    var i = n(186),
      s = n(208),
      o = n(200),
      r = n(215),
      a = n(0);
    class c {
      constructor() {
        this._commands = new Map();
      }
      add(t, e) {
        this._commands.set(t, e);
      }
      get(t) {
        return this._commands.get(t);
      }
      execute(t, ...e) {
        const n = this.get(t);
        if (!n)
          throw new a.default("commandcollection-command-not-found", this, {
            commandName: t,
          });
        return n.execute(...e);
      }
      *names() {
        yield* this._commands.keys();
      }
      *commands() {
        yield* this._commands.values();
      }
      [Symbol.iterator]() {
        return this._commands[Symbol.iterator]();
      }
      destroy() {
        for (const t of this.commands()) t.destroy();
      }
    }
    var l = n(201),
      u = n(190),
      d = n(199),
      h = n(69);
    class f extends h.a {
      constructor(t) {
        super(), (this.editor = t);
      }
      set(t, e, n = {}) {
        if ("string" == typeof e) {
          const t = e;
          e = (e, n) => {
            this.editor.execute(t), n();
          };
        }
        super.set(t, e, n);
      }
    }
    var m = n(14),
      g = n(6),
      p = n(143);
    class b {
      constructor(t = {}) {
        const e =
          t.language ||
          (this.constructor.defaultConfig &&
            this.constructor.defaultConfig.language);
        (this._context = t.context || new i.a({ language: e })),
          this._context._addEditor(this, !t.context);
        const n = Array.from(this.constructor.builtinPlugins || []);
        (this.config = new s.a(t, this.constructor.defaultConfig)),
          this.config.define("plugins", n),
          this.config.define(this._context._getEditorConfig()),
          (this.plugins = new r.a(this, n, this._context.plugins)),
          (this.locale = this._context.locale),
          (this.t = this.locale.t),
          (this.commands = new c()),
          this.set("state", "initializing"),
          this.once("ready", () => (this.state = "ready"), {
            priority: "high",
          }),
          this.once("destroy", () => (this.state = "destroyed"), {
            priority: "high",
          }),
          this.set("isReadOnly", !1),
          (this.model = new d.a());
        const a = new p.a();
        (this.data = new l.a(this.model, a)),
          (this.editing = new o.a(this.model, a)),
          this.editing.view.document.bind("isReadOnly").to(this),
          (this.conversion = new u.a(
            [this.editing.downcastDispatcher, this.data.downcastDispatcher],
            this.data.upcastDispatcher
          )),
          this.conversion.addAlias(
            "dataDowncast",
            this.data.downcastDispatcher
          ),
          this.conversion.addAlias(
            "editingDowncast",
            this.editing.downcastDispatcher
          ),
          (this.keystrokes = new f(this)),
          this.keystrokes.listenTo(this.editing.view.document);
      }
      initPlugins() {
        const t = this.config,
          e = t.get("plugins"),
          n = t.get("removePlugins") || [],
          i = t.get("extraPlugins") || [],
          s = t.get("substitutePlugins") || [];
        return this.plugins.init(e.concat(i), n, s);
      }
      destroy() {
        let t = Promise.resolve();
        return (
          "initializing" == this.state &&
            (t = new Promise((t) => this.once("ready", t))),
          t
            .then(() => {
              this.fire("destroy"),
                this.stopListening(),
                this.commands.destroy();
            })
            .then(() => this.plugins.destroy())
            .then(() => {
              this.model.destroy(),
                this.data.destroy(),
                this.editing.destroy(),
                this.keystrokes.destroy();
            })
            .then(() => this._context._removeEditor(this))
        );
      }
      execute(...t) {
        try {
          return this.commands.execute(...t);
        } catch (t) {
          a.default.rethrowUnexpectedError(t, this);
        }
      }
      focus() {
        this.editing.view.focus();
      }
    }
    Object(g.default)(b, m.default);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return l;
    });
    var i = n(0);
    class s {
      constructor(t) {
        (this.editor = t), (this._components = new Map());
      }
      *names() {
        for (const t of this._components.values()) yield t.originalName;
      }
      add(t, e) {
        this._components.set(o(t), { callback: e, originalName: t });
      }
      create(t) {
        if (!this.has(t))
          throw new i.default("componentfactory-item-missing", this, {
            name: t,
          });
        return this._components.get(o(t)).callback(this.editor.locale);
      }
      has(t) {
        return this._components.has(o(t));
      }
    }
    function o(t) {
      return String(t).toLowerCase();
    }
    var r = n(52),
      a = n(14),
      c = n(6);
    class l {
      constructor(t) {
        (this.editor = t),
          (this.componentFactory = new s(t)),
          (this.focusTracker = new r.a()),
          this.set("viewportOffset", this._readViewportOffsetFromConfig()),
          (this._editableElementsMap = new Map()),
          this.listenTo(t.editing.view.document, "layoutChanged", () =>
            this.update()
          );
      }
      get element() {
        return null;
      }
      update() {
        this.fire("update");
      }
      destroy() {
        this.stopListening(), this.focusTracker.destroy();
        for (const t of this._editableElementsMap.values())
          t.ckeditorInstance = null;
        this._editableElementsMap = new Map();
      }
      setEditableElement(t, e) {
        this._editableElementsMap.set(t, e),
          e.ckeditorInstance || (e.ckeditorInstance = this.editor);
      }
      getEditableElement(t = "main") {
        return this._editableElementsMap.get(t);
      }
      getEditableElementsNames() {
        return this._editableElementsMap.keys();
      }
      get _editableElements() {
        return (
          console.warn(
            "editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.",
            { editorUI: this }
          ),
          this._editableElementsMap
        );
      }
      _readViewportOffsetFromConfig() {
        const t = this.editor,
          e = t.config.get("ui.viewportOffset");
        if (e) return e;
        const n = t.config.get("toolbar.viewportTopOffset");
        return n
          ? (console.warn(
              "editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."
            ),
            { top: n })
          : { top: 0 };
      }
    }
    Object(c.default)(l, a.default);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(8);
    class s extends i.a {
      constructor(t, e, n) {
        super(t),
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-content",
                "ck-editor__editable",
                "ck-rounded-corners",
              ],
              lang: t.contentLanguage,
              dir: t.contentLanguageDirection,
            },
          }),
          (this.name = null),
          this.set("isFocused", !1),
          (this._editableElement = n),
          (this._hasExternalElement = !!this._editableElement),
          (this._editingView = e);
      }
      render() {
        super.render(),
          this._hasExternalElement
            ? this.template.apply((this.element = this._editableElement))
            : (this._editableElement = this.element),
          this.on("change:isFocused", () => this._updateIsFocusedClasses()),
          this._updateIsFocusedClasses();
      }
      destroy() {
        this._hasExternalElement && this.template.revert(this._editableElement),
          super.destroy();
      }
      _updateIsFocusedClasses() {
        const t = this._editingView;
        function e(e) {
          t.change((n) => {
            const i = t.document.getRoot(e.name);
            n.addClass(e.isFocused ? "ck-focused" : "ck-blurred", i),
              n.removeClass(e.isFocused ? "ck-blurred" : "ck-focused", i);
          });
        }
        t.isRenderingInProgress
          ? (function n(i) {
              t.once("change:isRenderingInProgress", (t, s, o) => {
                o ? n(i) : e(i);
              });
            })(this)
          : e(this);
      }
    }
    class o extends s {
      constructor(t, e, n) {
        super(t, e, n),
          this.extendTemplate({
            attributes: {
              role: "textbox",
              class: "ck-editor__editable_inline",
            },
          });
      }
      render() {
        super.render();
        const t = this._editingView,
          e = this.t;
        t.change((n) => {
          const i = t.document.getRoot(this.name);
          n.setAttribute("aria-label", e("Rich Text Editor, %0", this.name), i);
        });
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(9),
      s = n(34);
    class o extends i.a {
      init() {
        const t = this.editor,
          e = t.t;
        t.ui.componentFactory.add("paragraph", (n) => {
          const i = new s.a(n),
            o = t.commands.get("paragraph");
          return (
            (i.label = e("Paragraph")),
            (i.icon =
              '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>'),
            (i.tooltip = !0),
            (i.isToggleable = !0),
            i.bind("isEnabled").to(o),
            i.bind("isOn").to(o, "value"),
            i.on("execute", () => {
              t.execute("paragraph");
            }),
            i
          );
        });
      }
    }
  },
  function (t, e, n) {
    "use strict";
    e.a = function (t, e) {
      for (var n = -1, i = null == t ? 0 : t.length, s = Array(i); ++n < i; )
        s[n] = e(t[n], n, t);
      return s;
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(127),
      s = n(147),
      o = n(87);
    var r = function (t, e, n) {
      ((void 0 !== n && !Object(o.a)(t[e], n)) ||
        (void 0 === n && !(e in t))) &&
        Object(s.a)(t, e, n);
    };
    var a = (function (t) {
        return function (e, n, i) {
          for (var s = -1, o = Object(e), r = i(e), a = r.length; a--; ) {
            var c = r[t ? a : ++s];
            if (!1 === n(o[c], c, o)) break;
          }
          return e;
        };
      })(),
      c = n(210),
      l = n(213),
      u = n(183),
      d = n(229),
      h = n(173),
      f = n(46),
      m = n(117),
      g = n(38);
    var p = function (t) {
        return Object(g.a)(t) && Object(m.a)(t);
      },
      b = n(102),
      w = n(123),
      v = n(30),
      _ = n(76),
      y = n(158);
    var k = function (t, e) {
        if (
          ("constructor" !== e || "function" != typeof t[e]) &&
          "__proto__" != e
        )
          return t[e];
      },
      A = n(78),
      C = n(80);
    var E = function (t) {
      return Object(A.a)(t, Object(C.a)(t));
    };
    var O = function (t, e, n, i, s, o, a) {
      var m = k(t, n),
        g = k(e, n),
        A = a.get(g);
      if (A) r(t, n, A);
      else {
        var C = o ? o(m, g, n + "", t, e, a) : void 0,
          O = void 0 === C;
        if (O) {
          var P = Object(f.a)(g),
            T = !P && Object(b.a)(g),
            x = !P && !T && Object(y.a)(g);
          (C = g),
            P || T || x
              ? Object(f.a)(m)
                ? (C = m)
                : p(m)
                ? (C = Object(u.a)(m))
                : T
                ? ((O = !1), (C = Object(c.a)(g, !0)))
                : x
                ? ((O = !1), (C = Object(l.a)(g, !0)))
                : (C = [])
              : Object(_.a)(g) || Object(h.a)(g)
              ? ((C = m),
                Object(h.a)(m)
                  ? (C = E(m))
                  : (Object(v.a)(m) && !Object(w.a)(m)) || (C = Object(d.a)(g)))
              : (O = !1);
        }
        O && (a.set(g, C), s(C, g, i, o, a), a.delete(g)), r(t, n, C);
      }
    };
    e.a = function t(e, n, s, o, c) {
      e !== n &&
        a(
          n,
          function (a, l) {
            if ((c || (c = new i.a()), Object(v.a)(a))) O(e, n, l, s, t, o, c);
            else {
              var u = o ? o(k(e, l), a, l + "", e, n, c) : void 0;
              void 0 === u && (u = a), r(e, l, u);
            }
          },
          C.a
        );
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(206);
    var s = function (t, e, n) {
        switch (n.length) {
          case 0:
            return t.call(e);
          case 1:
            return t.call(e, n[0]);
          case 2:
            return t.call(e, n[0], n[1]);
          case 3:
            return t.call(e, n[0], n[1], n[2]);
        }
        return t.apply(e, n);
      },
      o = Math.max;
    var r = function (t, e, n) {
      return (
        (e = o(void 0 === e ? t.length - 1 : e, 0)),
        function () {
          for (
            var i = arguments, r = -1, a = o(i.length - e, 0), c = Array(a);
            ++r < a;

          )
            c[r] = i[e + r];
          r = -1;
          for (var l = Array(e + 1); ++r < e; ) l[r] = i[r];
          return (l[e] = n(c)), s(t, this, l);
        }
      );
    };
    var a = function (t) {
        return function () {
          return t;
        };
      },
      c = n(161),
      l = c.a
        ? function (t, e) {
            return Object(c.a)(t, "toString", {
              configurable: !0,
              enumerable: !1,
              value: a(e),
              writable: !0,
            });
          }
        : i.a,
      u = Date.now;
    var d = (function (t) {
      var e = 0,
        n = 0;
      return function () {
        var i = u(),
          s = 16 - (i - n);
        if (((n = i), s > 0)) {
          if (++e >= 800) return arguments[0];
        } else e = 0;
        return t.apply(void 0, arguments);
      };
    })(l);
    e.a = function (t, e) {
      return d(r(t, e, i.a), t + "");
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return l;
    }),
      n.d(e, "b", function () {
        return u;
      });
    var i = n(1),
      s = n(84),
      o = n(16),
      r = n(98),
      a = n(10),
      c = n(31);
    class l extends i.j {
      static get pluginName() {
        return "TableClipboard";
      }
      static get requires() {
        return [s.a, r.a];
      }
      init() {
        const t = this.editor,
          e = t.editing.view.document;
        this.listenTo(e, "copy", (t, e) => this._onCopyCut(t, e)),
          this.listenTo(e, "cut", (t, e) => this._onCopyCut(t, e)),
          this.listenTo(
            t.model,
            "insertContent",
            (t, e) => this._onInsertContent(t, ...e),
            { priority: "high" }
          ),
          this.decorate("_replaceTableSlotCell");
      }
      _onCopyCut(t, e) {
        const n = this.editor.plugins.get(s.a);
        if (!n.getSelectedTableCells()) return;
        if ("cut" == t.name && this.editor.isReadOnly) return;
        e.preventDefault(), t.stop();
        const i = this.editor.data,
          o = this.editor.editing.view.document,
          r = i.toView(n.getSelectionAsFragment());
        o.fire("clipboardOutput", {
          dataTransfer: e.dataTransfer,
          content: r,
          method: t.name,
        });
      }
      _onInsertContent(t, e, n) {
        if (n && !n.is("documentSelection")) return;
        const i = this.editor.model,
          s = this.editor.plugins.get(r.a);
        let o = u(e, i);
        if (!o) return;
        const l = Object(a.d)(i.document.selection);
        l.length
          ? (t.stop(),
            i.change((t) => {
              const e = { width: s.getColumns(o), height: s.getRows(o) },
                n = (function (t, e, n, i) {
                  const s = t[0].findAncestor("table"),
                    o = Object(a.a)(t),
                    r = Object(a.b)(t),
                    l = {
                      firstColumn: o.first,
                      lastColumn: o.last,
                      firstRow: r.first,
                      lastRow: r.last,
                    },
                    u = 1 === t.length;
                  u &&
                    ((l.lastRow += e.height - 1),
                    (l.lastColumn += e.width - 1),
                    (function (t, e, n, i) {
                      const s = i.getColumns(t),
                        o = i.getRows(t);
                      n > s && i.insertColumns(t, { at: s, columns: n - s });
                      e > o && i.insertRows(t, { at: o, rows: e - o });
                    })(s, l.lastRow + 1, l.lastColumn + 1, i));
                  u || !Object(a.f)(t, i)
                    ? (function (t, e, n) {
                        const {
                            firstRow: i,
                            lastRow: s,
                            firstColumn: o,
                            lastColumn: r,
                          } = e,
                          a = { first: i, last: s },
                          c = { first: o, last: r };
                        h(t, o, a, n),
                          h(t, r + 1, a, n),
                          d(t, i, c, n),
                          d(t, s + 1, c, n, i);
                      })(s, l, n)
                    : ((l.lastRow = Object(c.b)(s, l)),
                      (l.lastColumn = Object(c.a)(s, l)));
                  return l;
                })(l, e, t, s),
                i = n.lastRow - n.firstRow + 1,
                r = n.lastColumn - n.firstColumn + 1,
                u = {
                  startRow: 0,
                  startColumn: 0,
                  endRow: Math.min(i, e.height) - 1,
                  endColumn: Math.min(r, e.width) - 1,
                };
              o = Object(c.c)(o, u, t);
              const f = l[0].findAncestor("table"),
                m = this._replaceSelectedCellsWithPasted(o, e, f, n, t);
              if (this.editor.plugins.get("TableSelection").isEnabled) {
                const e = Object(a.g)(m.map((e) => t.createRangeOn(e)));
                t.setSelection(e);
              } else t.setSelection(m[0], 0);
            }))
          : Object(c.h)(o, s);
      }
      _replaceSelectedCellsWithPasted(t, e, n, i, s) {
        const { width: r, height: a } = e,
          l = (function (t, e, n) {
            const i = new Array(n)
              .fill(null)
              .map(() => new Array(e).fill(null));
            for (const { column: e, row: n, cell: s } of new o.a(t))
              i[n][e] = s;
            return i;
          })(t, r, a),
          u = [
            ...new o.a(n, {
              startRow: i.firstRow,
              endRow: i.lastRow,
              startColumn: i.firstColumn,
              endColumn: i.lastColumn,
              includeAllSlots: !0,
            }),
          ],
          f = [];
        let m;
        for (const t of u) {
          const { row: e, column: n } = t;
          n === i.firstColumn && (m = t.getPositionBefore());
          const o = e - i.firstRow,
            u = n - i.firstColumn,
            d = l[o % a][u % r],
            h = d ? s.cloneElement(d) : null,
            g = this._replaceTableSlotCell(t, h, m, s);
          g &&
            (Object(c.k)(g, e, n, i.lastRow, i.lastColumn, s),
            f.push(g),
            (m = s.createPositionAfter(g)));
        }
        const g = parseInt(n.getAttribute("headingRows") || 0),
          p = parseInt(n.getAttribute("headingColumns") || 0),
          b = i.firstRow < g && g <= i.lastRow,
          w = i.firstColumn < p && p <= i.lastColumn;
        if (b) {
          const t = d(
            n,
            g,
            { first: i.firstColumn, last: i.lastColumn },
            s,
            i.firstRow
          );
          f.push(...t);
        }
        if (w) {
          const t = h(n, p, { first: i.firstRow, last: i.lastRow }, s);
          f.push(...t);
        }
        return f;
      }
      _replaceTableSlotCell(t, e, n, i) {
        const { cell: s, isAnchor: o } = t;
        return o && i.remove(s), e ? (i.insert(e, n), e) : null;
      }
    }
    function u(t, e) {
      if (!t.is("documentFragment") && !t.is("element")) return null;
      if (t.is("element", "table")) return t;
      if (1 == t.childCount && t.getChild(0).is("element", "table"))
        return t.getChild(0);
      const n = e.createRangeIn(t);
      for (const t of n.getItems())
        if (t.is("element", "table")) {
          const i = e.createRange(n.start, e.createPositionBefore(t));
          if (e.hasContent(i, { ignoreWhitespaces: !0 })) return null;
          const s = e.createRange(e.createPositionAfter(t), n.end);
          return e.hasContent(s, { ignoreWhitespaces: !0 }) ? null : t;
        }
      return null;
    }
    function d(t, e, n, i, s = 0) {
      if (e < 1) return;
      return Object(c.e)(t, e, s)
        .filter(({ column: t, cellWidth: e }) => f(t, e, n))
        .map(({ cell: t }) => Object(c.i)(t, e, i));
    }
    function h(t, e, n, i) {
      if (e < 1) return;
      return Object(c.d)(t, e)
        .filter(({ row: t, cellHeight: e }) => f(t, e, n))
        .map(({ cell: t, column: n }) => Object(c.j)(t, n, e, i));
    }
    function f(t, e, n) {
      const i = t + e - 1,
        { first: s, last: o } = n;
      return (t >= s && t <= o) || (t < s && i >= s);
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return i;
    });
    class i {
      constructor() {
        this._replacedElements = [];
      }
      replace(t, e) {
        this._replacedElements.push({ element: t, newElement: e }),
          (t.style.display = "none"),
          e && t.parentNode.insertBefore(e, t.nextSibling);
      }
      restore() {
        this._replacedElements.forEach(({ element: t, newElement: e }) => {
          (t.style.display = ""), e && e.remove();
        }),
          (this._replacedElements = []);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(123),
      s = n(0);
    function o(t) {
      if (!Object(i.a)(t.updateSourceElement))
        throw new s.default("attachtoform-missing-elementapi-interface", t);
      const e = t.sourceElement;
      if (e && "textarea" === e.tagName.toLowerCase() && e.form) {
        let n;
        const s = e.form,
          o = () => t.updateSourceElement();
        Object(i.a)(s.submit) &&
          ((n = s.submit),
          (s.submit = () => {
            o(), n.apply(s);
          })),
          s.addEventListener("submit", o),
          t.on("destroy", () => {
            s.removeEventListener("submit", o), n && (s.submit = n);
          });
      }
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(0),
      s = n(187);
    const o = {
      updateSourceElement() {
        if (!this.sourceElement)
          throw new i.default("editor-missing-sourceelement", this);
        Object(s.a)(this.sourceElement, this.data.get());
      },
    };
    e.a = o;
  },
  function (t, e, n) {
    "use strict";
    function i({
      origin: t,
      originKeystrokeHandler: e,
      originFocusTracker: n,
      toolbar: i,
      beforeFocus: s,
      afterBlur: o,
    }) {
      n.add(i.element),
        e.set("Alt+F10", (t, e) => {
          n.isFocused &&
            !i.focusTracker.isFocused &&
            (s && s(), i.focus(), e());
        }),
        i.keystrokes.set("Esc", (e, n) => {
          i.focusTracker.isFocused && (t.focus(), o && o(), n());
        });
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "b", function () {
      return s;
    }),
      n.d(e, "a", function () {
        return o;
      }),
      n.d(e, "e", function () {
        return r;
      }),
      n.d(e, "c", function () {
        return a;
      }),
      n.d(e, "d", function () {
        return c;
      });
    n(351);
    const i = new WeakMap();
    function s(t) {
      const {
          view: e,
          element: n,
          text: s,
          isDirectHost: o = !0,
          keepOnFocus: r = !1,
        } = t,
        a = e.document;
      i.has(a) || (i.set(a, new Map()), a.registerPostFixer((t) => l(a, t))),
        i.get(a).set(n, {
          text: s,
          isDirectHost: o,
          keepOnFocus: r,
          hostElement: o ? n : null,
        }),
        e.change((t) => l(a, t));
    }
    function o(t, e) {
      const n = e.document;
      t.change((t) => {
        if (!i.has(n)) return;
        const s = i.get(n),
          o = s.get(e);
        t.removeAttribute("data-placeholder", o.hostElement),
          a(t, o.hostElement),
          s.delete(e);
      });
    }
    function r(t, e) {
      return (
        !e.hasClass("ck-placeholder") && (t.addClass("ck-placeholder", e), !0)
      );
    }
    function a(t, e) {
      return (
        !!e.hasClass("ck-placeholder") &&
        (t.removeClass("ck-placeholder", e), !0)
      );
    }
    function c(t, e) {
      if (!t.isAttached()) return !1;
      if (Array.from(t.getChildren()).some((t) => !t.is("uiElement")))
        return !1;
      if (e) return !0;
      const n = t.document;
      if (!n.isFocused) return !0;
      const i = n.selection.anchor;
      return i && i.parent !== t;
    }
    function l(t, e) {
      const n = i.get(t),
        s = [];
      let o = !1;
      for (const [t, i] of n)
        i.isDirectHost && (s.push(t), u(e, t, i) && (o = !0));
      for (const [t, i] of n) {
        if (i.isDirectHost) continue;
        const n = d(t);
        n && (s.includes(n) || ((i.hostElement = n), u(e, t, i) && (o = !0)));
      }
      return o;
    }
    function u(t, e, n) {
      const { text: i, isDirectHost: s, hostElement: o } = n;
      let l = !1;
      o.getAttribute("data-placeholder") !== i &&
        (t.setAttribute("data-placeholder", i, o), (l = !0));
      return (
        (s || 1 == e.childCount) && c(o, n.keepOnFocus)
          ? r(t, o) && (l = !0)
          : a(t, o) && (l = !0),
        l
      );
    }
    function d(t) {
      if (t.childCount) {
        const e = t.getChild(0);
        if (e.is("element") && !e.is("uiElement")) return e;
      }
      return null;
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(59);
    class s extends i.a {
      constructor(t) {
        super(t), (this.domEventType = "click");
      }
      onDomEvent(t) {
        this.fire(t.type, t);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(9),
      s = n(90),
      o = n(197),
      r = n(198);
    class a extends i.a {
      static get pluginName() {
        return "Clipboard";
      }
      static get requires() {
        return [s.a, o.a, r.a];
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return i;
    });
    class i {
      getHtml(t) {
        const e = document.implementation
          .createHTMLDocument("")
          .createElement("div");
        return e.appendChild(t), e.innerHTML;
      }
    }
  },
  function (t, e, n) {
    "use strict";
    e.a =
      '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>';
  },
  function (t, e, n) {
    "use strict";
    e.a =
      '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>';
  },
  function (t, e, n) {
    "use strict";
    e.a =
      '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>';
  },
  function (t, e, n) {
    "use strict";
    e.a =
      '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>';
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return u;
    });
    var i = n(1),
      s = n(2),
      o = n(304);
    const r = /^data:(\S*?);base64,/;
    class a {
      constructor(t, e, n) {
        if (!t) throw new s.a("fileuploader-missing-file", null);
        if (!e) throw new s.a("fileuploader-missing-token", null);
        if (!n) throw new s.a("fileuploader-missing-api-address", null);
        (this.file = (function (t) {
          if ("string" != typeof t) return !1;
          const e = t.match(r);
          return !(!e || !e.length);
        })(t)
          ? (function (t, e = 512) {
              try {
                const n = t.match(r)[1],
                  i = atob(t.replace(r, "")),
                  s = [];
                for (let t = 0; t < i.length; t += e) {
                  const n = i.slice(t, t + e),
                    o = new Array(n.length);
                  for (let t = 0; t < n.length; t++) o[t] = n.charCodeAt(t);
                  s.push(new Uint8Array(o));
                }
                return new Blob(s, { type: n });
              } catch (t) {
                throw new s.a("fileuploader-decoding-image-data-error", null);
              }
            })(t)
          : t),
          (this._token = e),
          (this._apiAddress = n);
      }
      onProgress(t) {
        return this.on("progress", (e, n) => t(n)), this;
      }
      onError(t) {
        return this.once("error", (e, n) => t(n)), this;
      }
      abort() {
        this.xhr.abort();
      }
      send() {
        return (
          this._prepareRequest(),
          this._attachXHRListeners(),
          this._sendRequest()
        );
      }
      _prepareRequest() {
        const t = new XMLHttpRequest();
        t.open("POST", this._apiAddress),
          t.setRequestHeader("Authorization", this._token.value),
          (t.responseType = "json"),
          (this.xhr = t);
      }
      _attachXHRListeners() {
        const t = this,
          e = this.xhr;
        function n(e) {
          return () => t.fire("error", e);
        }
        e.addEventListener("error", n("Network Error")),
          e.addEventListener("abort", n("Abort")),
          e.upload &&
            e.upload.addEventListener("progress", (t) => {
              t.lengthComputable &&
                this.fire("progress", { total: t.total, uploaded: t.loaded });
            }),
          e.addEventListener("load", () => {
            const t = e.status,
              n = e.response;
            if (t < 200 || t > 299)
              return this.fire("error", n.message || n.error);
          });
      }
      _sendRequest() {
        const t = new FormData(),
          e = this.xhr;
        return (
          t.append("file", this.file),
          new Promise((n, i) => {
            e.addEventListener("load", () => {
              const t = e.status,
                o = e.response;
              return t < 200 || t > 299
                ? o.message
                  ? i(
                      new s.a("fileuploader-uploading-data-failed", this, {
                        message: o.message,
                      })
                    )
                  : i(o.error)
                : n(o);
            }),
              e.addEventListener("error", () => i(new Error("Network Error"))),
              e.addEventListener("abort", () => i(new Error("Abort"))),
              e.send(t);
          })
        );
      }
    }
    Object(s.v)(a, s.e);
    class c {
      constructor(t, e) {
        if (!t) throw new s.a("uploadgateway-missing-token", null);
        if (!e) throw new s.a("uploadgateway-missing-api-address", null);
        (this._token = t), (this._apiAddress = e);
      }
      upload(t) {
        return new a(t, this._token, this._apiAddress);
      }
    }
    class l extends i.c {
      static get pluginName() {
        return "CloudServicesCore";
      }
      createToken(t, e) {
        return new o.a(t, e);
      }
      createUploadGateway(t, e) {
        return new c(t, e);
      }
    }
    class u extends i.c {
      static get pluginName() {
        return "CloudServices";
      }
      static get requires() {
        return [l];
      }
      init() {
        const t = this.context.config.get("cloudServices") || {};
        for (const e in t) this[e] = t[e];
        if (((this._tokens = new Map()), this.tokenUrl))
          return (
            (this.token = this.context.plugins
              .get("CloudServicesCore")
              .createToken(this.tokenUrl)),
            this._tokens.set(this.tokenUrl, this.token),
            this.token.init()
          );
        this.token = null;
      }
      registerTokenUrl(t) {
        if (this._tokens.has(t)) return Promise.resolve(this.getTokenFor(t));
        const e = this.context.plugins.get("CloudServicesCore").createToken(t);
        return this._tokens.set(t, e), e.init();
      }
      getTokenFor(t) {
        const e = this._tokens.get(t);
        if (!e) throw new s.a("cloudservices-token-not-registered", this);
        return e;
      }
      destroy() {
        super.destroy();
        for (const t of this._tokens.values()) t.destroy();
      }
    }
  },
  function (t, e, n) {
    "use strict";
    function i(t) {
      const e = t.t,
        n = {
          Paragraph: e("Paragraph"),
          "Heading 1": e("Heading 1"),
          "Heading 2": e("Heading 2"),
          "Heading 3": e("Heading 3"),
          "Heading 4": e("Heading 4"),
          "Heading 5": e("Heading 5"),
          "Heading 6": e("Heading 6"),
        };
      return t.config.get("heading.options").map((t) => {
        const e = n[t.title];
        return e && e != t.title && (t.title = e), t;
      });
    }
    n.d(e, "a", function () {
      return i;
    });
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return s;
    });
    var i = n(13);
    class s extends i.m {
      observe(t) {
        this.listenTo(
          t,
          "load",
          (t, e) => {
            const n = e.target;
            this.checkShouldIgnoreEventFromTarget(n) ||
              ("IMG" == n.tagName && this._fireEvents(e));
          },
          { useCapture: !0 }
        );
      }
      _fireEvents(t) {
        this.isEnabled &&
          (this.document.fire("layoutChanged"),
          this.document.fire("imageLoaded", t));
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(9),
      s = n(231),
      o = n(128);
    class r extends i.a {
      static get requires() {
        return [s.a, o.a];
      }
      static get pluginName() {
        return "Typing";
      }
    }
  },
  function (t, e, n) {
    "use strict";
    e.a = function () {
      return !1;
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(1),
      s = n(165);
    class o extends i.j {
      static get pluginName() {
        return "BoldEditing";
      }
      init() {
        const t = this.editor;
        t.model.schema.extend("$text", { allowAttributes: "bold" }),
          t.model.schema.setAttributeProperties("bold", {
            isFormatting: !0,
            copyOnEnter: !0,
          }),
          t.conversion.attributeToElement({
            model: "bold",
            view: "strong",
            upcastAlso: [
              "b",
              (t) => {
                const e = t.getStyle("font-weight");
                return e
                  ? "bold" == e || Number(e) >= 600
                    ? { name: !0, styles: ["font-weight"] }
                    : void 0
                  : null;
              },
            ],
          }),
          t.commands.add("bold", new s.a(t, "bold")),
          t.keystrokes.set("CTRL+B", "bold");
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(1),
      s = n(165);
    class o extends i.j {
      static get pluginName() {
        return "ItalicEditing";
      }
      init() {
        const t = this.editor;
        t.model.schema.extend("$text", { allowAttributes: "italic" }),
          t.model.schema.setAttributeProperties("italic", {
            isFormatting: !0,
            copyOnEnter: !0,
          }),
          t.conversion.attributeToElement({
            model: "italic",
            view: "i",
            upcastAlso: ["em", { styles: { "font-style": "italic" } }],
          }),
          t.commands.add("italic", new s.a(t, "italic")),
          t.keystrokes.set("CTRL+I", "italic");
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return c;
    });
    var i = n(1),
      s = n(254),
      o = n(2);
    class r extends i.a {
      constructor(t, e) {
        super(t), (this.modelElements = e);
      }
      refresh() {
        const t = Object(o.n)(
          this.editor.model.document.selection.getSelectedBlocks()
        );
        (this.value = !!t && this.modelElements.includes(t.name) && t.name),
          (this.isEnabled =
            !!t &&
            this.modelElements.some((e) => a(t, e, this.editor.model.schema)));
      }
      execute(t) {
        const e = this.editor.model,
          n = e.document,
          i = t.value;
        e.change((t) => {
          const s = Array.from(n.selection.getSelectedBlocks()).filter((t) =>
            a(t, i, e.schema)
          );
          for (const e of s) e.is("element", i) || t.rename(e, i);
        });
      }
    }
    function a(t, e, n) {
      return n.checkChild(t.parent, e) && !n.isObject(t);
    }
    class c extends i.j {
      static get pluginName() {
        return "HeadingEditing";
      }
      constructor(t) {
        super(t),
          t.config.define("heading", {
            options: [
              {
                model: "paragraph",
                title: "Paragraph",
                class: "ck-heading_paragraph",
              },
              {
                model: "heading1",
                view: "h2",
                title: "Heading 1",
                class: "ck-heading_heading1",
              },
              {
                model: "heading2",
                view: "h3",
                title: "Heading 2",
                class: "ck-heading_heading2",
              },
              {
                model: "heading3",
                view: "h4",
                title: "Heading 3",
                class: "ck-heading_heading3",
              },
            ],
          });
      }
      static get requires() {
        return [s.a];
      }
      init() {
        const t = this.editor,
          e = t.config.get("heading.options"),
          n = [];
        for (const i of e)
          "paragraph" !== i.model &&
            (t.model.schema.register(i.model, { inheritAllFrom: "$block" }),
            t.conversion.elementToElement(i),
            n.push(i.model));
        this._addDefaultH1Conversion(t), t.commands.add("heading", new r(t, n));
      }
      afterInit() {
        const t = this.editor,
          e = t.commands.get("enter"),
          n = t.config.get("heading.options");
        e &&
          this.listenTo(e, "afterExecute", (e, i) => {
            const s = t.model.document.selection.getFirstPosition().parent;
            n.some((t) => s.is("element", t.model)) &&
              !s.is("element", "paragraph") &&
              0 === s.childCount &&
              i.writer.rename(s, "paragraph");
          });
      }
      _addDefaultH1Conversion(t) {
        t.conversion.for("upcast").elementToElement({
          model: "heading1",
          view: "h1",
          converterPriority: o.x.get("low") + 1,
        });
      }
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(226);
    e.a = function (t, e) {
      return Object(i.a)(t, e);
    };
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return y;
    });
    var i = n(1),
      s = n(19),
      o = n(250),
      r = n(4),
      a = n(2);
    n(361);
    class c extends r.D {
      constructor(t) {
        super(t);
        const e = this.bindTemplate;
        (this.items = this._createGridCollection()),
          this.set("rows", 0),
          this.set("columns", 0),
          this.bind("label").to(
            this,
            "columns",
            this,
            "rows",
            (t, e) => `${e} × ${t}`
          ),
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck"] },
            children: [
              {
                tag: "div",
                attributes: { class: ["ck-insert-table-dropdown__grid"] },
                on: {
                  "mouseover@.ck-insert-table-dropdown-grid-box":
                    e.to("boxover"),
                },
                children: this.items,
              },
              {
                tag: "div",
                attributes: { class: ["ck-insert-table-dropdown__label"] },
                children: [{ text: e.to("label") }],
              },
            ],
            on: {
              mousedown: e.to((t) => {
                t.preventDefault();
              }),
              click: e.to(() => {
                this.fire("execute");
              }),
            },
          }),
          this.on("boxover", (t, e) => {
            const { row: n, column: i } = e.target.dataset;
            this.set({ rows: parseInt(n), columns: parseInt(i) });
          }),
          this.on("change:columns", () => {
            this._highlightGridBoxes();
          }),
          this.on("change:rows", () => {
            this._highlightGridBoxes();
          });
      }
      focus() {}
      focusLast() {}
      _highlightGridBoxes() {
        const t = this.rows,
          e = this.columns;
        this.items.map((n, i) => {
          const s = Math.floor(i / 10) < t && i % 10 < e;
          n.set("isOn", s);
        });
      }
      _createGridCollection() {
        const t = [];
        for (let e = 0; e < 100; e++) {
          const n = Math.floor(e / 10),
            i = e % 10;
          t.push(new l(this.locale, n + 1, i + 1));
        }
        return this.createCollection(t);
      }
    }
    class l extends r.D {
      constructor(t, e, n) {
        super(t);
        const i = this.bindTemplate;
        this.set("isOn", !1),
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck-insert-table-dropdown-grid-box",
                i.if("isOn", "ck-on"),
              ],
              "data-row": e,
              "data-column": n,
            },
          });
      }
    }
    class u extends i.j {
      static get pluginName() {
        return "TableUI";
      }
      init() {
        const t = this.editor,
          e = this.editor.t,
          n = "ltr" === t.locale.contentLanguageDirection;
        t.ui.componentFactory.add("insertTable", (n) => {
          const i = t.commands.get("insertTable"),
            s = Object(r.I)(n);
          let o;
          return (
            s.bind("isEnabled").to(i),
            s.buttonView.set({
              icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>',
              label: e("Insert table"),
              tooltip: !0,
            }),
            s.on("change:isOpen", () => {
              o ||
                ((o = new c(n)),
                s.panelView.children.add(o),
                o.delegate("execute").to(s),
                s.buttonView.on("open", () => {
                  (o.rows = 0), (o.columns = 0);
                }),
                s.on("execute", () => {
                  t.execute("insertTable", {
                    rows: o.rows,
                    columns: o.columns,
                  }),
                    t.editing.view.focus();
                }));
            }),
            s
          );
        }),
          t.ui.componentFactory.add("tableColumn", (t) => {
            const i = [
              {
                type: "switchbutton",
                model: {
                  commandName: "setTableColumnHeader",
                  label: e("Header column"),
                  bindIsOn: !0,
                },
              },
              { type: "separator" },
              {
                type: "button",
                model: {
                  commandName: n
                    ? "insertTableColumnLeft"
                    : "insertTableColumnRight",
                  label: e("Insert column left"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: n
                    ? "insertTableColumnRight"
                    : "insertTableColumnLeft",
                  label: e("Insert column right"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: "removeTableColumn",
                  label: e("Delete column"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: "selectTableColumn",
                  label: e("Select column"),
                },
              },
            ];
            return this._prepareDropdown(
              e("Column"),
              '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>',
              i,
              t
            );
          }),
          t.ui.componentFactory.add("tableRow", (t) => {
            const n = [
              {
                type: "switchbutton",
                model: {
                  commandName: "setTableRowHeader",
                  label: e("Header row"),
                  bindIsOn: !0,
                },
              },
              { type: "separator" },
              {
                type: "button",
                model: {
                  commandName: "insertTableRowAbove",
                  label: e("Insert row above"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: "insertTableRowBelow",
                  label: e("Insert row below"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: "removeTableRow",
                  label: e("Delete row"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: "selectTableRow",
                  label: e("Select row"),
                },
              },
            ];
            return this._prepareDropdown(
              e("Row"),
              '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>',
              n,
              t
            );
          }),
          t.ui.componentFactory.add("mergeTableCells", (t) => {
            const i = [
              {
                type: "button",
                model: {
                  commandName: "mergeTableCellUp",
                  label: e("Merge cell up"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: n ? "mergeTableCellRight" : "mergeTableCellLeft",
                  label: e("Merge cell right"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: "mergeTableCellDown",
                  label: e("Merge cell down"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: n ? "mergeTableCellLeft" : "mergeTableCellRight",
                  label: e("Merge cell left"),
                },
              },
              { type: "separator" },
              {
                type: "button",
                model: {
                  commandName: "splitTableCellVertically",
                  label: e("Split cell vertically"),
                },
              },
              {
                type: "button",
                model: {
                  commandName: "splitTableCellHorizontally",
                  label: e("Split cell horizontally"),
                },
              },
            ];
            return this._prepareMergeSplitButtonDropdown(
              e("Merge cells"),
              '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>',
              i,
              t
            );
          });
      }
      _prepareDropdown(t, e, n, i) {
        const s = this.editor,
          o = Object(r.I)(i),
          a = this._fillDropdownWithListOptions(o, n);
        return (
          o.buttonView.set({ label: t, icon: e, tooltip: !0 }),
          o
            .bind("isEnabled")
            .toMany(a, "isEnabled", (...t) => t.some((t) => t)),
          this.listenTo(o, "execute", (t) => {
            s.execute(t.source.commandName), s.editing.view.focus();
          }),
          o
        );
      }
      _prepareMergeSplitButtonDropdown(t, e, n, i) {
        const s = this.editor,
          o = Object(r.I)(i, r.w),
          a = s.commands.get("mergeTableCells"),
          c = this._fillDropdownWithListOptions(o, n);
        return (
          o.buttonView.set({ label: t, icon: e, tooltip: !0, isEnabled: !0 }),
          o
            .bind("isEnabled")
            .toMany([a, ...c], "isEnabled", (...t) => t.some((t) => t)),
          this.listenTo(o.buttonView, "execute", () => {
            s.execute("mergeTableCells"), s.editing.view.focus();
          }),
          this.listenTo(o, "execute", (t) => {
            s.execute(t.source.commandName), s.editing.view.focus();
          }),
          o
        );
      }
      _fillDropdownWithListOptions(t, e) {
        const n = this.editor,
          i = [],
          s = new a.b();
        for (const t of e) d(t, n, i, s);
        return Object(r.F)(t, s, n.ui.componentFactory), i;
      }
    }
    function d(t, e, n, i) {
      const s = (t.model = new r.u(t.model)),
        { commandName: o, bindIsOn: a } = t.model;
      if ("button" === t.type || "switchbutton" === t.type) {
        const t = e.commands.get(o);
        n.push(t),
          s.set({ commandName: o }),
          s.bind("isEnabled").to(t),
          a && s.bind("isOn").to(t, "value");
      }
      s.set({ withText: !0 }), i.add(t);
    }
    var h = n(84),
      f = n(278),
      m = n(16),
      g = n(10);
    class p extends i.j {
      static get pluginName() {
        return "TableKeyboard";
      }
      static get requires() {
        return [h.a];
      }
      init() {
        const t = this.editor.editing.view.document;
        this.editor.keystrokes.set(
          "Tab",
          (...t) => this._handleTabOnSelectedTable(...t),
          { priority: "low" }
        ),
          this.editor.keystrokes.set("Tab", this._getTabHandler(!0), {
            priority: "low",
          }),
          this.editor.keystrokes.set("Shift+Tab", this._getTabHandler(!1), {
            priority: "low",
          }),
          this.listenTo(t, "arrowKey", (...t) => this._onArrowKey(...t), {
            context: "table",
          });
      }
      _handleTabOnSelectedTable(t, e) {
        const n = this.editor,
          i = n.model.document.selection.getSelectedElement();
        i &&
          i.is("element", "table") &&
          (e(),
          n.model.change((t) => {
            t.setSelection(t.createRangeIn(i.getChild(0).getChild(0)));
          }));
      }
      _getTabHandler(t) {
        const e = this.editor;
        return (n, i) => {
          const s = e.model.document.selection;
          let o = Object(g.e)(s)[0];
          if (
            (o ||
              (o = this.editor.plugins.get("TableSelection").getFocusCell()),
            !o)
          )
            return;
          i();
          const r = o.parent,
            a = r.parent,
            c = a.getChildIndex(r),
            l = r.getChildIndex(o),
            u = 0 === l;
          if (!t && u && 0 === c)
            return void e.model.change((t) => {
              t.setSelection(t.createRangeOn(a));
            });
          const d = this.editor.plugins.get("TableUtils"),
            h = l === r.childCount - 1,
            f = c === d.getRows(a) - 1;
          if (
            t &&
            f &&
            h &&
            (e.execute("insertTableRowBelow"), c === d.getRows(a) - 1)
          )
            return void e.model.change((t) => {
              t.setSelection(t.createRangeOn(a));
            });
          let m;
          if (t && h) {
            const t = a.getChild(c + 1);
            m = t.getChild(0);
          } else if (!t && u) {
            const t = a.getChild(c - 1);
            m = t.getChild(t.childCount - 1);
          } else m = r.getChild(l + (t ? 1 : -1));
          e.model.change((t) => {
            t.setSelection(t.createRangeIn(m));
          });
        };
      }
      _onArrowKey(t, e) {
        const n = this.editor,
          i = e.keyCode,
          s = Object(a.r)(i, n.locale.contentLanguageDirection);
        this._handleArrowKeys(s, e.shiftKey) &&
          (e.preventDefault(), e.stopPropagation(), t.stop());
      }
      _handleArrowKeys(t, e) {
        const n = this.editor.model,
          i = n.document.selection,
          s = ["right", "down"].includes(t),
          o = Object(g.c)(i);
        if (o.length) {
          let n;
          return (
            (n = e
              ? this.editor.plugins.get("TableSelection").getFocusCell()
              : s
              ? o[o.length - 1]
              : o[0]),
            this._navigateFromCellInDirection(n, t, e),
            !0
          );
        }
        const r = i.focus.findAncestor("tableCell");
        if (!r) return !1;
        if (!i.isCollapsed)
          if (e) {
            if (i.isBackward == s && !i.containsEntireContent(r)) return !1;
          } else {
            const t = i.getSelectedElement();
            if (!t || !n.schema.isObject(t)) return !1;
          }
        return (
          !!this._isSelectionAtCellEdge(i, r, s) &&
          (this._navigateFromCellInDirection(r, t, e), !0)
        );
      }
      _isSelectionAtCellEdge(t, e, n) {
        const i = this.editor.model,
          s = this.editor.model.schema,
          o = n ? t.getLastPosition() : t.getFirstPosition();
        if (!s.getLimitElement(o).is("element", "tableCell")) {
          return i.createPositionAt(e, n ? "end" : 0).isTouching(o);
        }
        const r = i.createSelection(o);
        return (
          i.modifySelection(r, { direction: n ? "forward" : "backward" }),
          o.isEqual(r.focus)
        );
      }
      _navigateFromCellInDirection(t, e, n = !1) {
        const i = this.editor.model,
          s = t.findAncestor("table"),
          o = [...new m.a(s, { includeAllSlots: !0 })],
          { row: r, column: a } = o[o.length - 1],
          c = o.find(({ cell: e }) => e == t);
        let { row: l, column: u } = c;
        switch (e) {
          case "left":
            u--;
            break;
          case "up":
            l--;
            break;
          case "right":
            u += c.cellWidth;
            break;
          case "down":
            l += c.cellHeight;
        }
        if (l < 0 || l > r || (u < 0 && l <= 0) || (u > a && l >= r))
          return void i.change((t) => {
            t.setSelection(t.createRangeOn(s));
          });
        u < 0 ? ((u = n ? 0 : a), l--) : u > a && ((u = n ? a : 0), l++);
        const d = o.find((t) => t.row == l && t.column == u).cell,
          h = ["right", "down"].includes(e),
          f = this.editor.plugins.get("TableSelection");
        if (n && f.isEnabled) {
          const e = f.getAnchorCell() || t;
          f.setCellSelection(e, d);
        } else {
          const t = i.createPositionAt(d, h ? 0 : "end");
          i.change((e) => {
            e.setSelection(t);
          });
        }
      }
    }
    var b = n(13);
    class w extends b.c {
      constructor(t) {
        super(t), (this.domEventType = ["mousemove", "mouseleave"]);
      }
      onDomEvent(t) {
        this.fire(t.type, t);
      }
    }
    class v extends i.j {
      static get pluginName() {
        return "TableMouse";
      }
      static get requires() {
        return [h.a];
      }
      init() {
        this.editor.editing.view.addObserver(w),
          this._enableShiftClickSelection(),
          this._enableMouseDragSelection();
      }
      _enableShiftClickSelection() {
        const t = this.editor;
        let e = !1;
        const n = t.plugins.get(h.a);
        this.listenTo(t.editing.view.document, "mousedown", (i, s) => {
          if (!this.isEnabled || !n.isEnabled) return;
          if (!s.domEvent.shiftKey) return;
          const o =
            n.getAnchorCell() || Object(g.e)(t.model.document.selection)[0];
          if (!o) return;
          const r = this._getModelTableCellFromDomEvent(s);
          r &&
            _(o, r) &&
            ((e = !0), n.setCellSelection(o, r), s.preventDefault());
        }),
          this.listenTo(t.editing.view.document, "mouseup", () => {
            e = !1;
          }),
          this.listenTo(
            t.editing.view.document,
            "selectionChange",
            (t) => {
              e && t.stop();
            },
            { priority: "highest" }
          );
      }
      _enableMouseDragSelection() {
        const t = this.editor;
        let e,
          n,
          i = !1,
          s = !1;
        const o = t.plugins.get(h.a);
        this.listenTo(t.editing.view.document, "mousedown", (t, n) => {
          this.isEnabled &&
            o.isEnabled &&
            (n.domEvent.shiftKey ||
              n.domEvent.ctrlKey ||
              n.domEvent.altKey ||
              (e = this._getModelTableCellFromDomEvent(n)));
        }),
          this.listenTo(t.editing.view.document, "mousemove", (t, r) => {
            if (!r.domEvent.buttons) return;
            if (!e) return;
            const a = this._getModelTableCellFromDomEvent(r);
            a && _(e, a) && ((n = a), i || n == e || (i = !0)),
              i && ((s = !0), o.setCellSelection(e, n), r.preventDefault());
          }),
          this.listenTo(t.editing.view.document, "mouseup", () => {
            (i = !1), (s = !1), (e = null), (n = null);
          }),
          this.listenTo(
            t.editing.view.document,
            "selectionChange",
            (t) => {
              s && t.stop();
            },
            { priority: "highest" }
          );
      }
      _getModelTableCellFromDomEvent(t) {
        const e = t.target,
          n = this.editor.editing.view.createPositionAt(e, 0);
        return this.editor.editing.mapper
          .toModelPosition(n)
          .parent.findAncestor("tableCell", { includeSelf: !0 });
      }
    }
    function _(t, e) {
      return t.parent.parent == e.parent.parent;
    }
    n(362);
    class y extends i.j {
      static get requires() {
        return [o.a, u, h.a, v, p, f.a, s.a];
      }
      static get pluginName() {
        return "Table";
      }
    }
  },
  function (t, e, n) {},
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return m;
    });
    var i = n(1),
      s = n(13),
      o = n(33),
      r = n(77),
      a = n(2);
    class c {
      constructor() {
        this._definitions = new Set();
      }
      get length() {
        return this._definitions.size;
      }
      add(t) {
        Array.isArray(t)
          ? t.forEach((t) => this._definitions.add(t))
          : this._definitions.add(t);
      }
      getDispatcher() {
        return (t) => {
          t.on(
            "attribute:linkHref",
            (t, e, n) => {
              if (!n.consumable.test(e.item, "attribute:linkHref")) return;
              const i = n.writer,
                s = i.document.selection;
              for (const t of this._definitions) {
                const o = i.createAttributeElement("a", t.attributes, {
                  priority: 5,
                });
                t.classes && i.addClass(t.classes, o);
                for (const e in t.styles) i.setStyle(e, t.styles[e], o);
                i.setCustomProperty("link", !0, o),
                  t.callback(e.attributeNewValue)
                    ? e.item.is("selection")
                      ? i.wrap(s.getFirstRange(), o)
                      : i.wrap(n.mapper.toViewRange(e.range), o)
                    : i.unwrap(n.mapper.toViewRange(e.range), o);
              }
            },
            { priority: "high" }
          );
        };
      }
      getDispatcherForLinkedImage() {
        return (t) => {
          t.on(
            "attribute:linkHref:imageBlock",
            (t, e, { writer: n, mapper: i }) => {
              const s = i.toViewElement(e.item),
                o = Array.from(s.getChildren()).find((t) => "a" === t.name);
              for (const t of this._definitions) {
                const i = Object(a.A)(t.attributes);
                if (t.callback(e.attributeNewValue)) {
                  for (const [t, e] of i)
                    "class" === t ? n.addClass(e, o) : n.setAttribute(t, e, o);
                  t.classes && n.addClass(t.classes, o);
                  for (const e in t.styles) n.setStyle(e, t.styles[e], o);
                } else {
                  for (const [t, e] of i)
                    "class" === t
                      ? n.removeClass(e, o)
                      : n.removeAttribute(t, o);
                  t.classes && n.removeClass(t.classes, o);
                  for (const e in t.styles) n.removeStyle(e, o);
                }
              }
            }
          );
        };
      }
    }
    var l = n(43);
    class u extends i.a {
      constructor(t) {
        super(t),
          (this.manualDecorators = new a.b()),
          (this.automaticDecorators = new c());
      }
      restoreManualDecoratorStates() {
        for (const t of this.manualDecorators)
          t.value = this._getDecoratorStateFromModel(t.id);
      }
      refresh() {
        const t = this.editor.model,
          e = t.document.selection,
          n = e.getSelectedElement() || Object(a.n)(e.getSelectedBlocks());
        Object(l.g)(n, t.schema)
          ? ((this.value = n.getAttribute("linkHref")),
            (this.isEnabled = t.schema.checkAttribute(n, "linkHref")))
          : ((this.value = e.getAttribute("linkHref")),
            (this.isEnabled = t.schema.checkAttributeInSelection(
              e,
              "linkHref"
            )));
        for (const t of this.manualDecorators)
          t.value = this._getDecoratorStateFromModel(t.id);
      }
      execute(t, e = {}) {
        const n = this.editor.model,
          i = n.document.selection,
          s = [],
          r = [];
        for (const t in e) e[t] ? s.push(t) : r.push(t);
        n.change((e) => {
          if (i.isCollapsed) {
            const c = i.getFirstPosition();
            if (i.hasAttribute("linkHref")) {
              const a = Object(o.f)(
                c,
                "linkHref",
                i.getAttribute("linkHref"),
                n
              );
              e.setAttribute("linkHref", t, a),
                s.forEach((t) => {
                  e.setAttribute(t, !0, a);
                }),
                r.forEach((t) => {
                  e.removeAttribute(t, a);
                }),
                e.setSelection(e.createPositionAfter(a.end.nodeBefore));
            } else if ("" !== t) {
              const o = Object(a.A)(i.getAttributes());
              o.set("linkHref", t),
                s.forEach((t) => {
                  o.set(t, !0);
                });
              const { end: r } = n.insertContent(e.createText(t, o), c);
              e.setSelection(r);
            }
            ["linkHref", ...s, ...r].forEach((t) => {
              e.removeSelectionAttribute(t);
            });
          } else {
            const o = n.schema.getValidRanges(i.getRanges(), "linkHref"),
              a = [];
            for (const t of i.getSelectedBlocks())
              n.schema.checkAttribute(t, "linkHref") &&
                a.push(e.createRangeOn(t));
            const c = a.slice();
            for (const t of o) this._isRangeToUpdate(t, a) && c.push(t);
            for (const n of c)
              e.setAttribute("linkHref", t, n),
                s.forEach((t) => {
                  e.setAttribute(t, !0, n);
                }),
                r.forEach((t) => {
                  e.removeAttribute(t, n);
                });
          }
        });
      }
      _getDecoratorStateFromModel(t) {
        const e = this.editor.model,
          n = e.document.selection,
          i = n.getSelectedElement();
        return Object(l.g)(i, e.schema) ? i.getAttribute(t) : n.getAttribute(t);
      }
      _isRangeToUpdate(t, e) {
        for (const n of e) if (n.containsRange(t)) return !1;
        return !0;
      }
    }
    class d extends i.a {
      refresh() {
        const t = this.editor.model,
          e = t.document.selection,
          n = e.getSelectedElement();
        Object(l.g)(n, t.schema)
          ? (this.isEnabled = t.schema.checkAttribute(n, "linkHref"))
          : (this.isEnabled = t.schema.checkAttributeInSelection(
              e,
              "linkHref"
            ));
      }
      execute() {
        const t = this.editor,
          e = this.editor.model,
          n = e.document.selection,
          i = t.commands.get("link");
        e.change((t) => {
          const s = n.isCollapsed
            ? [
                Object(o.f)(
                  n.getFirstPosition(),
                  "linkHref",
                  n.getAttribute("linkHref"),
                  e
                ),
              ]
            : e.schema.getValidRanges(n.getRanges(), "linkHref");
          for (const e of s)
            if ((t.removeAttribute("linkHref", e), i))
              for (const n of i.manualDecorators) t.removeAttribute(n.id, e);
        });
      }
    }
    class h {
      constructor({
        id: t,
        label: e,
        attributes: n,
        classes: i,
        styles: s,
        defaultValue: o,
      }) {
        (this.id = t),
          this.set("value"),
          (this.defaultValue = o),
          (this.label = e),
          (this.attributes = n),
          (this.classes = i),
          (this.styles = s);
      }
      _createPattern() {
        return {
          attributes: this.attributes,
          classes: this.classes,
          styles: this.styles,
        };
      }
    }
    Object(a.v)(h, a.h);
    n(368);
    const f = /^(https?:)?\/\//;
    class m extends i.j {
      static get pluginName() {
        return "LinkEditing";
      }
      static get requires() {
        return [o.d, o.b, r.b];
      }
      constructor(t) {
        super(t), t.config.define("link", { addTargetToExternalLinks: !1 });
      }
      init() {
        const t = this.editor;
        t.model.schema.extend("$text", { allowAttributes: "linkHref" }),
          t.conversion
            .for("dataDowncast")
            .attributeToElement({ model: "linkHref", view: l.c }),
          t.conversion.for("editingDowncast").attributeToElement({
            model: "linkHref",
            view: (t, e) => Object(l.c)(Object(l.d)(t), e),
          }),
          t.conversion.for("upcast").elementToAttribute({
            view: { name: "a", attributes: { href: !0 } },
            model: { key: "linkHref", value: (t) => t.getAttribute("href") },
          }),
          t.commands.add("link", new u(t)),
          t.commands.add("unlink", new d(t));
        const e = Object(l.e)(
          t.t,
          Object(l.h)(t.config.get("link.decorators"))
        );
        this._enableAutomaticDecorators(
          e.filter((t) => "automatic" === t.mode)
        ),
          this._enableManualDecorators(e.filter((t) => "manual" === t.mode));
        t.plugins.get(o.d).registerAttribute("linkHref"),
          Object(o.h)(t, "linkHref", "a", "ck-link_selected"),
          this._enableLinkOpen(),
          this._enableInsertContentSelectionAttributesFixer(),
          this._enableClickingAfterLink(),
          this._enableTypingOverLink(),
          this._handleDeleteContentAfterLink();
      }
      _enableAutomaticDecorators(t) {
        const e = this.editor,
          n = e.commands.get("link").automaticDecorators;
        e.config.get("link.addTargetToExternalLinks") &&
          n.add({
            id: "linkIsExternal",
            mode: "automatic",
            callback: (t) => f.test(t),
            attributes: { target: "_blank", rel: "noopener noreferrer" },
          }),
          n.add(t),
          n.length && e.conversion.for("downcast").add(n.getDispatcher());
      }
      _enableManualDecorators(t) {
        if (!t.length) return;
        const e = this.editor,
          n = e.commands.get("link").manualDecorators;
        t.forEach((t) => {
          e.model.schema.extend("$text", { allowAttributes: t.id }),
            (t = new h(t)),
            n.add(t),
            e.conversion.for("downcast").attributeToElement({
              model: t.id,
              view: (e, { writer: n }) => {
                if (e) {
                  const e = n.createAttributeElement("a", t.attributes, {
                    priority: 5,
                  });
                  t.classes && n.addClass(t.classes, e);
                  for (const i in t.styles) n.setStyle(i, t.styles[i], e);
                  return n.setCustomProperty("link", !0, e), e;
                }
              },
            }),
            e.conversion.for("upcast").elementToAttribute({
              view: { name: "a", ...t._createPattern() },
              model: { key: t.id },
            });
        });
      }
      _enableLinkOpen() {
        const t = this.editor,
          e = t.editing.view.document,
          n = t.model.document;
        this.listenTo(
          e,
          "click",
          (t, e) => {
            if (!(a.m.isMac ? e.domEvent.metaKey : e.domEvent.ctrlKey)) return;
            let n = e.domTarget;
            if (("a" != n.tagName.toLowerCase() && (n = n.closest("a")), !n))
              return;
            const i = n.getAttribute("href");
            i && (t.stop(), e.preventDefault(), Object(l.i)(i));
          },
          { context: "$capture" }
        ),
          this.listenTo(
            e,
            "enter",
            (t, e) => {
              const i = n.selection,
                s = i.getSelectedElement(),
                o = s ? s.getAttribute("linkHref") : i.getAttribute("linkHref");
              o && e.domEvent.altKey && (t.stop(), Object(l.i)(o));
            },
            { context: "a" }
          );
      }
      _enableInsertContentSelectionAttributesFixer() {
        const t = this.editor.model,
          e = t.document.selection;
        this.listenTo(
          t,
          "insertContent",
          () => {
            const n = e.anchor.nodeBefore,
              i = e.anchor.nodeAfter;
            e.hasAttribute("linkHref") &&
              n &&
              n.hasAttribute("linkHref") &&
              ((i && i.hasAttribute("linkHref")) ||
                t.change((e) => {
                  g(e, b(t.schema));
                }));
          },
          { priority: "low" }
        );
      }
      _enableClickingAfterLink() {
        const t = this.editor,
          e = t.model;
        t.editing.view.addObserver(s.l);
        let n = !1;
        this.listenTo(t.editing.view.document, "mousedown", () => {
          n = !0;
        }),
          this.listenTo(t.editing.view.document, "selectionChange", () => {
            if (!n) return;
            n = !1;
            const t = e.document.selection;
            if (!t.isCollapsed) return;
            if (!t.hasAttribute("linkHref")) return;
            const i = t.getFirstPosition(),
              s = Object(o.f)(i, "linkHref", t.getAttribute("linkHref"), e);
            (i.isTouching(s.start) || i.isTouching(s.end)) &&
              e.change((t) => {
                g(t, b(e.schema));
              });
          });
      }
      _enableTypingOverLink() {
        const t = this.editor,
          e = t.editing.view;
        let n, i;
        this.listenTo(
          e.document,
          "delete",
          () => {
            i = !0;
          },
          { priority: "high" }
        ),
          this.listenTo(
            t.model,
            "deleteContent",
            () => {
              const e = t.model.document.selection;
              e.isCollapsed ||
                (i
                  ? (i = !1)
                  : p(t) &&
                    (function (t) {
                      const e = t.document.selection,
                        n = e.getFirstPosition(),
                        i = e.getLastPosition(),
                        s = n.nodeAfter;
                      if (!s) return !1;
                      if (!s.is("$text")) return !1;
                      if (!s.hasAttribute("linkHref")) return !1;
                      const r = i.textNode || i.nodeBefore;
                      if (s === r) return !0;
                      return Object(o.f)(
                        n,
                        "linkHref",
                        s.getAttribute("linkHref"),
                        t
                      ).containsRange(t.createRange(n, i), !0);
                    })(t.model) &&
                    (n = e.getAttributes()));
            },
            { priority: "high" }
          ),
          this.listenTo(
            t.model,
            "insertContent",
            (e, [s]) => {
              (i = !1),
                p(t) &&
                  n &&
                  (t.model.change((t) => {
                    for (const [e, i] of n) t.setAttribute(e, i, s);
                  }),
                  (n = null));
            },
            { priority: "high" }
          );
      }
      _handleDeleteContentAfterLink() {
        const t = this.editor,
          e = t.model,
          n = e.document.selection,
          i = t.editing.view;
        let s = !1,
          r = !1;
        this.listenTo(
          i.document,
          "delete",
          (t, e) => {
            r = e.domEvent.keyCode === a.t.backspace;
          },
          { priority: "high" }
        ),
          this.listenTo(
            e,
            "deleteContent",
            () => {
              s = !1;
              const t = n.getFirstPosition(),
                i = n.getAttribute("linkHref");
              if (!i) return;
              const r = Object(o.f)(t, "linkHref", i, e);
              s = r.containsPosition(t) || r.end.isEqual(t);
            },
            { priority: "high" }
          ),
          this.listenTo(
            e,
            "deleteContent",
            () => {
              r &&
                ((r = !1),
                s ||
                  t.model.enqueueChange((t) => {
                    g(t, b(e.schema));
                  }));
            },
            { priority: "low" }
          );
      }
    }
    function g(t, e) {
      t.removeSelectionAttribute("linkHref");
      for (const n of e) t.removeSelectionAttribute(n);
    }
    function p(t) {
      return t.plugins.get("Input").isInput(t.model.change((t) => t.batch));
    }
    function b(t) {
      return t
        .getDefinition("$text")
        .allowAttributes.filter((t) => t.startsWith("link"));
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(1),
      s = n(19),
      o = n(239);
    class r extends i.j {
      static get requires() {
        return [s.c];
      }
      static get pluginName() {
        return "TableToolbar";
      }
      afterInit() {
        const t = this.editor,
          e = t.t,
          n = t.plugins.get(s.c),
          i = t.config.get("table.contentToolbar"),
          r = t.config.get("table.tableToolbar");
        i &&
          n.register("tableContent", {
            ariaLabel: e("Table toolbar"),
            items: i,
            getRelatedElement: o.b,
          }),
          r &&
            n.register("table", {
              ariaLabel: e("Table toolbar"),
              items: r,
              getRelatedElement: o.a,
            });
      }
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(2);
    const s = { autoRefresh: !0 };
    class o {
      constructor(t, e = s) {
        if (!t) throw new i.a("token-missing-token-url", this);
        e.initValue && this._validateTokenValue(e.initValue),
          this.set("value", e.initValue),
          (this._refresh =
            "function" == typeof t
              ? t
              : () => {
                  return (
                    (e = t),
                    new Promise((t, n) => {
                      const s = new XMLHttpRequest();
                      s.open("GET", e),
                        s.addEventListener("load", () => {
                          const e = s.status,
                            o = s.response;
                          return e < 200 || e > 299
                            ? n(
                                new i.a("token-cannot-download-new-token", null)
                              )
                            : t(o);
                        }),
                        s.addEventListener("error", () =>
                          n(new Error("Network Error"))
                        ),
                        s.addEventListener("abort", () =>
                          n(new Error("Abort"))
                        ),
                        s.send();
                    })
                  );
                  var e;
                }),
          (this._options = Object.assign({}, s, e));
      }
      init() {
        return new Promise((t, e) => {
          this.value
            ? (this._options.autoRefresh && this._registerRefreshTokenTimeout(),
              t(this))
            : this.refreshToken().then(t).catch(e);
        });
      }
      refreshToken() {
        return this._refresh()
          .then((t) => {
            this._validateTokenValue(t),
              this.set("value", t),
              this._options.autoRefresh && this._registerRefreshTokenTimeout();
          })
          .then(() => this);
      }
      destroy() {
        clearTimeout(this._tokenRefreshTimeout);
      }
      _validateTokenValue(t) {
        const e = "string" == typeof t,
          n = !/^".*"$/.test(t),
          s = e && 3 === t.split(".").length;
        if (!n || !s) throw new i.a("token-not-in-jwt-format", this);
      }
      _registerRefreshTokenTimeout() {
        const t = this._getTokenRefreshTimeoutTime();
        clearTimeout(this._tokenRefreshTimeout),
          (this._tokenRefreshTimeout = setTimeout(() => {
            this.refreshToken();
          }, t));
      }
      _getTokenRefreshTimeoutTime() {
        try {
          const [, t] = this.value.split("."),
            { exp: e } = JSON.parse(atob(t));
          if (!e) return 36e5;
          return Math.floor((1e3 * e - Date.now()) / 2);
        } catch (t) {
          return 36e5;
        }
      }
      static create(t, e = s) {
        return new o(t, e).init();
      }
    }
    Object(i.v)(o, i.h), (e.a = o);
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(1),
      s = n(302),
      o = n(315),
      r = n(317);
    class a extends i.j {
      static get requires() {
        return [s.a, o.a, r.a];
      }
      static get pluginName() {
        return "Link";
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return C;
    });
    var i = n(1),
      s = n(19);
    class o extends i.a {
      refresh() {
        const t = this.editor.plugins
          .get("ImageUtils")
          .getClosestSelectedImageElement(this.editor.model.document.selection);
        (this.isEnabled = !!t),
          this.isEnabled && t.hasAttribute("alt")
            ? (this.value = t.getAttribute("alt"))
            : (this.value = !1);
      }
      execute(t) {
        const e = this.editor,
          n = e.plugins.get("ImageUtils"),
          i = e.model,
          s = n.getClosestSelectedImageElement(i.document.selection);
        i.change((e) => {
          e.setAttribute("alt", t.newValue, s);
        });
      }
    }
    var r = n(54);
    class a extends i.j {
      static get requires() {
        return [r.a];
      }
      static get pluginName() {
        return "ImageTextAlternativeEditing";
      }
      init() {
        this.editor.commands.add("imageTextAlternative", new o(this.editor));
      }
    }
    var c = n(4),
      l = n(2);
    n(364), n(240);
    class u extends c.D {
      constructor(t) {
        super(t);
        const e = this.locale.t;
        (this.focusTracker = new l.f()),
          (this.keystrokes = new l.g()),
          (this.labeledInput = this._createLabeledInputView()),
          (this.saveButtonView = this._createButton(
            e("Save"),
            i.l.check,
            "ck-button-save"
          )),
          (this.saveButtonView.type = "submit"),
          (this.cancelButtonView = this._createButton(
            e("Cancel"),
            i.l.cancel,
            "ck-button-cancel",
            "cancel"
          )),
          (this._focusables = new c.E()),
          (this._focusCycler = new c.k({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          })),
          this.setTemplate({
            tag: "form",
            attributes: {
              class: ["ck", "ck-text-alternative-form", "ck-responsive-form"],
              tabindex: "-1",
            },
            children: [
              this.labeledInput,
              this.saveButtonView,
              this.cancelButtonView,
            ],
          }),
          Object(c.N)(this);
      }
      render() {
        super.render(),
          this.keystrokes.listenTo(this.element),
          Object(c.Q)({ view: this }),
          [
            this.labeledInput,
            this.saveButtonView,
            this.cancelButtonView,
          ].forEach((t) => {
            this._focusables.add(t), this.focusTracker.add(t.element);
          });
      }
      destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
      }
      _createButton(t, e, n, i) {
        const s = new c.e(this.locale);
        return (
          s.set({ label: t, icon: e, tooltip: !0 }),
          s.extendTemplate({ attributes: { class: n } }),
          i && s.delegate("execute").to(this, i),
          s
        );
      }
      _createLabeledInputView() {
        const t = this.locale.t,
          e = new c.r(this.locale, c.K);
        return (e.label = t("Text alternative")), e;
      }
    }
    function d(t) {
      const e = t.editing.view,
        n = c.a.defaultPositions,
        i = t.plugins.get("ImageUtils");
      return {
        target: e.domConverter.viewToDom(
          i.getClosestSelectedImageWidget(e.document.selection)
        ),
        positions: [
          n.northArrowSouth,
          n.northArrowSouthWest,
          n.northArrowSouthEast,
          n.southArrowNorth,
          n.southArrowNorthWest,
          n.southArrowNorthEast,
          n.viewportStickyNorth,
        ],
      };
    }
    class h extends i.j {
      static get requires() {
        return [c.h];
      }
      static get pluginName() {
        return "ImageTextAlternativeUI";
      }
      init() {
        this._createButton(), this._createForm();
      }
      destroy() {
        super.destroy(), this._form.destroy();
      }
      _createButton() {
        const t = this.editor,
          e = t.t;
        t.ui.componentFactory.add("imageTextAlternative", (n) => {
          const s = t.commands.get("imageTextAlternative"),
            o = new c.e(n);
          return (
            o.set({
              label: e("Change image text alternative"),
              icon: i.l.lowVision,
              tooltip: !0,
            }),
            o.bind("isEnabled").to(s, "isEnabled"),
            this.listenTo(o, "execute", () => {
              this._showForm();
            }),
            o
          );
        });
      }
      _createForm() {
        const t = this.editor,
          e = t.editing.view.document,
          n = t.plugins.get("ImageUtils");
        (this._balloon = this.editor.plugins.get("ContextualBalloon")),
          (this._form = new u(t.locale)),
          this._form.render(),
          this.listenTo(this._form, "submit", () => {
            t.execute("imageTextAlternative", {
              newValue: this._form.labeledInput.fieldView.element.value,
            }),
              this._hideForm(!0);
          }),
          this.listenTo(this._form, "cancel", () => {
            this._hideForm(!0);
          }),
          this._form.keystrokes.set("Esc", (t, e) => {
            this._hideForm(!0), e();
          }),
          this.listenTo(t.ui, "update", () => {
            n.getClosestSelectedImageWidget(e.selection)
              ? this._isVisible &&
                (function (t) {
                  const e = t.plugins.get("ContextualBalloon");
                  if (
                    t.plugins
                      .get("ImageUtils")
                      .getClosestSelectedImageWidget(
                        t.editing.view.document.selection
                      )
                  ) {
                    const n = d(t);
                    e.updatePosition(n);
                  }
                })(t)
              : this._hideForm(!0);
          }),
          Object(c.H)({
            emitter: this._form,
            activator: () => this._isVisible,
            contextElements: [this._balloon.view.element],
            callback: () => this._hideForm(),
          });
      }
      _showForm() {
        if (this._isVisible) return;
        const t = this.editor,
          e = t.commands.get("imageTextAlternative"),
          n = this._form.labeledInput;
        this._form.disableCssTransitions(),
          this._isInBalloon ||
            this._balloon.add({ view: this._form, position: d(t) }),
          (n.fieldView.value = n.fieldView.element.value = e.value || ""),
          this._form.labeledInput.fieldView.select(),
          this._form.enableCssTransitions();
      }
      _hideForm(t) {
        this._isInBalloon &&
          (this._form.focusTracker.isFocused &&
            this._form.saveButtonView.focus(),
          this._balloon.remove(this._form),
          t && this.editor.editing.view.focus());
      }
      get _isVisible() {
        return this._balloon.visibleView === this._form;
      }
      get _isInBalloon() {
        return this._balloon.hasView(this._form);
      }
    }
    class f extends i.j {
      static get requires() {
        return [a, h];
      }
      static get pluginName() {
        return "ImageTextAlternative";
      }
    }
    var m = n(244);
    n(249);
    class g extends i.j {
      static get requires() {
        return [m.a, s.a, f];
      }
      static get pluginName() {
        return "ImageBlock";
      }
    }
    var p = n(77),
      b = n(13),
      w = n(108),
      v = n(243),
      _ = n(242),
      y = n(85);
    class k extends i.j {
      static get requires() {
        return [v.a, r.a, p.b];
      }
      static get pluginName() {
        return "ImageInlineEditing";
      }
      init() {
        const t = this.editor,
          e = t.model.schema;
        e.register("imageInline", {
          isObject: !0,
          isInline: !0,
          allowWhere: "$text",
          allowAttributesOf: "$text",
          allowAttributes: ["alt", "src", "srcset"],
        }),
          e.addChildCheck((t, e) => {
            if (t.endsWith("caption") && "imageInline" === e.name) return !1;
          }),
          this._setupConversion(),
          t.plugins.has("ImageBlockEditing") &&
            (t.commands.add(
              "imageTypeInline",
              new _.a(this.editor, "imageInline")
            ),
            this._setupClipboardIntegration());
      }
      _setupConversion() {
        const t = this.editor,
          e = t.t,
          n = t.conversion,
          i = t.plugins.get("ImageUtils");
        n.for("dataDowncast").elementToElement({
          model: "imageInline",
          view: (t, { writer: e }) => e.createEmptyElement("img"),
        }),
          n.for("editingDowncast").elementToElement({
            model: "imageInline",
            view: (t, { writer: n }) =>
              i.toImageWidget(
                Object(y.a)(n, "imageInline"),
                n,
                e("image widget")
              ),
          }),
          n
            .for("downcast")
            .add(Object(w.a)(i, "imageInline", "src"))
            .add(Object(w.a)(i, "imageInline", "alt"))
            .add(Object(w.b)(i, "imageInline")),
          n.for("upcast").elementToElement({
            view: Object(y.c)(t, "imageInline"),
            model: (t, { writer: e }) =>
              e.createElement(
                "imageInline",
                t.hasAttribute("src") ? { src: t.getAttribute("src") } : null
              ),
          });
      }
      _setupClipboardIntegration() {
        const t = this.editor,
          e = t.model,
          n = t.editing.view,
          i = t.plugins.get("ImageUtils");
        this.listenTo(
          t.plugins.get("ClipboardPipeline"),
          "inputTransformation",
          (s, o) => {
            const r = Array.from(o.content.getChildren());
            let a;
            if (!r.every(i.isBlockImageView)) return;
            a = o.targetRanges
              ? t.editing.mapper.toModelRange(o.targetRanges[0])
              : e.document.selection.getFirstRange();
            const c = e.createSelection(a);
            if ("imageInline" === Object(y.b)(e.schema, c)) {
              const t = new b.q(n.document),
                e = r.map((e) =>
                  1 === e.childCount
                    ? (Array.from(e.getAttributes()).forEach((n) =>
                        t.setAttribute(...n, i.findViewImgElement(e))
                      ),
                      e.getChild(0))
                    : e
                );
              o.content = t.createDocumentFragment(e);
            }
          }
        );
      }
    }
    class A extends i.j {
      static get requires() {
        return [k, s.a, f];
      }
      static get pluginName() {
        return "ImageInline";
      }
    }
    class C extends i.j {
      static get requires() {
        return [g, A];
      }
      static get pluginName() {
        return "Image";
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return A;
    });
    var i = n(1),
      s = n(66),
      o = n(2);
    function r(t) {
      const e = t.map((t) => t.replace("+", "\\+"));
      return new RegExp(`^image\\/(${e.join("|")})$`);
    }
    function a(t) {
      return new Promise((e, n) => {
        const i = t.getAttribute("src");
        fetch(i)
          .then((t) => t.blob())
          .then((t) => {
            const n = c(t, i),
              s = n.replace("image/", ""),
              o = new File([t], "image." + s, { type: n });
            e(o);
          })
          .catch((t) =>
            t && "TypeError" === t.name
              ? (function (t) {
                  return (function (t) {
                    return new Promise((e, n) => {
                      const i = o.s.document.createElement("img");
                      i.addEventListener("load", () => {
                        const t = o.s.document.createElement("canvas");
                        (t.width = i.width), (t.height = i.height);
                        t.getContext("2d").drawImage(i, 0, 0),
                          t.toBlob((t) => (t ? e(t) : n()));
                      }),
                        i.addEventListener("error", () => n()),
                        (i.src = t);
                    });
                  })(t).then((e) => {
                    const n = c(e, t),
                      i = n.replace("image/", "");
                    return new File([e], "image." + i, { type: n });
                  });
                })(i)
                  .then(e)
                  .catch(n)
              : n(t)
          );
      });
    }
    function c(t, e) {
      return t.type
        ? t.type
        : e.match(/data:(image\/\w+);base64/)
        ? e.match(/data:(image\/\w+);base64/)[1].toLowerCase()
        : "image/jpeg";
    }
    class l extends i.j {
      static get pluginName() {
        return "ImageUploadUI";
      }
      init() {
        const t = this.editor,
          e = t.t,
          n = (n) => {
            const o = new s.a(n),
              a = t.commands.get("uploadImage"),
              c = t.config.get("image.upload.types"),
              l = r(c);
            return (
              o.set({
                acceptedType: c.map((t) => "image/" + t).join(","),
                allowMultipleFiles: !0,
              }),
              o.buttonView.set({
                label: e("Insert image"),
                icon: i.l.image,
                tooltip: !0,
              }),
              o.buttonView.bind("isEnabled").to(a),
              o.on("done", (e, n) => {
                const i = Array.from(n).filter((t) => l.test(t.type));
                i.length && t.execute("uploadImage", { file: i });
              }),
              o
            );
          };
        t.ui.componentFactory.add("uploadImage", n),
          t.ui.componentFactory.add("imageUpload", n);
      }
    }
    n(365), n(366), n(367);
    class u extends i.j {
      static get pluginName() {
        return "ImageUploadProgress";
      }
      constructor(t) {
        super(t),
          (this.placeholder =
            "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==");
      }
      init() {
        const t = this.editor;
        t.plugins.has("ImageBlockEditing") &&
          t.editing.downcastDispatcher.on(
            "attribute:uploadStatus:imageBlock",
            (...t) => this.uploadStatusChange(...t)
          ),
          t.plugins.has("ImageInlineEditing") &&
            t.editing.downcastDispatcher.on(
              "attribute:uploadStatus:imageInline",
              (...t) => this.uploadStatusChange(...t)
            );
      }
      uploadStatusChange(t, e, n) {
        const i = this.editor,
          o = e.item,
          r = o.getAttribute("uploadId");
        if (!n.consumable.consume(e.item, t.name)) return;
        const a = i.plugins.get("ImageUtils"),
          c = i.plugins.get(s.b),
          l = r ? e.attributeNewValue : null,
          u = this.placeholder,
          m = i.editing.mapper.toViewElement(o),
          p = n.writer;
        if ("reading" == l) return d(m, p), void h(a, u, m, p);
        if ("uploading" == l) {
          const t = c.loaders.get(r);
          return (
            d(m, p),
            void (t
              ? (f(m, p),
                (function (t, e, n, i) {
                  const s = (function (t) {
                    const e = t.createUIElement("div", {
                      class: "ck-progress-bar",
                    });
                    return t.setCustomProperty("progressBar", !0, e), e;
                  })(e);
                  e.insert(e.createPositionAt(t, "end"), s),
                    n.on("change:uploadedPercent", (t, e, n) => {
                      i.change((t) => {
                        t.setStyle("width", n + "%", s);
                      });
                    });
                })(m, p, t, i.editing.view),
                (function (t, e, n, i) {
                  if (i.data) {
                    const s = t.findViewImgElement(e);
                    n.setAttribute("src", i.data, s);
                  }
                })(a, m, p, t))
              : h(a, u, m, p))
          );
        }
        "complete" == l &&
          c.loaders.get(r) &&
          (function (t, e, n) {
            const i = e.createUIElement("div", {
              class: "ck-image-upload-complete-icon",
            });
            e.insert(e.createPositionAt(t, "end"), i),
              setTimeout(() => {
                n.change((t) => t.remove(t.createRangeOn(i)));
              }, 3e3);
          })(m, p, i.editing.view),
          (function (t, e) {
            g(t, e, "progressBar");
          })(m, p),
          f(m, p),
          (function (t, e) {
            e.removeClass("ck-appear", t);
          })(m, p);
      }
    }
    function d(t, e) {
      t.hasClass("ck-appear") || e.addClass("ck-appear", t);
    }
    function h(t, e, n, i) {
      n.hasClass("ck-image-upload-placeholder") ||
        i.addClass("ck-image-upload-placeholder", n);
      const s = t.findViewImgElement(n);
      s.getAttribute("src") !== e && i.setAttribute("src", e, s),
        m(n, "placeholder") ||
          i.insert(
            i.createPositionAfter(s),
            (function (t) {
              const e = t.createUIElement("div", {
                class: "ck-upload-placeholder-loader",
              });
              return t.setCustomProperty("placeholder", !0, e), e;
            })(i)
          );
    }
    function f(t, e) {
      t.hasClass("ck-image-upload-placeholder") &&
        e.removeClass("ck-image-upload-placeholder", t),
        g(t, e, "placeholder");
    }
    function m(t, e) {
      for (const n of t.getChildren()) if (n.getCustomProperty(e)) return n;
    }
    function g(t, e, n) {
      const i = m(t, n);
      i && e.remove(e.createRangeOn(i));
    }
    var p = n(13),
      b = n(4),
      w = n(77),
      v = n(54);
    class _ extends i.a {
      refresh() {
        const t = this.editor,
          e = t.plugins.get("ImageUtils"),
          n = t.model.document.selection.getSelectedElement();
        this.isEnabled = e.isImageAllowed() || e.isImage(n);
      }
      execute(t) {
        const e = Object(o.z)(t.file),
          n = this.editor.model.document.selection,
          i = this.editor.plugins.get("ImageUtils"),
          s = Object.fromEntries(n.getAttributes());
        e.forEach((t, e) => {
          const o = n.getSelectedElement();
          if (e && o && i.isImage(o)) {
            const e = this.editor.model.createPositionAfter(o);
            this._uploadImage(t, s, e);
          } else this._uploadImage(t, s);
        });
      }
      _uploadImage(t, e, n) {
        const i = this.editor,
          o = i.plugins.get(s.b).createLoader(t),
          r = i.plugins.get("ImageUtils");
        o && r.insertImage({ ...e, uploadId: o.id }, n);
      }
    }
    class y extends i.j {
      static get requires() {
        return [s.b, b.v, w.b, v.a];
      }
      static get pluginName() {
        return "ImageUploadEditing";
      }
      constructor(t) {
        super(t),
          t.config.define("image", {
            upload: { types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"] },
          }),
          (this._uploadImageElements = new Map());
      }
      init() {
        const t = this.editor,
          e = t.model.document,
          n = t.conversion,
          i = t.plugins.get(s.b),
          o = t.plugins.get("ImageUtils"),
          c = r(t.config.get("image.upload.types")),
          l = new _(t);
        t.commands.add("uploadImage", l),
          t.commands.add("imageUpload", l),
          n.for("upcast").attributeToAttribute({
            view: { name: "img", key: "uploadId" },
            model: "uploadId",
          }),
          this.listenTo(t.editing.view.document, "clipboardInput", (e, n) => {
            if (
              ((i = n.dataTransfer),
              Array.from(i.types).includes("text/html") &&
                "" !== i.getData("text/html"))
            )
              return;
            var i;
            const s = Array.from(n.dataTransfer.files).filter(
              (t) => !!t && c.test(t.type)
            );
            s.length &&
              (e.stop(),
              t.model.change((e) => {
                n.targetRanges &&
                  e.setSelection(
                    n.targetRanges.map((e) => t.editing.mapper.toModelRange(e))
                  ),
                  t.model.enqueueChange("default", () => {
                    t.execute("uploadImage", { file: s });
                  });
              }));
          }),
          this.listenTo(
            t.plugins.get("ClipboardPipeline"),
            "inputTransformation",
            (e, n) => {
              const s = Array.from(t.editing.view.createRangeIn(n.content))
                .filter(
                  (t) =>
                    (function (t, e) {
                      return (
                        !(!t.isInlineImageView(e) || !e.getAttribute("src")) &&
                        (e
                          .getAttribute("src")
                          .match(/^data:image\/\w+;base64,/g) ||
                          e.getAttribute("src").match(/^blob:/g))
                      );
                    })(o, t.item) && !t.item.getAttribute("uploadProcessed")
                )
                .map((t) => ({ promise: a(t.item), imageElement: t.item }));
              if (!s.length) return;
              const r = new p.q(t.editing.view.document);
              for (const t of s) {
                r.setAttribute("uploadProcessed", !0, t.imageElement);
                const e = i.createLoader(t.promise);
                e &&
                  (r.setAttribute("src", "", t.imageElement),
                  r.setAttribute("uploadId", e.id, t.imageElement));
              }
            }
          ),
          t.editing.view.document.on("dragover", (t, e) => {
            e.preventDefault();
          }),
          e.on("change", () => {
            const n = e.differ
                .getChanges({ includeChangesInGraveyard: !0 })
                .reverse(),
              s = new Set();
            for (const e of n)
              if ("insert" == e.type && "$text" != e.name) {
                const n = e.position.nodeAfter,
                  o = "$graveyard" == e.position.root.rootName;
                for (const e of k(t, n)) {
                  const t = e.getAttribute("uploadId");
                  if (!t) continue;
                  const n = i.loaders.get(t);
                  n &&
                    (o
                      ? s.has(t) || n.abort()
                      : (s.add(t),
                        this._uploadImageElements.set(t, e),
                        "idle" == n.status && this._readAndUpload(n)));
                }
              }
          }),
          this.on(
            "uploadComplete",
            (t, { imageElement: e, data: n }) => {
              const i = n.urls ? n.urls : n;
              this.editor.model.change((t) => {
                t.setAttribute("src", i.default, e),
                  this._parseAndSetSrcsetAttributeOnImage(i, e, t);
              });
            },
            { priority: "low" }
          );
      }
      afterInit() {
        const t = this.editor.model.schema;
        this.editor.plugins.has("ImageBlockEditing") &&
          t.extend("imageBlock", {
            allowAttributes: ["uploadId", "uploadStatus"],
          }),
          this.editor.plugins.has("ImageInlineEditing") &&
            t.extend("imageInline", {
              allowAttributes: ["uploadId", "uploadStatus"],
            });
      }
      _readAndUpload(t) {
        const e = this.editor,
          n = e.model,
          i = e.locale.t,
          r = e.plugins.get(s.b),
          a = e.plugins.get(b.v),
          c = e.plugins.get("ImageUtils"),
          l = this._uploadImageElements;
        return (
          n.enqueueChange("transparent", (e) => {
            e.setAttribute("uploadStatus", "reading", l.get(t.id));
          }),
          t
            .read()
            .then(() => {
              const i = t.upload(),
                s = l.get(t.id);
              if (o.m.isSafari) {
                const t = e.editing.mapper.toViewElement(s),
                  n = c.findViewImgElement(t);
                e.editing.view.once("render", () => {
                  if (!n.parent) return;
                  const t = e.editing.view.domConverter.mapViewToDom(n.parent);
                  if (!t) return;
                  const i = t.style.display;
                  (t.style.display = "none"),
                    (t._ckHack = t.offsetHeight),
                    (t.style.display = i);
                });
              }
              return (
                n.enqueueChange("transparent", (t) => {
                  t.setAttribute("uploadStatus", "uploading", s);
                }),
                i
              );
            })
            .then((e) => {
              n.enqueueChange("transparent", (n) => {
                const i = l.get(t.id);
                n.setAttribute("uploadStatus", "complete", i),
                  this.fire("uploadComplete", { data: e, imageElement: i });
              }),
                u();
            })
            .catch((e) => {
              if ("error" !== t.status && "aborted" !== t.status) throw e;
              "error" == t.status &&
                e &&
                a.showWarning(e, {
                  title: i("Upload failed"),
                  namespace: "upload",
                }),
                n.enqueueChange("transparent", (e) => {
                  e.remove(l.get(t.id));
                }),
                u();
            })
        );
        function u() {
          n.enqueueChange("transparent", (e) => {
            const n = l.get(t.id);
            e.removeAttribute("uploadId", n),
              e.removeAttribute("uploadStatus", n),
              l.delete(t.id);
          }),
            r.destroyLoader(t);
        }
      }
      _parseAndSetSrcsetAttributeOnImage(t, e, n) {
        let i = 0;
        const s = Object.keys(t)
          .filter((t) => {
            const e = parseInt(t, 10);
            if (!isNaN(e)) return (i = Math.max(i, e)), !0;
          })
          .map((e) => `${t[e]} ${e}w`)
          .join(", ");
        "" != s && n.setAttribute("srcset", { data: s, width: i }, e);
      }
    }
    function k(t, e) {
      const n = t.plugins.get("ImageUtils");
      return Array.from(t.model.createRangeOn(e))
        .filter((t) => n.isImage(t.item))
        .map((t) => t.item);
    }
    class A extends i.j {
      static get pluginName() {
        return "ImageUpload";
      }
      static get requires() {
        return [y, l, u];
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return m;
    });
    var i = n(1),
      s = n(130),
      o = n(33),
      r = n(2);
    class a extends i.a {
      refresh() {
        (this.value = this._getValue()),
          (this.isEnabled = this._checkEnabled());
      }
      execute(t = {}) {
        const e = this.editor.model,
          n = e.schema,
          i = e.document.selection,
          s = Array.from(i.getSelectedBlocks()),
          o = void 0 === t.forceValue ? !this.value : t.forceValue;
        e.change((t) => {
          if (o) {
            const e = s.filter((t) => c(t) || u(n, t));
            this._applyQuote(t, e);
          } else this._removeQuote(t, s.filter(c));
        });
      }
      _getValue() {
        const t = this.editor.model.document.selection,
          e = Object(r.n)(t.getSelectedBlocks());
        return !(!e || !c(e));
      }
      _checkEnabled() {
        if (this.value) return !0;
        const t = this.editor.model.document.selection,
          e = this.editor.model.schema,
          n = Object(r.n)(t.getSelectedBlocks());
        return !!n && u(e, n);
      }
      _removeQuote(t, e) {
        l(t, e)
          .reverse()
          .forEach((e) => {
            if (e.start.isAtStart && e.end.isAtEnd)
              return void t.unwrap(e.start.parent);
            if (e.start.isAtStart) {
              const n = t.createPositionBefore(e.start.parent);
              return void t.move(e, n);
            }
            e.end.isAtEnd || t.split(e.end);
            const n = t.createPositionAfter(e.end.parent);
            t.move(e, n);
          });
      }
      _applyQuote(t, e) {
        const n = [];
        l(t, e)
          .reverse()
          .forEach((e) => {
            let i = c(e.start);
            i || ((i = t.createElement("blockQuote")), t.wrap(e, i)), n.push(i);
          }),
          n
            .reverse()
            .reduce((e, n) =>
              e.nextSibling == n ? (t.merge(t.createPositionAfter(e)), e) : n
            );
      }
    }
    function c(t) {
      return "blockQuote" == t.parent.name ? t.parent : null;
    }
    function l(t, e) {
      let n,
        i = 0;
      const s = [];
      for (; i < e.length; ) {
        const o = e[i],
          r = e[i + 1];
        n || (n = t.createPositionBefore(o)),
          (r && o.nextSibling == r) ||
            (s.push(t.createRange(n, t.createPositionAfter(o))), (n = null)),
          i++;
      }
      return s;
    }
    function u(t, e) {
      const n = t.checkChild(e.parent, "blockQuote"),
        i = t.checkChild(["$root", "blockQuote"], e);
      return n && i;
    }
    class d extends i.j {
      static get pluginName() {
        return "BlockQuoteEditing";
      }
      static get requires() {
        return [s.a, o.a];
      }
      init() {
        const t = this.editor,
          e = t.model.schema;
        t.commands.add("blockQuote", new a(t)),
          e.register("blockQuote", {
            allowWhere: "$block",
            allowContentOf: "$root",
          }),
          t.conversion.elementToElement({
            model: "blockQuote",
            view: "blockquote",
          }),
          t.model.document.registerPostFixer((n) => {
            const i = t.model.document.differ.getChanges();
            for (const t of i)
              if ("insert" == t.type) {
                const i = t.position.nodeAfter;
                if (!i) continue;
                if (i.is("element", "blockQuote") && i.isEmpty)
                  return n.remove(i), !0;
                if (
                  i.is("element", "blockQuote") &&
                  !e.checkChild(t.position, i)
                )
                  return n.unwrap(i), !0;
                if (i.is("element")) {
                  const t = n.createRangeIn(i);
                  for (const i of t.getItems())
                    if (
                      i.is("element", "blockQuote") &&
                      !e.checkChild(n.createPositionBefore(i), i)
                    )
                      return n.unwrap(i), !0;
                }
              } else if ("remove" == t.type) {
                const e = t.position.parent;
                if (e.is("element", "blockQuote") && e.isEmpty)
                  return n.remove(e), !0;
              }
            return !1;
          });
        const n = this.editor.editing.view.document,
          i = t.model.document.selection,
          s = t.commands.get("blockQuote");
        this.listenTo(
          n,
          "enter",
          (e, n) => {
            if (!i.isCollapsed || !s.value) return;
            i.getLastPosition().parent.isEmpty &&
              (t.execute("blockQuote"),
              t.editing.view.scrollToTheSelection(),
              n.preventDefault(),
              e.stop());
          },
          { context: "blockquote" }
        ),
          this.listenTo(
            n,
            "delete",
            (e, n) => {
              if ("backward" != n.direction || !i.isCollapsed || !s.value)
                return;
              const o = i.getLastPosition().parent;
              o.isEmpty &&
                !o.previousSibling &&
                (t.execute("blockQuote"),
                t.editing.view.scrollToTheSelection(),
                n.preventDefault(),
                e.stop());
            },
            { context: "blockquote" }
          );
      }
    }
    var h = n(4);
    n(363);
    class f extends i.j {
      static get pluginName() {
        return "BlockQuoteUI";
      }
      init() {
        const t = this.editor,
          e = t.t;
        t.ui.componentFactory.add("blockQuote", (n) => {
          const s = t.commands.get("blockQuote"),
            o = new h.e(n);
          return (
            o.set({
              label: e("Block quote"),
              icon: i.l.quote,
              tooltip: !0,
              isToggleable: !0,
            }),
            o.bind("isOn", "isEnabled").to(s, "value", "isEnabled"),
            this.listenTo(o, "execute", () => {
              t.execute("blockQuote"), t.editing.view.focus();
            }),
            o
          );
        });
      }
    }
    class m extends i.j {
      static get requires() {
        return [d, f];
      }
      static get pluginName() {
        return "BlockQuote";
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return l;
    });
    var i = n(1);
    class s extends i.j {
      static get pluginName() {
        return "IndentEditing";
      }
      init() {
        const t = this.editor;
        t.commands.add("indent", new i.h(t)),
          t.commands.add("outdent", new i.h(t));
      }
    }
    var o = n(4),
      r =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>',
      a =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
    class c extends i.j {
      static get pluginName() {
        return "IndentUI";
      }
      init() {
        const t = this.editor,
          e = t.locale,
          n = t.t,
          i = "ltr" == e.uiLanguageDirection ? r : a,
          s = "ltr" == e.uiLanguageDirection ? a : r;
        this._defineButton("indent", n("Increase indent"), i),
          this._defineButton("outdent", n("Decrease indent"), s);
      }
      _defineButton(t, e, n) {
        const i = this.editor;
        i.ui.componentFactory.add(t, (s) => {
          const r = i.commands.get(t),
            a = new o.e(s);
          return (
            a.set({ label: e, icon: n, tooltip: !0 }),
            a.bind("isOn", "isEnabled").to(r, "value", "isEnabled"),
            this.listenTo(a, "execute", () => {
              i.execute(t), i.editing.view.focus();
            }),
            a
          );
        });
      }
    }
    class l extends i.j {
      static get pluginName() {
        return "Indent";
      }
      static get requires() {
        return [s, c];
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(1),
      s = n(19),
      o = n(54),
      r = n(30);
    class a extends i.j {
      static get requires() {
        return [s.c, o.a];
      }
      static get pluginName() {
        return "ImageToolbar";
      }
      afterInit() {
        const t = this.editor,
          e = t.t,
          n = t.plugins.get(s.c),
          i = t.plugins.get("ImageUtils");
        var o;
        n.register("image", {
          ariaLabel: e("Image toolbar"),
          items:
            ((o = t.config.get("image.toolbar") || []),
            o.map((t) => (Object(r.a)(t) ? t.name : t))),
          getRelatedElement: (t) => i.getClosestSelectedImageWidget(t),
        });
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return T;
    });
    var i = n(1);
    class s extends i.a {
      constructor(t, e) {
        super(t),
          (this._defaultStyles = { imageBlock: !1, imageInline: !1 }),
          (this._styles = new Map(
            e.map((t) => {
              if (t.isDefault)
                for (const e of t.modelElements)
                  this._defaultStyles[e] = t.name;
              return [t.name, t];
            })
          ));
      }
      refresh() {
        const t = this.editor.plugins
          .get("ImageUtils")
          .getClosestSelectedImageElement(this.editor.model.document.selection);
        (this.isEnabled = !!t),
          this.isEnabled
            ? t.hasAttribute("imageStyle")
              ? (this.value = t.getAttribute("imageStyle"))
              : (this.value = this._defaultStyles[t.name])
            : (this.value = !1);
      }
      execute(t = {}) {
        const e = this.editor,
          n = e.model,
          i = e.plugins.get("ImageUtils");
        n.change((e) => {
          const s = t.value;
          let o = i.getClosestSelectedImageElement(n.document.selection);
          s &&
            this.shouldConvertImageType(s, o) &&
            (this.editor.execute(
              i.isBlockImage(o) ? "imageTypeInline" : "imageTypeBlock"
            ),
            (o = i.getClosestSelectedImageElement(n.document.selection))),
            !s || this._styles.get(s).isDefault
              ? e.removeAttribute("imageStyle", o)
              : e.setAttribute("imageStyle", s, o);
        });
      }
      shouldConvertImageType(t, e) {
        return !this._styles.get(t).modelElements.includes(e.name);
      }
    }
    var o = n(54),
      r = n(2);
    const {
        objectFullWidth: a,
        objectInline: c,
        objectLeft: l,
        objectRight: u,
        objectCenter: d,
        objectBlockLeft: h,
        objectBlockRight: f,
      } = i.l,
      m = {
        inline: {
          name: "inline",
          title: "In line",
          icon: c,
          modelElements: ["imageInline"],
          isDefault: !0,
        },
        alignLeft: {
          name: "alignLeft",
          title: "Left aligned image",
          icon: l,
          modelElements: ["imageBlock", "imageInline"],
          className: "image-style-align-left",
        },
        alignBlockLeft: {
          name: "alignBlockLeft",
          title: "Left aligned image",
          icon: h,
          modelElements: ["imageBlock"],
          className: "image-style-block-align-left",
        },
        alignCenter: {
          name: "alignCenter",
          title: "Centered image",
          icon: d,
          modelElements: ["imageBlock"],
          className: "image-style-align-center",
        },
        alignRight: {
          name: "alignRight",
          title: "Right aligned image",
          icon: u,
          modelElements: ["imageBlock", "imageInline"],
          className: "image-style-align-right",
        },
        alignBlockRight: {
          name: "alignBlockRight",
          title: "Right aligned image",
          icon: f,
          modelElements: ["imageBlock"],
          className: "image-style-block-align-right",
        },
        block: {
          name: "block",
          title: "Centered image",
          icon: d,
          modelElements: ["imageBlock"],
          isDefault: !0,
        },
        side: {
          name: "side",
          title: "Side image",
          icon: u,
          modelElements: ["imageBlock"],
          className: "image-style-side",
        },
      },
      g = {
        full: a,
        left: h,
        right: f,
        center: d,
        inlineLeft: l,
        inlineRight: u,
        inline: c,
      },
      p = [
        {
          name: "imageStyle:wrapText",
          title: "Wrap text",
          defaultItem: "imageStyle:alignLeft",
          items: ["imageStyle:alignLeft", "imageStyle:alignRight"],
        },
        {
          name: "imageStyle:breakText",
          title: "Break text",
          defaultItem: "imageStyle:block",
          items: [
            "imageStyle:alignBlockLeft",
            "imageStyle:block",
            "imageStyle:alignBlockRight",
          ],
        },
      ];
    function b(t) {
      Object(r.u)("image-style-configuration-definition-invalid", t);
    }
    var w = {
      normalizeStyles: function (t) {
        return (t.configuredStyles.options || [])
          .map((t) =>
            (function (t) {
              t =
                "string" == typeof t
                  ? m[t]
                    ? { ...m[t] }
                    : { name: t }
                  : (function (t, e) {
                      const n = { ...e };
                      for (const i in t)
                        Object.prototype.hasOwnProperty.call(e, i) ||
                          (n[i] = t[i]);
                      return n;
                    })(m[t.name], t);
              "string" == typeof t.icon && (t.icon = g[t.icon] || t.icon);
              return t;
            })(t)
          )
          .filter((e) =>
            (function (t, { isBlockPluginLoaded: e, isInlinePluginLoaded: n }) {
              const { modelElements: i, name: s } = t;
              if (!(i && i.length && s)) return b({ style: t }), !1;
              {
                const s = [e ? "imageBlock" : null, n ? "imageInline" : null];
                if (!i.some((t) => s.includes(t)))
                  return (
                    Object(r.u)("image-style-missing-dependency", {
                      style: t,
                      missingPlugins: i.map((t) =>
                        "imageBlock" === t
                          ? "ImageBlockEditing"
                          : "ImageInlineEditing"
                      ),
                    }),
                    !1
                  );
              }
              return !0;
            })(e, t)
          );
      },
      getDefaultStylesConfiguration: function (t, e) {
        return t && e
          ? {
              options: [
                "inline",
                "alignLeft",
                "alignRight",
                "alignCenter",
                "alignBlockLeft",
                "alignBlockRight",
                "block",
                "side",
              ],
            }
          : t
          ? { options: ["block", "side"] }
          : e
          ? { options: ["inline", "alignLeft", "alignRight"] }
          : {};
      },
      getDefaultDropdownDefinitions: function (t) {
        return t.has("ImageBlockEditing") && t.has("ImageInlineEditing")
          ? [...p]
          : [];
      },
      warnInvalidStyle: b,
      DEFAULT_OPTIONS: m,
      DEFAULT_ICONS: g,
      DEFAULT_DROPDOWN_DEFINITIONS: p,
    };
    function v(t, e) {
      for (const n of e) if (n.name === t) return n;
    }
    class _ extends i.j {
      static get pluginName() {
        return "ImageStyleEditing";
      }
      static get requires() {
        return [o.a];
      }
      init() {
        const { normalizeStyles: t, getDefaultStylesConfiguration: e } = w,
          n = this.editor,
          i = n.plugins.has("ImageBlockEditing"),
          o = n.plugins.has("ImageInlineEditing");
        n.config.define("image.styles", e(i, o)),
          (this.normalizedStyles = t({
            configuredStyles: n.config.get("image.styles"),
            isBlockPluginLoaded: i,
            isInlinePluginLoaded: o,
          })),
          this._setupConversion(i, o),
          this._setupPostFixer(),
          n.commands.add("imageStyle", new s(n, this.normalizedStyles));
      }
      _setupConversion(t, e) {
        const n = this.editor,
          i = n.model.schema,
          s =
            ((o = this.normalizedStyles),
            (t, e, n) => {
              if (!n.consumable.consume(e.item, t.name)) return;
              const i = v(e.attributeNewValue, o),
                s = v(e.attributeOldValue, o),
                r = n.mapper.toViewElement(e.item),
                a = n.writer;
              s && a.removeClass(s.className, r),
                i && a.addClass(i.className, r);
            });
        var o;
        const a = (function (t) {
          const e = {
            imageInline: t.filter(
              (t) => !t.isDefault && t.modelElements.includes("imageInline")
            ),
            imageBlock: t.filter(
              (t) => !t.isDefault && t.modelElements.includes("imageBlock")
            ),
          };
          return (t, n, i) => {
            if (!n.modelRange) return;
            const s = n.viewItem,
              o = Object(r.n)(n.modelRange.getItems());
            if (o && i.schema.checkAttribute(o, "imageStyle"))
              for (const t of e[o.name])
                i.consumable.consume(s, { classes: t.className }) &&
                  i.writer.setAttribute("imageStyle", t.name, o);
          };
        })(this.normalizedStyles);
        n.editing.downcastDispatcher.on("attribute:imageStyle", s),
          n.data.downcastDispatcher.on("attribute:imageStyle", s),
          t &&
            (i.extend("imageBlock", { allowAttributes: "imageStyle" }),
            n.data.upcastDispatcher.on("element:figure", a, {
              priority: "low",
            })),
          e &&
            (i.extend("imageInline", { allowAttributes: "imageStyle" }),
            n.data.upcastDispatcher.on("element:img", a, { priority: "low" }));
      }
      _setupPostFixer() {
        const t = this.editor,
          e = t.model.document,
          n = t.plugins.get(o.a),
          i = new Map(this.normalizedStyles.map((t) => [t.name, t]));
        e.registerPostFixer((t) => {
          let s = !1;
          for (const o of e.differ.getChanges())
            if (
              "insert" == o.type ||
              ("attribute" == o.type && "imageStyle" == o.attributeKey)
            ) {
              let e =
                "insert" == o.type
                  ? o.position.nodeAfter
                  : o.range.start.nodeAfter;
              if (
                (e &&
                  e.is("element", "paragraph") &&
                  e.childCount > 0 &&
                  (e = e.getChild(0)),
                !n.isImage(e))
              )
                continue;
              const r = e.getAttribute("imageStyle");
              if (!r) continue;
              const a = i.get(r);
              (a && a.modelElements.includes(e.name)) ||
                (t.removeAttribute("imageStyle", e), (s = !0));
            }
          return s;
        });
      }
    }
    var y = n(4),
      k = n(30),
      A = n(206);
    n(372);
    class C extends i.j {
      static get requires() {
        return [_];
      }
      static get pluginName() {
        return "ImageStyleUI";
      }
      get localizedDefaultStylesTitles() {
        const t = this.editor.t;
        return {
          "Wrap text": t("Wrap text"),
          "Break text": t("Break text"),
          "In line": t("In line"),
          "Full size image": t("Full size image"),
          "Side image": t("Side image"),
          "Left aligned image": t("Left aligned image"),
          "Centered image": t("Centered image"),
          "Right aligned image": t("Right aligned image"),
        };
      }
      init() {
        const t = this.editor.plugins,
          e = this.editor.config.get("image.toolbar") || [],
          n = E(
            t.get("ImageStyleEditing").normalizedStyles,
            this.localizedDefaultStylesTitles
          );
        for (const t of n) this._createButton(t);
        const i = E(
          [...e.filter(k.a), ...w.getDefaultDropdownDefinitions(t)],
          this.localizedDefaultStylesTitles
        );
        for (const t of i) this._createDropdown(t, n);
      }
      _createDropdown(t, e) {
        const n = this.editor.ui.componentFactory;
        n.add(t.name, (i) => {
          let s;
          const { defaultItem: o, items: r, title: a } = t,
            c = r
              .filter((t) => e.find(({ name: e }) => O(e) === t))
              .map((t) => {
                const e = n.create(t);
                return t === o && (s = e), e;
              });
          r.length !== c.length && w.warnInvalidStyle({ dropdown: t });
          const l = Object(y.I)(i, y.w),
            u = l.buttonView;
          return (
            Object(y.G)(l, c),
            u.set({ label: P(a, s.label), class: null, tooltip: !0 }),
            u.bind("icon").toMany(c, "isOn", (...t) => {
              const e = t.findIndex(A.a);
              return e < 0 ? s.icon : c[e].icon;
            }),
            u.bind("label").toMany(c, "isOn", (...t) => {
              const e = t.findIndex(A.a);
              return P(a, e < 0 ? s.label : c[e].label);
            }),
            u.bind("isOn").toMany(c, "isOn", (...t) => t.some(A.a)),
            u
              .bind("class")
              .toMany(c, "isOn", (...t) =>
                t.some(A.a) ? "ck-splitbutton_flatten" : null
              ),
            u.on("execute", () => {
              c.some(({ isOn: t }) => t)
                ? (l.isOpen = !l.isOpen)
                : s.fire("execute");
            }),
            l.bind("isEnabled").toMany(c, "isEnabled", (...t) => t.some(A.a)),
            l
          );
        });
      }
      _createButton(t) {
        const e = t.name;
        this.editor.ui.componentFactory.add(O(e), (n) => {
          const i = this.editor.commands.get("imageStyle"),
            s = new y.e(n);
          return (
            s.set({
              label: t.title,
              icon: t.icon,
              tooltip: !0,
              isToggleable: !0,
            }),
            s.bind("isEnabled").to(i, "isEnabled"),
            s.bind("isOn").to(i, "value", (t) => t === e),
            s.on("execute", this._executeCommand.bind(this, e)),
            s
          );
        });
      }
      _executeCommand(t) {
        this.editor.execute("imageStyle", { value: t }),
          this.editor.editing.view.focus();
      }
    }
    function E(t, e) {
      for (const n of t) e[n.title] && (n.title = e[n.title]);
      return t;
    }
    function O(t) {
      return "imageStyle:" + t;
    }
    function P(t, e) {
      return (t ? t + ": " : "") + e;
    }
    class T extends i.j {
      static get requires() {
        return [_, C];
      }
      static get pluginName() {
        return "ImageStyle";
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return m;
    });
    var i = n(1),
      s = n(13),
      o = n(19),
      r = n(244),
      a = n(99);
    class c extends i.a {
      refresh() {
        const t = this.editor,
          e = t.plugins.get("ImageUtils");
        if (!t.plugins.has(r.a))
          return (this.isEnabled = !1), void (this.value = !1);
        const n = t.model.document.selection,
          i = n.getSelectedElement();
        if (!i) {
          const t = Object(a.b)(e, n);
          return (this.isEnabled = !!t), void (this.value = !!t);
        }
        (this.isEnabled = this.editor.plugins.get("ImageUtils").isImage(i)),
          this.isEnabled ? (this.value = !!Object(a.a)(i)) : (this.value = !1);
      }
      execute(t = {}) {
        const { focusCaptionOnShow: e } = t;
        this.editor.model.change((t) => {
          this.value ? this._hideImageCaption(t) : this._showImageCaption(t, e);
        });
      }
      _showImageCaption(t, e) {
        const n = this.editor.model.document.selection,
          i = this.editor.plugins.get("ImageCaptionEditing");
        let s = n.getSelectedElement();
        const o = i._getSavedCaption(s);
        this.editor.plugins.get("ImageUtils").isInlineImage(s) &&
          (this.editor.execute("imageTypeBlock"), (s = n.getSelectedElement()));
        const r = o || t.createElement("caption");
        t.append(r, s), e && t.setSelection(r, "in");
      }
      _hideImageCaption(t) {
        const e = this.editor,
          n = e.model.document.selection,
          i = e.plugins.get("ImageCaptionEditing"),
          s = e.plugins.get("ImageUtils");
        let o,
          r = n.getSelectedElement();
        r ? (o = Object(a.a)(r)) : ((o = Object(a.b)(s, n)), (r = o.parent)),
          i._saveCaption(r, o),
          t.setSelection(r, "on"),
          t.remove(o);
      }
    }
    var l = n(54);
    class u extends i.j {
      static get requires() {
        return [l.a];
      }
      static get pluginName() {
        return "ImageCaptionEditing";
      }
      constructor(t) {
        super(t), (this._savedCaptionsMap = new WeakMap());
      }
      init() {
        const t = this.editor,
          e = t.model.schema;
        e.isRegistered("caption")
          ? e.extend("caption", { allowIn: "imageBlock" })
          : e.register("caption", {
              allowIn: "imageBlock",
              allowContentOf: "$block",
              isLimit: !0,
            }),
          t.commands.add("toggleImageCaption", new c(this.editor)),
          this._setupConversion(),
          this._setupImageTypeCommandsIntegration();
      }
      _setupConversion() {
        const t = this.editor,
          e = t.editing.view,
          n = t.plugins.get("ImageUtils"),
          i = t.t;
        t.conversion.for("upcast").elementToElement({
          view: (t) => Object(a.c)(n, t),
          model: "caption",
        }),
          t.conversion.for("dataDowncast").elementToElement({
            model: "caption",
            view: (t, { writer: e }) =>
              n.isBlockImage(t.parent)
                ? e.createContainerElement("figcaption")
                : null,
          }),
          t.conversion.for("editingDowncast").elementToElement({
            model: "caption",
            view: (t, { writer: r }) => {
              if (!n.isBlockImage(t.parent)) return null;
              const a = r.createEditableElement("figcaption");
              return (
                r.setCustomProperty("imageCaption", !0, a),
                Object(s.x)({
                  view: e,
                  element: a,
                  text: i("Enter image caption"),
                  keepOnFocus: !0,
                }),
                Object(o.h)(a, r)
              );
            },
          }),
          t.editing.mapper.on("modelToViewPosition", d(e)),
          t.data.mapper.on("modelToViewPosition", d(e));
      }
      _setupImageTypeCommandsIntegration() {
        const t = this.editor,
          e = t.plugins.get("ImageUtils"),
          n = t.commands.get("imageTypeInline"),
          i = t.commands.get("imageTypeBlock"),
          s = (t) => {
            if (!t.return) return;
            const { oldElement: n, newElement: i } = t.return;
            if (!n) return;
            if (e.isBlockImage(n)) {
              const t = Object(a.a)(n);
              if (t) return void this._saveCaption(i, t);
            }
            const s = this._getSavedCaption(n);
            s && this._saveCaption(i, s);
          };
        n && this.listenTo(n, "execute", s, { priority: "low" }),
          i && this.listenTo(i, "execute", s, { priority: "low" });
      }
      _getSavedCaption(t) {
        const e = this._savedCaptionsMap.get(t);
        return e ? s.e.fromJSON(e) : null;
      }
      _saveCaption(t, e) {
        this._savedCaptionsMap.set(t, e.toJSON());
      }
    }
    function d(t) {
      return (e, n) => {
        const i = n.modelPosition,
          s = i.parent;
        if (!s.is("element", "imageBlock")) return;
        const o = n.mapper.toViewElement(s);
        n.viewPosition = t.createPositionAt(o, i.offset + 1);
      };
    }
    var h = n(4);
    class f extends i.j {
      static get requires() {
        return [l.a];
      }
      static get pluginName() {
        return "ImageCaptionUI";
      }
      init() {
        const t = this.editor,
          e = t.editing.view,
          n = t.plugins.get("ImageUtils"),
          s = t.t;
        t.ui.componentFactory.add("toggleImageCaption", (o) => {
          const r = t.commands.get("toggleImageCaption"),
            c = new h.e(o);
          return (
            c.set({ icon: i.l.caption, tooltip: !0, isToggleable: !0 }),
            c.bind("isOn", "isEnabled").to(r, "value", "isEnabled"),
            c
              .bind("label")
              .to(r, "value", (t) =>
                s(t ? "Toggle caption off" : "Toggle caption on")
              ),
            this.listenTo(c, "execute", () => {
              t.execute("toggleImageCaption", { focusCaptionOnShow: !0 });
              const i = Object(a.b)(n, t.model.document.selection);
              if (i) {
                const n = t.editing.mapper.toViewElement(i);
                e.scrollToTheSelection(),
                  e.change((t) => {
                    t.addClass("image__caption_highlighted", n);
                  });
              }
            }),
            c
          );
        });
      }
    }
    n(371);
    class m extends i.j {
      static get requires() {
        return [u, f];
      }
      static get pluginName() {
        return "ImageCaption";
      }
    }
  },
  ,
  function (t, e, n) {
    "use strict";
    e.a =
      '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>';
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return h;
    });
    var i = n(1),
      s = n(13),
      o = n(4),
      r = n(19),
      a = n(2);
    n(240), n(369);
    class c extends o.D {
      constructor(t, e) {
        super(t);
        const n = t.t;
        (this.focusTracker = new a.f()),
          (this.keystrokes = new a.g()),
          (this.urlInputView = this._createUrlInput()),
          (this.saveButtonView = this._createButton(
            n("Save"),
            i.l.check,
            "ck-button-save"
          )),
          (this.saveButtonView.type = "submit"),
          (this.cancelButtonView = this._createButton(
            n("Cancel"),
            i.l.cancel,
            "ck-button-cancel",
            "cancel"
          )),
          (this._manualDecoratorSwitches =
            this._createManualDecoratorSwitches(e)),
          (this.children = this._createFormChildren(e.manualDecorators)),
          (this._focusables = new o.E()),
          (this._focusCycler = new o.k({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          }));
        const s = ["ck", "ck-link-form", "ck-responsive-form"];
        e.manualDecorators.length &&
          s.push("ck-link-form_layout-vertical", "ck-vertical-form"),
          this.setTemplate({
            tag: "form",
            attributes: { class: s, tabindex: "-1" },
            children: this.children,
          }),
          Object(o.N)(this);
      }
      getDecoratorSwitchesState() {
        return Array.from(this._manualDecoratorSwitches).reduce(
          (t, e) => ((t[e.name] = e.isOn), t),
          {}
        );
      }
      render() {
        super.render(), Object(o.Q)({ view: this });
        [
          this.urlInputView,
          ...this._manualDecoratorSwitches,
          this.saveButtonView,
          this.cancelButtonView,
        ].forEach((t) => {
          this._focusables.add(t), this.focusTracker.add(t.element);
        }),
          this.keystrokes.listenTo(this.element);
      }
      destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
      }
      focus() {
        this._focusCycler.focusFirst();
      }
      _createUrlInput() {
        const t = this.locale.t,
          e = new o.r(this.locale, o.K);
        return (e.label = t("Link URL")), e;
      }
      _createButton(t, e, n, i) {
        const s = new o.e(this.locale);
        return (
          s.set({ label: t, icon: e, tooltip: !0 }),
          s.extendTemplate({ attributes: { class: n } }),
          i && s.delegate("execute").to(this, i),
          s
        );
      }
      _createManualDecoratorSwitches(t) {
        const e = this.createCollection();
        for (const n of t.manualDecorators) {
          const i = new o.y(this.locale);
          i.set({ name: n.id, label: n.label, withText: !0 }),
            i
              .bind("isOn")
              .toMany([n, t], "value", (t, e) =>
                void 0 === e && void 0 === t ? n.defaultValue : t
              ),
            i.on("execute", () => {
              n.set("value", !i.isOn);
            }),
            e.add(i);
        }
        return e;
      }
      _createFormChildren(t) {
        const e = this.createCollection();
        if ((e.add(this.urlInputView), t.length)) {
          const t = new o.D();
          t.setTemplate({
            tag: "ul",
            children: this._manualDecoratorSwitches.map((t) => ({
              tag: "li",
              children: [t],
              attributes: { class: ["ck", "ck-list__item"] },
            })),
            attributes: { class: ["ck", "ck-reset", "ck-list"] },
          }),
            e.add(t);
        }
        return e.add(this.saveButtonView), e.add(this.cancelButtonView), e;
      }
    }
    var l = n(43);
    n(370);
    class u extends o.D {
      constructor(t) {
        super(t);
        const e = t.t;
        (this.focusTracker = new a.f()),
          (this.keystrokes = new a.g()),
          (this.previewButtonView = this._createPreviewButton()),
          (this.unlinkButtonView = this._createButton(
            e("Unlink"),
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>',
            "unlink"
          )),
          (this.editButtonView = this._createButton(
            e("Edit link"),
            i.l.pencil,
            "edit"
          )),
          this.set("href"),
          (this._focusables = new o.E()),
          (this._focusCycler = new o.k({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          })),
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck", "ck-link-actions", "ck-responsive-form"],
              tabindex: "-1",
            },
            children: [
              this.previewButtonView,
              this.editButtonView,
              this.unlinkButtonView,
            ],
          });
      }
      render() {
        super.render();
        [
          this.previewButtonView,
          this.editButtonView,
          this.unlinkButtonView,
        ].forEach((t) => {
          this._focusables.add(t), this.focusTracker.add(t.element);
        }),
          this.keystrokes.listenTo(this.element);
      }
      destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
      }
      focus() {
        this._focusCycler.focusFirst();
      }
      _createButton(t, e, n) {
        const i = new o.e(this.locale);
        return (
          i.set({ label: t, icon: e, tooltip: !0 }),
          i.delegate("execute").to(this, n),
          i
        );
      }
      _createPreviewButton() {
        const t = new o.e(this.locale),
          e = this.bindTemplate,
          n = this.t;
        return (
          t.set({ withText: !0, tooltip: n("Open link in new tab") }),
          t.extendTemplate({
            attributes: {
              class: ["ck", "ck-link-actions__preview"],
              href: e.to("href", (t) => t && Object(l.d)(t)),
              target: "_blank",
              rel: "noopener noreferrer",
            },
          }),
          t
            .bind("label")
            .to(this, "href", (t) => t || n("This link has no URL")),
          t.bind("isEnabled").to(this, "href", (t) => !!t),
          (t.template.tag = "a"),
          (t.template.eventListeners = {}),
          t
        );
      }
    }
    var d = n(314);
    class h extends i.j {
      static get requires() {
        return [o.h];
      }
      static get pluginName() {
        return "LinkUI";
      }
      init() {
        const t = this.editor;
        t.editing.view.addObserver(s.a),
          (this.actionsView = this._createActionsView()),
          (this.formView = this._createFormView()),
          (this._balloon = t.plugins.get(o.h)),
          this._createToolbarLinkButton(),
          this._enableUserBalloonInteractions(),
          t.conversion.for("editingDowncast").markerToHighlight({
            model: "link-ui",
            view: { classes: ["ck-fake-link-selection"] },
          }),
          t.conversion.for("editingDowncast").markerToElement({
            model: "link-ui",
            view: {
              name: "span",
              classes: [
                "ck-fake-link-selection",
                "ck-fake-link-selection_collapsed",
              ],
            },
          });
      }
      destroy() {
        super.destroy(), this.formView.destroy();
      }
      _createActionsView() {
        const t = this.editor,
          e = new u(t.locale),
          n = t.commands.get("link"),
          i = t.commands.get("unlink");
        return (
          e.bind("href").to(n, "value"),
          e.editButtonView.bind("isEnabled").to(n),
          e.unlinkButtonView.bind("isEnabled").to(i),
          this.listenTo(e, "edit", () => {
            this._addFormView();
          }),
          this.listenTo(e, "unlink", () => {
            t.execute("unlink"), this._hideUI();
          }),
          e.keystrokes.set("Esc", (t, e) => {
            this._hideUI(), e();
          }),
          e.keystrokes.set(l.a, (t, e) => {
            this._addFormView(), e();
          }),
          e
        );
      }
      _createFormView() {
        const t = this.editor,
          e = t.commands.get("link"),
          n = t.config.get("link.defaultProtocol"),
          i = new c(t.locale, e);
        return (
          i.urlInputView.fieldView.bind("value").to(e, "value"),
          i.urlInputView.bind("isReadOnly").to(e, "isEnabled", (t) => !t),
          i.saveButtonView.bind("isEnabled").to(e),
          this.listenTo(i, "submit", () => {
            const { value: e } = i.urlInputView.fieldView.element,
              s = Object(l.b)(e, n);
            t.execute("link", s, i.getDecoratorSwitchesState()),
              this._closeFormView();
          }),
          this.listenTo(i, "cancel", () => {
            this._closeFormView();
          }),
          i.keystrokes.set("Esc", (t, e) => {
            this._closeFormView(), e();
          }),
          i
        );
      }
      _createToolbarLinkButton() {
        const t = this.editor,
          e = t.commands.get("link"),
          n = t.t;
        t.keystrokes.set(l.a, (t, n) => {
          n(), e.isEnabled && this._showUI(!0);
        }),
          t.ui.componentFactory.add("link", (t) => {
            const i = new o.e(t);
            return (
              (i.isEnabled = !0),
              (i.label = n("Link")),
              (i.icon = d.a),
              (i.keystroke = l.a),
              (i.tooltip = !0),
              (i.isToggleable = !0),
              i.bind("isEnabled").to(e, "isEnabled"),
              i.bind("isOn").to(e, "value", (t) => !!t),
              this.listenTo(i, "execute", () => this._showUI(!0)),
              i
            );
          });
      }
      _enableUserBalloonInteractions() {
        const t = this.editor.editing.view.document;
        this.listenTo(t, "click", () => {
          this._getSelectedLinkElement() && this._showUI();
        }),
          this.editor.keystrokes.set(
            "Tab",
            (t, e) => {
              this._areActionsVisible &&
                !this.actionsView.focusTracker.isFocused &&
                (this.actionsView.focus(), e());
            },
            { priority: "high" }
          ),
          this.editor.keystrokes.set("Esc", (t, e) => {
            this._isUIVisible && (this._hideUI(), e());
          }),
          Object(o.H)({
            emitter: this.formView,
            activator: () => this._isUIInPanel,
            contextElements: [this._balloon.view.element],
            callback: () => this._hideUI(),
          });
      }
      _addActionsView() {
        this._areActionsInPanel ||
          this._balloon.add({
            view: this.actionsView,
            position: this._getBalloonPositionData(),
          });
      }
      _addFormView() {
        if (this._isFormInPanel) return;
        const t = this.editor.commands.get("link");
        this.formView.disableCssTransitions(),
          this._balloon.add({
            view: this.formView,
            position: this._getBalloonPositionData(),
          }),
          this._balloon.visibleView === this.formView &&
            this.formView.urlInputView.fieldView.select(),
          this.formView.enableCssTransitions(),
          (this.formView.urlInputView.fieldView.element.value = t.value || "");
      }
      _closeFormView() {
        const t = this.editor.commands.get("link");
        t.restoreManualDecoratorStates(),
          void 0 !== t.value ? this._removeFormView() : this._hideUI();
      }
      _removeFormView() {
        this._isFormInPanel &&
          (this.formView.saveButtonView.focus(),
          this._balloon.remove(this.formView),
          this.editor.editing.view.focus(),
          this._hideFakeVisualSelection());
      }
      _showUI(t = !1) {
        this._getSelectedLinkElement()
          ? (this._areActionsVisible
              ? this._addFormView()
              : this._addActionsView(),
            t && this._balloon.showStack("main"))
          : (this._showFakeVisualSelection(),
            this._addActionsView(),
            t && this._balloon.showStack("main"),
            this._addFormView()),
          this._startUpdatingUI();
      }
      _hideUI() {
        if (!this._isUIInPanel) return;
        const t = this.editor;
        this.stopListening(t.ui, "update"),
          this.stopListening(this._balloon, "change:visibleView"),
          t.editing.view.focus(),
          this._removeFormView(),
          this._balloon.remove(this.actionsView),
          this._hideFakeVisualSelection();
      }
      _startUpdatingUI() {
        const t = this.editor,
          e = t.editing.view.document;
        let n = this._getSelectedLinkElement(),
          i = o();
        const s = () => {
          const t = this._getSelectedLinkElement(),
            e = o();
          (n && !t) || (!n && e !== i)
            ? this._hideUI()
            : this._isUIVisible &&
              this._balloon.updatePosition(this._getBalloonPositionData()),
            (n = t),
            (i = e);
        };
        function o() {
          return e.selection.focus
            .getAncestors()
            .reverse()
            .find((t) => t.is("element"));
        }
        this.listenTo(t.ui, "update", s),
          this.listenTo(this._balloon, "change:visibleView", s);
      }
      get _isFormInPanel() {
        return this._balloon.hasView(this.formView);
      }
      get _areActionsInPanel() {
        return this._balloon.hasView(this.actionsView);
      }
      get _areActionsVisible() {
        return this._balloon.visibleView === this.actionsView;
      }
      get _isUIInPanel() {
        return this._isFormInPanel || this._areActionsInPanel;
      }
      get _isUIVisible() {
        return (
          this._balloon.visibleView == this.formView || this._areActionsVisible
        );
      }
      _getBalloonPositionData() {
        const t = this.editor.editing.view,
          e = this.editor.model,
          n = t.document;
        let i = null;
        if (e.markers.has("link-ui")) {
          const e = Array.from(
              this.editor.editing.mapper.markerNameToElements("link-ui")
            ),
            n = t.createRange(
              t.createPositionBefore(e[0]),
              t.createPositionAfter(e[e.length - 1])
            );
          i = t.domConverter.viewRangeToDom(n);
        } else
          i = () => {
            const e = this._getSelectedLinkElement();
            return e
              ? t.domConverter.mapViewToDom(e)
              : t.domConverter.viewRangeToDom(n.selection.getFirstRange());
          };
        return { target: i };
      }
      _getSelectedLinkElement() {
        const t = this.editor.editing.view,
          e = t.document.selection,
          n = e.getSelectedElement();
        if (e.isCollapsed || (n && Object(r.e)(n)))
          return f(e.getFirstPosition());
        {
          const n = e.getFirstRange().getTrimmed(),
            i = f(n.start),
            s = f(n.end);
          return i && i == s && t.createRangeIn(i).getTrimmed().isEqual(n)
            ? i
            : null;
        }
      }
      _showFakeVisualSelection() {
        const t = this.editor.model;
        t.change((e) => {
          const n = t.document.selection.getFirstRange();
          if (t.markers.has("link-ui")) e.updateMarker("link-ui", { range: n });
          else if (n.start.isAtEnd) {
            const i = n.start.getLastMatchingPosition(
              ({ item: e }) => !t.schema.isContent(e),
              { boundaries: n }
            );
            e.addMarker("link-ui", {
              usingOperation: !1,
              affectsData: !1,
              range: e.createRange(i, n.end),
            });
          } else
            e.addMarker("link-ui", {
              usingOperation: !1,
              affectsData: !1,
              range: n,
            });
        });
      }
      _hideFakeVisualSelection() {
        const t = this.editor.model;
        t.markers.has("link-ui") &&
          t.change((t) => {
            t.removeMarker("link-ui");
          });
      }
    }
    function f(t) {
      return t.getAncestors().find((t) => Object(l.f)(t));
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return c;
    });
    var i = n(1),
      s = n(2),
      o = n(66);
    class r extends i.j {
      static get pluginName() {
        return "CloudServicesUploadAdapter";
      }
      static get requires() {
        return ["CloudServices", o.b];
      }
      init() {
        const t = this.editor,
          e = t.plugins.get("CloudServices"),
          n = e.token,
          i = e.uploadUrl;
        n &&
          ((this._uploadGateway = t.plugins
            .get("CloudServicesCore")
            .createUploadGateway(n, i)),
          (t.plugins.get(o.b).createUploadAdapter = (t) =>
            new a(this._uploadGateway, t)));
      }
    }
    class a {
      constructor(t, e) {
        (this.uploadGateway = t), (this.loader = e);
      }
      upload() {
        return this.loader.file.then(
          (t) => (
            (this.fileUploader = this.uploadGateway.upload(t)),
            this.fileUploader.on("progress", (t, e) => {
              (this.loader.uploadTotal = e.total),
                (this.loader.uploaded = e.uploaded);
            }),
            this.fileUploader.send()
          )
        );
      }
      abort() {
        this.fileUploader.abort();
      }
    }
    class c extends i.j {
      static get requires() {
        return [r, "ImageUpload"];
      }
      init() {
        const t = this.editor;
        t.plugins.has("ImageBlockEditing") ||
          t.plugins.has("ImageInlineEditing") ||
          Object(s.u)("easy-image-image-feature-missing", t);
      }
      static get pluginName() {
        return "EasyImage";
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return a;
    });
    var i = n(1),
      s = n(33),
      o = n(43);
    const r = new RegExp(
      "(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$",
      "i"
    );
    class a extends i.j {
      static get requires() {
        return [s.a];
      }
      static get pluginName() {
        return "AutoLink";
      }
      init() {
        const t = this.editor.model.document.selection;
        t.on("change:range", () => {
          this.isEnabled = !t.anchor.parent.is("element", "codeBlock");
        }),
          this._enableTypingHandling();
      }
      afterInit() {
        this._enableEnterHandling(), this._enableShiftEnterHandling();
      }
      _enableTypingHandling() {
        const t = this.editor,
          e = new s.c(t.model, (t) => {
            if (
              !(function (t) {
                return (
                  t.length > 4 &&
                  " " === t[t.length - 1] &&
                  " " !== t[t.length - 2]
                );
              })(t)
            )
              return;
            const e = c(t.substr(0, t.length - 1));
            return e ? { url: e } : void 0;
          }),
          n = t.plugins.get("Input");
        e.on("matched:data", (e, i) => {
          const { batch: s, range: o, url: r } = i;
          if (!n.isInput(s)) return;
          const a = o.end.getShiftedBy(-1),
            c = a.getShiftedBy(-r.length),
            l = t.model.createRange(c, a);
          this._applyAutoLink(r, l);
        }),
          e.bind("isEnabled").to(this);
      }
      _enableEnterHandling() {
        const t = this.editor,
          e = t.model,
          n = t.commands.get("enter");
        n &&
          n.on("execute", () => {
            const t = e.document.selection.getFirstPosition();
            if (!t.parent.previousSibling) return;
            const n = e.createRangeIn(t.parent.previousSibling);
            this._checkAndApplyAutoLinkOnRange(n);
          });
      }
      _enableShiftEnterHandling() {
        const t = this.editor,
          e = t.model,
          n = t.commands.get("shiftEnter");
        n &&
          n.on("execute", () => {
            const t = e.document.selection.getFirstPosition(),
              n = e.createRange(
                e.createPositionAt(t.parent, 0),
                t.getShiftedBy(-1)
              );
            this._checkAndApplyAutoLinkOnRange(n);
          });
      }
      _checkAndApplyAutoLinkOnRange(t) {
        const e = this.editor.model,
          { text: n, range: i } = Object(s.g)(t, e),
          o = c(n);
        if (o) {
          const t = e.createRange(i.end.getShiftedBy(-o.length), i.end);
          this._applyAutoLink(o, t);
        }
      }
      _applyAutoLink(t, e) {
        const n = this.editor.model,
          i = this.editor.plugins.get("Delete");
        this.isEnabled &&
          (function (t, e) {
            return e.schema.checkAttributeInSelection(
              e.createSelection(t),
              "linkHref"
            );
          })(e, n) &&
          n.enqueueChange((s) => {
            const r = this.editor.config.get("link.defaultProtocol"),
              a = Object(o.b)(t, r);
            s.setAttribute("linkHref", a, e),
              n.enqueueChange(() => {
                i.requestUndoOnBackspace();
              });
          });
      }
    }
    function c(t) {
      const e = r.exec(t);
      return e ? e[2] : null;
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return o;
    });
    var i = n(9),
      s = n(131);
    class o extends i.a {
      static get requires() {
        return [s.a];
      }
      static get pluginName() {
        return "Base64UploadAdapter";
      }
      init() {
        this.editor.plugins.get(s.a).createUploadAdapter = (t) => new r(t);
      }
    }
    class r {
      constructor(t) {
        this.loader = t;
      }
      upload() {
        return new Promise((t, e) => {
          const n = (this.reader = new window.FileReader());
          n.addEventListener("load", () => {
            t({ default: n.result });
          }),
            n.addEventListener("error", (t) => {
              e(t);
            }),
            n.addEventListener("abort", () => {
              e();
            }),
            this.loader.file.then((t) => {
              n.readAsDataURL(t);
            });
        });
      }
      abort() {
        this.reader.abort();
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return y;
    });
    var i = n(1),
      s = n(19),
      o = n(2);
    function r(t, e) {
      return (t) => {
        t.on("attribute:url:media", n);
      };
      function n(n, i, s) {
        if (!s.consumable.consume(i.item, n.name)) return;
        const o = i.attributeNewValue,
          r = s.writer,
          a = s.mapper.toViewElement(i.item),
          c = [...a.getChildren()].find((t) =>
            t.getCustomProperty("media-content")
          );
        r.remove(c);
        const l = t.getMediaViewElement(r, o, e);
        r.insert(r.createPositionAt(a, 0), l);
      }
    }
    var a = n(107);
    class c extends i.a {
      refresh() {
        const t = this.editor.model,
          e = t.document.selection,
          n = Object(a.b)(e);
        (this.value = n ? n.getAttribute("url") : null),
          (this.isEnabled =
            (function (t) {
              const e = t.getSelectedElement();
              return !!e && "media" === e.name;
            })(e) ||
            (function (t, e) {
              let n = Object(s.d)(t, e).start.parent;
              n.isEmpty && !e.schema.isLimit(n) && (n = n.parent);
              return e.schema.checkChild(n, "media");
            })(e, t));
      }
      execute(t) {
        const e = this.editor.model,
          n = e.document.selection,
          i = Object(a.b)(n);
        i
          ? e.change((e) => {
              e.setAttribute("url", t, i);
            })
          : Object(a.d)(e, t, Object(s.d)(n, e));
      }
    }
    var l = n(4);
    class u {
      constructor(t, e) {
        const n = e.providers,
          i = e.extraProviders || [],
          s = new Set(e.removeProviders),
          r = n.concat(i).filter((t) => {
            const e = t.name;
            return e
              ? !s.has(e)
              : (Object(o.u)("media-embed-no-provider-name", { provider: t }),
                !1);
          });
        (this.locale = t), (this.providerDefinitions = r);
      }
      hasMedia(t) {
        return !!this._getMedia(t);
      }
      getMediaViewElement(t, e, n) {
        return this._getMedia(e).getViewElement(t, n);
      }
      _getMedia(t) {
        if (!t) return new d(this.locale);
        t = t.trim();
        for (const e of this.providerDefinitions) {
          const n = e.html,
            i = Object(o.z)(e.url);
          for (const e of i) {
            const i = this._getUrlMatches(t, e);
            if (i) return new d(this.locale, t, i, n);
          }
        }
        return null;
      }
      _getUrlMatches(t, e) {
        let n = t.match(e);
        if (n) return n;
        let i = t.replace(/^https?:\/\//, "");
        return (
          (n = i.match(e)),
          n || ((i = i.replace(/^www\./, "")), (n = i.match(e)), n || null)
        );
      }
    }
    class d {
      constructor(t, e, n, i) {
        (this.url = this._getValidUrl(e)),
          (this._t = t.t),
          (this._match = n),
          (this._previewRenderer = i);
      }
      getViewElement(t, e) {
        const n = {};
        let i;
        if (
          e.renderForEditingView ||
          (e.renderMediaPreview && this.url && this._previewRenderer)
        ) {
          this.url && (n["data-oembed-url"] = this.url),
            e.renderForEditingView && (n.class = "ck-media__wrapper");
          const s = this._getPreviewHtml(e);
          i = t.createRawElement("div", n, (t, e) => {
            e.setContentOf(t, s);
          });
        } else
          this.url && (n.url = this.url),
            (i = t.createEmptyElement(e.elementName, n));
        return t.setCustomProperty("media-content", !0, i), i;
      }
      _getPreviewHtml(t) {
        return this._previewRenderer
          ? this._previewRenderer(this._match)
          : this.url && t.renderForEditingView
          ? this._getPlaceholderHtml()
          : "";
      }
      _getPlaceholderHtml() {
        const t = new l.C(),
          e = new l.m();
        (t.text = this._t("Open media in new tab")),
          (e.content =
            '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>'),
          (e.viewBox = "0 0 64 42");
        return new l.z({
          tag: "div",
          attributes: { class: "ck ck-reset_all ck-media__placeholder" },
          children: [
            {
              tag: "div",
              attributes: { class: "ck-media__placeholder__icon" },
              children: [e],
            },
            {
              tag: "a",
              attributes: {
                class: "ck-media__placeholder__url",
                target: "_blank",
                rel: "noopener noreferrer",
                href: this.url,
              },
              children: [
                {
                  tag: "span",
                  attributes: { class: "ck-media__placeholder__url__text" },
                  children: [this.url],
                },
                t,
              ],
            },
          ],
        }).render().outerHTML;
      }
      _getValidUrl(t) {
        return t ? (t.match(/^https?/) ? t : "https://" + t) : null;
      }
    }
    n(373);
    class h extends i.j {
      static get pluginName() {
        return "MediaEmbedEditing";
      }
      constructor(t) {
        super(t),
          t.config.define("mediaEmbed", {
            elementName: "oembed",
            providers: [
              {
                name: "dailymotion",
                url: /^dailymotion\.com\/video\/(\w+)/,
                html: (t) =>
                  `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>`,
              },
              {
                name: "spotify",
                url: [
                  /^open\.spotify\.com\/(artist\/\w+)/,
                  /^open\.spotify\.com\/(album\/\w+)/,
                  /^open\.spotify\.com\/(track\/\w+)/,
                ],
                html: (t) =>
                  `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>`,
              },
              {
                name: "youtube",
                url: [
                  /^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)/,
                  /^(?:m\.)?youtube\.com\/v\/([\w-]+)/,
                  /^youtube\.com\/embed\/([\w-]+)/,
                  /^youtu\.be\/([\w-]+)/,
                ],
                html: (t) =>
                  `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>`,
              },
              {
                name: "vimeo",
                url: [
                  /^vimeo\.com\/(\d+)/,
                  /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/,
                  /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/,
                  /^vimeo\.com\/channels\/[^/]+\/(\d+)/,
                  /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/,
                  /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/,
                  /^player\.vimeo\.com\/video\/(\d+)/,
                ],
                html: (t) =>
                  `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>`,
              },
              { name: "instagram", url: /^instagram\.com\/p\/(\w+)/ },
              { name: "twitter", url: /^twitter\.com/ },
              {
                name: "googleMaps",
                url: [
                  /^google\.com\/maps/,
                  /^goo\.gl\/maps/,
                  /^maps\.google\.com/,
                  /^maps\.app\.goo\.gl/,
                ],
              },
              { name: "flickr", url: /^flickr\.com/ },
              { name: "facebook", url: /^facebook\.com/ },
            ],
          }),
          (this.registry = new u(t.locale, t.config.get("mediaEmbed")));
      }
      init() {
        const t = this.editor,
          e = t.model.schema,
          n = t.t,
          i = t.conversion,
          s = t.config.get("mediaEmbed.previewsInData"),
          l = t.config.get("mediaEmbed.elementName"),
          u = this.registry;
        t.commands.add("mediaEmbed", new c(t)),
          e.register("media", {
            isObject: !0,
            isBlock: !0,
            allowWhere: "$block",
            allowAttributes: ["url"],
          }),
          i.for("dataDowncast").elementToElement({
            model: "media",
            view: (t, { writer: e }) => {
              const n = t.getAttribute("url");
              return Object(a.a)(e, u, n, {
                elementName: l,
                renderMediaPreview: n && s,
              });
            },
          }),
          i
            .for("dataDowncast")
            .add(r(u, { elementName: l, renderMediaPreview: s })),
          i.for("editingDowncast").elementToElement({
            model: "media",
            view: (t, { writer: e }) => {
              const i = t.getAttribute("url"),
                s = Object(a.a)(e, u, i, {
                  elementName: l,
                  renderForEditingView: !0,
                });
              return Object(a.e)(s, e, n("media widget"));
            },
          }),
          i
            .for("editingDowncast")
            .add(r(u, { elementName: l, renderForEditingView: !0 })),
          i
            .for("upcast")
            .elementToElement({
              view: (t) =>
                ["oembed", l].includes(t.name) && t.getAttribute("url")
                  ? { name: !0 }
                  : null,
              model: (t, { writer: e }) => {
                const n = t.getAttribute("url");
                if (u.hasMedia(n)) return e.createElement("media", { url: n });
              },
            })
            .elementToElement({
              view: { name: "div", attributes: { "data-oembed-url": !0 } },
              model: (t, { writer: e }) => {
                const n = t.getAttribute("data-oembed-url");
                if (u.hasMedia(n)) return e.createElement("media", { url: n });
              },
            })
            .add((t) => {
              t.on("element:figure", function (t, e, n) {
                if (
                  !n.consumable.consume(e.viewItem, {
                    name: !0,
                    classes: "media",
                  })
                )
                  return;
                const { modelRange: i, modelCursor: s } = n.convertChildren(
                  e.viewItem,
                  e.modelCursor
                );
                (e.modelRange = i), (e.modelCursor = s);
                Object(o.n)(i.getItems()) ||
                  n.consumable.revert(e.viewItem, {
                    name: !0,
                    classes: "media",
                  });
              });
            });
      }
    }
    var f = n(13),
      m = n(77),
      g = n(33),
      p = n(238);
    const b = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;
    class w extends i.j {
      static get requires() {
        return [m.a, g.a, p.a];
      }
      static get pluginName() {
        return "AutoMediaEmbed";
      }
      constructor(t) {
        super(t), (this._timeoutId = null), (this._positionToInsert = null);
      }
      init() {
        const t = this.editor,
          e = t.model.document;
        this.listenTo(
          t.plugins.get("ClipboardPipeline"),
          "inputTransformation",
          () => {
            const t = e.selection.getFirstRange(),
              n = f.h.fromPosition(t.start);
            n.stickiness = "toPrevious";
            const i = f.h.fromPosition(t.end);
            (i.stickiness = "toNext"),
              e.once(
                "change:data",
                () => {
                  this._embedMediaBetweenPositions(n, i),
                    n.detach(),
                    i.detach();
                },
                { priority: "high" }
              );
          }
        ),
          t.commands.get("undo").on(
            "execute",
            () => {
              this._timeoutId &&
                (o.s.window.clearTimeout(this._timeoutId),
                this._positionToInsert.detach(),
                (this._timeoutId = null),
                (this._positionToInsert = null));
            },
            { priority: "high" }
          );
      }
      _embedMediaBetweenPositions(t, e) {
        const n = this.editor,
          i = n.plugins.get(h).registry,
          s = new f.i(t, e),
          r = s.getWalker({ ignoreElementEnd: !0 });
        let c = "";
        for (const t of r) t.item.is("$textProxy") && (c += t.item.data);
        if (((c = c.trim()), !c.match(b))) return void s.detach();
        if (!i.hasMedia(c)) return void s.detach();
        n.commands.get("mediaEmbed").isEnabled
          ? ((this._positionToInsert = f.h.fromPosition(t)),
            (this._timeoutId = o.s.window.setTimeout(() => {
              n.model.change((t) => {
                let e;
                (this._timeoutId = null),
                  t.remove(s),
                  s.detach(),
                  "$graveyard" !== this._positionToInsert.root.rootName &&
                    (e = this._positionToInsert),
                  Object(a.d)(n.model, c, e),
                  this._positionToInsert.detach(),
                  (this._positionToInsert = null);
              }),
                n.plugins.get("Delete").requestUndoOnBackspace();
            }, 100)))
          : s.detach();
      }
    }
    n(240), n(374);
    class v extends l.D {
      constructor(t, e) {
        super(e);
        const n = e.t;
        (this.focusTracker = new o.f()),
          (this.keystrokes = new o.g()),
          this.set("mediaURLInputValue", ""),
          (this.urlInputView = this._createUrlInput()),
          (this.saveButtonView = this._createButton(
            n("Save"),
            i.l.check,
            "ck-button-save"
          )),
          (this.saveButtonView.type = "submit"),
          this.saveButtonView
            .bind("isEnabled")
            .to(this, "mediaURLInputValue", (t) => !!t),
          (this.cancelButtonView = this._createButton(
            n("Cancel"),
            i.l.cancel,
            "ck-button-cancel",
            "cancel"
          )),
          (this._focusables = new l.E()),
          (this._focusCycler = new l.k({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          })),
          (this._validators = t),
          this.setTemplate({
            tag: "form",
            attributes: {
              class: ["ck", "ck-media-form", "ck-responsive-form"],
              tabindex: "-1",
            },
            children: [
              this.urlInputView,
              this.saveButtonView,
              this.cancelButtonView,
            ],
          }),
          Object(l.N)(this);
      }
      render() {
        super.render(), Object(l.Q)({ view: this });
        [this.urlInputView, this.saveButtonView, this.cancelButtonView].forEach(
          (t) => {
            this._focusables.add(t), this.focusTracker.add(t.element);
          }
        ),
          this.keystrokes.listenTo(this.element);
        const t = (t) => t.stopPropagation();
        this.keystrokes.set("arrowright", t),
          this.keystrokes.set("arrowleft", t),
          this.keystrokes.set("arrowup", t),
          this.keystrokes.set("arrowdown", t),
          this.listenTo(
            this.urlInputView.element,
            "selectstart",
            (t, e) => {
              e.stopPropagation();
            },
            { priority: "high" }
          );
      }
      destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
      }
      focus() {
        this._focusCycler.focusFirst();
      }
      get url() {
        return this.urlInputView.fieldView.element.value.trim();
      }
      set url(t) {
        this.urlInputView.fieldView.element.value = t.trim();
      }
      isValid() {
        this.resetFormStatus();
        for (const t of this._validators) {
          const e = t(this);
          if (e) return (this.urlInputView.errorText = e), !1;
        }
        return !0;
      }
      resetFormStatus() {
        (this.urlInputView.errorText = null),
          (this.urlInputView.infoText = this._urlInputViewInfoDefault);
      }
      _createUrlInput() {
        const t = this.locale.t,
          e = new l.r(this.locale, l.K),
          n = e.fieldView;
        return (
          (this._urlInputViewInfoDefault = t(
            "Paste the media URL in the input."
          )),
          (this._urlInputViewInfoTip = t(
            "Tip: Paste the URL into the content to embed faster."
          )),
          (e.label = t("Media URL")),
          (e.infoText = this._urlInputViewInfoDefault),
          n.on("input", () => {
            (e.infoText = n.element.value
              ? this._urlInputViewInfoTip
              : this._urlInputViewInfoDefault),
              (this.mediaURLInputValue = n.element.value.trim());
          }),
          e
        );
      }
      _createButton(t, e, n, i) {
        const s = new l.e(this.locale);
        return (
          s.set({ label: t, icon: e, tooltip: !0 }),
          s.extendTemplate({ attributes: { class: n } }),
          i && s.delegate("execute").to(this, i),
          s
        );
      }
    }
    class _ extends i.j {
      static get requires() {
        return [h];
      }
      static get pluginName() {
        return "MediaEmbedUI";
      }
      init() {
        const t = this.editor,
          e = t.commands.get("mediaEmbed"),
          n = t.plugins.get(h).registry;
        t.ui.componentFactory.add("mediaEmbed", (i) => {
          const s = Object(l.I)(i),
            o = new v(
              (function (t, e) {
                return [
                  (e) => {
                    if (!e.url.length) return t("The URL must not be empty.");
                  },
                  (n) => {
                    if (!e.hasMedia(n.url))
                      return t("This media URL is not supported.");
                  },
                ];
              })(t.t, n),
              t.locale
            );
          return this._setUpDropdown(s, o, e, t), this._setUpForm(s, o, e), s;
        });
      }
      _setUpDropdown(t, e, n) {
        const i = this.editor,
          s = i.t,
          o = t.buttonView;
        function r() {
          i.editing.view.focus(), (t.isOpen = !1);
        }
        t.bind("isEnabled").to(n),
          t.panelView.children.add(e),
          o.set({
            label: s("Insert media"),
            icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 0 1 .593-.351l5.133 2.824a.4.4 0 0 1 0 .7l-5.133 2.824a.4.4 0 0 1-.593-.35V7.176v.001z"/></svg>',
            tooltip: !0,
          }),
          o.on(
            "open",
            () => {
              e.disableCssTransitions(),
                (e.url = n.value || ""),
                e.urlInputView.fieldView.select(),
                e.focus(),
                e.enableCssTransitions();
            },
            { priority: "low" }
          ),
          t.on("submit", () => {
            e.isValid() && (i.execute("mediaEmbed", e.url), r());
          }),
          t.on("change:isOpen", () => e.resetFormStatus()),
          t.on("cancel", () => r());
      }
      _setUpForm(t, e, n) {
        e.delegate("submit", "cancel").to(t),
          e.urlInputView.bind("value").to(n, "value"),
          e.urlInputView.bind("isReadOnly").to(n, "isEnabled", (t) => !t);
      }
    }
    n(375);
    class y extends i.j {
      static get requires() {
        return [h, _, w, s.a];
      }
      static get pluginName() {
        return "MediaEmbed";
      }
    }
  },
  ,
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return w;
    });
    var i = n(1),
      s = n(77),
      o = n(13);
    function r(t, e) {
      if (!t.childCount) return;
      const n = new o.q(t.document),
        i = (function (t, e) {
          const n = e.createRangeIn(t),
            i = new o.k({ name: /^p|h\d+$/, styles: { "mso-list": /.*/ } }),
            s = [];
          for (const t of n)
            if ("elementStart" === t.type && i.match(t.item)) {
              const e = l(t.item);
              s.push({
                element: t.item,
                id: e.id,
                order: e.order,
                indent: e.indent,
              });
            }
          return s;
        })(t, n);
      if (!i.length) return;
      let s = null,
        r = 1;
      i.forEach((t, l) => {
        const u = (function (t, e) {
            if (!t) return !0;
            if (t.id !== e.id) return e.indent - t.indent != 1;
            const n = e.element.previousSibling;
            if (!n) return !0;
            return (i = n), !(i.is("element", "ol") || i.is("element", "ul"));
            var i;
          })(i[l - 1], t),
          d = u ? null : i[l - 1],
          h = ((m = t), (f = d) ? m.indent - f.indent : m.indent - 1);
        var f, m;
        if ((u && ((s = null), (r = 1)), !s || 0 !== h)) {
          const i = (function (t, e) {
            const n = new RegExp(
                `@list l${t.id}:level${t.indent}\\s*({[^}]*)`,
                "gi"
              ),
              i = /mso-level-number-format:([^;]{0,100});/gi,
              s = n.exec(e);
            let o = "decimal",
              r = "ol";
            if (s && s[1]) {
              const e = i.exec(s[1]);
              if (
                (e &&
                  e[1] &&
                  ((o = e[1].trim()),
                  (r = "bullet" !== o && "image" !== o ? "ol" : "ul")),
                "bullet" === o)
              ) {
                const e = (function (t) {
                  const e = (function (t) {
                    if (t.getChild(0).is("$text")) return null;
                    for (const e of t.getChildren()) {
                      if (!e.is("element", "span")) continue;
                      const t = e.getChild(0);
                      return t.is("$text") ? t : t.getChild(0);
                    }
                  })(t);
                  if (!e) return null;
                  const n = e._data;
                  if ("o" === n) return "circle";
                  if ("·" === n) return "disc";
                  if ("§" === n) return "square";
                  return null;
                })(t.element);
                e && (o = e);
              }
            }
            return { type: r, style: a(o) };
          })(t, e);
          if (s) {
            if (t.indent > r) {
              const t = s.getChild(s.childCount - 1),
                e = t.getChild(t.childCount - 1);
              (s = c(i, e, n)), (r += 1);
            } else if (t.indent < r) {
              const e = r - t.indent;
              (s = (function (t, e) {
                const n = t.getAncestors({ parentFirst: !0 });
                let i = null,
                  s = 0;
                for (const t of n)
                  if ((("ul" !== t.name && "ol" !== t.name) || s++, s === e)) {
                    i = t;
                    break;
                  }
                return i;
              })(s, e)),
                (r = parseInt(t.indent));
            }
          } else s = c(i, t.element, n);
          t.indent <= r &&
            (s.is("element", i.type) || (s = n.rename(i.type, s)));
        }
        const g = (function (t, e) {
          return (
            (function (t, e) {
              const n = new o.k({
                  name: "span",
                  styles: { "mso-list": "Ignore" },
                }),
                i = e.createRangeIn(t);
              for (const t of i)
                "elementStart" === t.type &&
                  n.match(t.item) &&
                  e.remove(t.item);
            })(t, e),
            e.rename("li", t)
          );
        })(t.element, n);
        n.appendChild(g, s);
      });
    }
    function a(t) {
      switch (t) {
        case "arabic-leading-zero":
          return "decimal-leading-zero";
        case "alpha-upper":
          return "upper-alpha";
        case "alpha-lower":
          return "lower-alpha";
        case "roman-upper":
          return "upper-roman";
        case "roman-lower":
          return "lower-roman";
        case "circle":
        case "disc":
        case "square":
          return t;
        default:
          return null;
      }
    }
    function c(t, e, n) {
      const i = e.parent,
        s = n.createElement(t.type),
        o = i.getChildIndex(e) + 1;
      return (
        n.insertChild(o, s, i),
        t.style && n.setStyle("list-style-type", t.style, s),
        s
      );
    }
    function l(t) {
      const e = {},
        n = t.getStyle("mso-list");
      if (n) {
        const t = n.match(/(^|\s{1,100})l(\d+)/i),
          i = n.match(/\s{0,100}lfo(\d+)/i),
          s = n.match(/\s{0,100}level(\d+)/i);
        t && i && s && ((e.id = t[2]), (e.order = i[1]), (e.indent = s[1]));
      }
      return e;
    }
    const u = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
    class d {
      constructor(t) {
        this.document = t;
      }
      isActive(t) {
        return u.test(t);
      }
      execute(t) {
        const e = new o.q(this.document),
          { body: n } = t._parsedData;
        !(function (t, e) {
          for (const n of t.getChildren())
            if (
              n.is("element", "b") &&
              "normal" === n.getStyle("font-weight")
            ) {
              const i = t.getChildIndex(n);
              e.remove(n), e.insertChild(i, n.getChildren(), t);
            }
        })(n, e),
          (function (t, e) {
            for (const n of e.createRangeIn(t)) {
              const t = n.item;
              if (t.is("element", "li")) {
                const n = t.getChild(0);
                n && n.is("element", "p") && e.unwrapElement(n);
              }
            }
          })(n, e),
          (t.content = n);
      }
    }
    function h(t, e) {
      if (!t.childCount) return;
      const n = new o.q();
      !(function (t, e, n) {
        const i = n.createRangeIn(e),
          s = new o.k({ name: "img" }),
          r = [];
        for (const e of i)
          if (s.match(e.item)) {
            const n = e.item,
              i = n.getAttribute("v:shapes")
                ? n.getAttribute("v:shapes").split(" ")
                : [];
            i.length && i.every((e) => t.indexOf(e) > -1)
              ? r.push(n)
              : n.getAttribute("src") || r.push(n);
          }
        for (const t of r) n.remove(t);
      })(
        (function (t, e) {
          const n = e.createRangeIn(t),
            i = new o.k({ name: /v:(.+)/ }),
            s = [];
          for (const t of n) {
            if ("elementStart" != t.type) continue;
            const e = t.item,
              n = (e.previousSibling && e.previousSibling.name) || null;
            i.match(e) &&
              e.getAttribute("o:gfxdata") &&
              "v:shapetype" !== n &&
              s.push(t.item.getAttribute("id"));
          }
          return s;
        })(t, n),
        t,
        n
      ),
        (function (t, e) {
          const n = e.createRangeIn(t),
            i = new o.k({ name: /v:(.+)/ }),
            s = [];
          for (const t of n)
            "elementStart" == t.type && i.match(t.item) && s.push(t.item);
          for (const t of s) e.remove(t);
        })(t, n);
      const i = (function (t, e) {
        const n = e.createRangeIn(t),
          i = new o.k({ name: "img" }),
          s = [];
        for (const t of n)
          i.match(t.item) &&
            t.item.getAttribute("src").startsWith("file://") &&
            s.push(t.item);
        return s;
      })(t, n);
      i.length &&
        (function (t, e, n) {
          if (t.length === e.length)
            for (let s = 0; s < t.length; s++) {
              const o = `data:${e[s].type};base64,${
                ((i = e[s].hex),
                btoa(
                  i
                    .match(/\w{2}/g)
                    .map((t) => String.fromCharCode(parseInt(t, 16)))
                    .join("")
                ))
              }`;
              n.setAttribute("src", o, t[s]);
            }
          var i;
        })(
          i,
          (function (t) {
            if (!t) return [];
            const e =
                /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/,
              n = new RegExp("(?:(" + e.source + "))([\\da-fA-F\\s]+)\\}", "g"),
              i = t.match(n),
              s = [];
            if (i)
              for (const t of i) {
                let n = !1;
                t.includes("\\pngblip")
                  ? (n = "image/png")
                  : t.includes("\\jpegblip") && (n = "image/jpeg"),
                  n &&
                    s.push({
                      hex: t.replace(e, "").replace(/[^\da-fA-F]/g, ""),
                      type: n,
                    });
              }
            return s;
          })(e),
          n
        );
    }
    const f =
        /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i,
      m = /xmlns:o="urn:schemas-microsoft-com/i;
    class g {
      constructor(t) {
        this.document = t;
      }
      isActive(t) {
        return f.test(t) || m.test(t);
      }
      execute(t) {
        const { body: e, stylesString: n } = t._parsedData;
        r(e, n), h(e, t.dataTransfer.getData("text/rtf")), (t.content = e);
      }
    }
    function p(t) {
      return t.replace(
        /<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g,
        (t, e) =>
          1 === e.length
            ? " "
            : Array(e.length + 1)
                .join("  ")
                .substr(0, e.length)
      );
    }
    function b(t, e) {
      const n = new DOMParser(),
        i = (function (t) {
          return p(p(t))
            .replace(
              /(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g,
              "$1$2"
            )
            .replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "")
            .replace(/ <\//g, " </")
            .replace(/ <o:p><\/o:p>/g, " <o:p></o:p>")
            .replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "")
            .replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><");
        })(
          (function (t) {
            const e = t.indexOf("</body>");
            if (e < 0) return t;
            const n = t.indexOf("</html>", e + "</body>".length);
            return (
              t.substring(0, e + "</body>".length) +
              (n >= 0 ? t.substring(n) : "")
            );
          })((t = t.replace(/<!--\[if gte vml 1]>/g, "")))
        ),
        s = n.parseFromString(i, "text/html");
      !(function (t) {
        t.querySelectorAll("span[style*=spacerun]").forEach((t) => {
          const e = t.innerText.length || 0;
          t.innerHTML = Array(e + 1)
            .join("  ")
            .substr(0, e);
        });
      })(s);
      const r = s.body.innerHTML,
        a = (function (t, e) {
          const n = new o.r(e),
            i = new o.b(n, { renderingMode: "data" }),
            s = t.createDocumentFragment(),
            r = t.body.childNodes;
          for (; r.length > 0; ) s.appendChild(r[0]);
          return i.domToView(s, { skipComments: !0 });
        })(s, e),
        c = (function (t) {
          const e = [],
            n = [],
            i = Array.from(t.getElementsByTagName("style"));
          for (const t of i)
            t.sheet &&
              t.sheet.cssRules &&
              t.sheet.cssRules.length &&
              (e.push(t.sheet), n.push(t.innerHTML));
          return { styles: e, stylesString: n.join(" ") };
        })(s);
      return {
        body: a,
        bodyString: r,
        styles: c.styles,
        stylesString: c.stylesString,
      };
    }
    class w extends i.j {
      static get pluginName() {
        return "PasteFromOffice";
      }
      static get requires() {
        return [s.b];
      }
      init() {
        const t = this.editor,
          e = t.editing.view.document,
          n = [];
        n.push(new g(e)),
          n.push(new d(e)),
          t.plugins.get("ClipboardPipeline").on(
            "inputTransformation",
            (t, i) => {
              if (i._isTransformedWithPasteFromOffice) return;
              const s = i.dataTransfer.getData("text/html"),
                o = n.find((t) => t.isActive(s));
              o &&
                ((i._parsedData = b(s, e.stylesProcessor)),
                o.execute(i),
                (i._isTransformedWithPasteFromOffice = !0));
            },
            { priority: "high" }
          );
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return u;
    });
    var i = n(1),
      s = n(2),
      o = n(179),
      r = n(4),
      a = n(13);
    class c extends i.f {
      constructor(t, e) {
        super(t),
          (this.view = e),
          (this._toolbarConfig = Object(r.P)(t.config.get("toolbar"))),
          (this._elementReplacer = new s.d());
      }
      get element() {
        return this.view.element;
      }
      init(t) {
        const e = this.editor,
          n = this.view,
          i = e.editing.view,
          s = n.editable,
          o = i.document.getRoot();
        (s.name = o.rootName), n.render();
        const r = s.element;
        this.setEditableElement(s.name, r),
          this.focusTracker.add(r),
          n.editable.bind("isFocused").to(this.focusTracker),
          i.attachDomRoot(r),
          t && this._elementReplacer.replace(t, this.element),
          this._initPlaceholder(),
          this._initToolbar(),
          this.fire("ready");
      }
      destroy() {
        const t = this.view,
          e = this.editor.editing.view;
        this._elementReplacer.restore(),
          e.detachDomRoot(t.editable.name),
          t.destroy(),
          super.destroy();
      }
      _initToolbar() {
        const t = this.editor,
          e = this.view,
          n = t.editing.view;
        e.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"),
          (e.stickyPanel.limiterElement = e.element),
          e.stickyPanel
            .bind("viewportTopOffset")
            .to(this, "viewportOffset", ({ top: t }) => t),
          e.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory),
          Object(r.L)({
            origin: n,
            originFocusTracker: this.focusTracker,
            originKeystrokeHandler: t.keystrokes,
            toolbar: e.toolbar,
          });
      }
      _initPlaceholder() {
        const t = this.editor,
          e = t.editing.view,
          n = e.document.getRoot(),
          i = t.sourceElement,
          s =
            t.config.get("placeholder") ||
            (i &&
              "textarea" === i.tagName.toLowerCase() &&
              i.getAttribute("placeholder"));
        s &&
          Object(a.x)({
            view: e,
            element: n,
            text: s,
            isDirectHost: !1,
            keepOnFocus: !0,
          });
      }
    }
    n(376);
    class l extends r.d {
      constructor(t, e, n = {}) {
        super(t),
          (this.stickyPanel = new r.x(t)),
          (this.toolbar = new r.B(t, {
            shouldGroupWhenFull: n.shouldToolbarGroupWhenFull,
          })),
          (this.editable = new r.o(t, e));
      }
      render() {
        super.render(),
          this.stickyPanel.content.add(this.toolbar),
          this.top.add(this.stickyPanel),
          this.main.add(this.editable);
      }
    }
    class u extends i.e {
      constructor(t, e) {
        super(e),
          Object(o.a)(t) && (this.sourceElement = t),
          this.model.document.createRoot();
        const n = !this.config.get("toolbar.shouldNotGroupWhenFull"),
          s = new l(this.locale, this.editing.view, {
            shouldToolbarGroupWhenFull: n,
          });
        (this.ui = new c(this, s)), Object(i.k)(this);
      }
      destroy() {
        return (
          this.sourceElement && this.updateSourceElement(),
          this.ui.destroy(),
          super.destroy()
        );
      }
      static create(t, e = {}) {
        return new Promise((n) => {
          const i = new this(t, e);
          n(
            i
              .initPlugins()
              .then(() => i.ui.init(Object(o.a)(t) ? t : null))
              .then(() => {
                if (!Object(o.a)(t) && e.initialData)
                  throw new s.a("editor-create-initial-data", null);
                const n =
                  void 0 !== e.initialData
                    ? e.initialData
                    : (function (t) {
                        return Object(o.a)(t) ? Object(s.p)(t) : t;
                      })(t);
                return i.data.init(n);
              })
              .then(() => i.fire("ready"))
              .then(() => i)
          );
        });
      }
    }
    Object(s.v)(u, i.d), Object(s.v)(u, i.g);
  },
  ,
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return u;
    });
    var i = n(1),
      s = n(4);
    class o extends i.j {
      static get pluginName() {
        return "CKFinderUI";
      }
      init() {
        const t = this.editor,
          e = t.ui.componentFactory,
          n = t.t;
        e.add("ckfinder", (e) => {
          const i = t.commands.get("ckfinder"),
            o = new s.e(e);
          return (
            o.set({
              label: n("Insert image or file"),
              icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>',
              tooltip: !0,
            }),
            o.bind("isEnabled").to(i),
            o.on("execute", () => {
              t.execute("ckfinder"), t.editing.view.focus();
            }),
            o
          );
        });
      }
    }
    var r = n(2);
    class a extends i.a {
      constructor(t) {
        super(t),
          this.stopListening(this.editor.model.document, "change"),
          this.listenTo(
            this.editor.model.document,
            "change",
            () => this.refresh(),
            { priority: "low" }
          );
      }
      refresh() {
        const t = this.editor.commands.get("insertImage"),
          e = this.editor.commands.get("link");
        this.isEnabled = t.isEnabled || e.isEnabled;
      }
      execute() {
        const t = this.editor,
          e = this.editor.config.get("ckfinder.openerMethod") || "modal";
        if ("popup" != e && "modal" != e)
          throw new r.a("ckfinder-unknown-openermethod", t);
        const n = this.editor.config.get("ckfinder.options") || {};
        n.chooseFiles = !0;
        const i = n.onInit;
        n.language || (n.language = t.locale.uiLanguage),
          (n.onInit = (e) => {
            i && i(e),
              e.on("files:choose", (n) => {
                const i = n.data.files.toArray(),
                  s = i.filter((t) => !t.isImage()),
                  o = i.filter((t) => t.isImage());
                for (const e of s) t.execute("link", e.getUrl());
                const r = [];
                for (const t of o) {
                  const n = t.getUrl();
                  r.push(n || e.request("file:getProxyUrl", { file: t }));
                }
                r.length && c(t, r);
              }),
              e.on("file:choose:resizedImage", (e) => {
                const n = e.data.resizedUrl;
                if (n) c(t, [n]);
                else {
                  const e = t.plugins.get("Notification"),
                    n = t.locale.t;
                  e.showWarning(n("Could not obtain resized image URL."), {
                    title: n("Selecting resized image failed"),
                    namespace: "ckfinder",
                  });
                }
              });
          }),
          window.CKFinder[e](n);
      }
    }
    function c(t, e) {
      if (t.commands.get("insertImage").isEnabled)
        t.execute("insertImage", { source: e });
      else {
        const e = t.plugins.get("Notification"),
          n = t.locale.t;
        e.showWarning(n("Could not insert image at the current position."), {
          title: n("Inserting image failed"),
          namespace: "ckfinder",
        });
      }
    }
    class l extends i.j {
      static get pluginName() {
        return "CKFinderEditing";
      }
      static get requires() {
        return [s.v, "LinkEditing"];
      }
      init() {
        const t = this.editor;
        if (
          !t.plugins.has("ImageBlockEditing") &&
          !t.plugins.has("ImageInlineEditing")
        )
          throw new r.a("ckfinder-missing-image-plugin", t);
        t.commands.add("ckfinder", new a(t));
      }
    }
    class u extends i.j {
      static get pluginName() {
        return "CKFinder";
      }
      static get requires() {
        return ["Link", "CKFinderUploadAdapter", l, o];
      }
    }
  },
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return r;
    });
    var i = n(1),
      s = n(66);
    function o() {
      let t = (function (t) {
        t = t.toLowerCase();
        const e = document.cookie.split(";");
        for (const n of e) {
          const e = n.split("=");
          if (decodeURIComponent(e[0].trim().toLowerCase()) === t)
            return decodeURIComponent(e[1]);
        }
        return null;
      })("ckCsrfToken");
      var e, n;
      return (
        (t && 40 == t.length) ||
          ((t = (function (t) {
            let e = "";
            const n = new Uint8Array(t);
            window.crypto.getRandomValues(n);
            for (let t = 0; t < n.length; t++) {
              const i = "abcdefghijklmnopqrstuvwxyz0123456789".charAt(
                n[t] % "abcdefghijklmnopqrstuvwxyz0123456789".length
              );
              e += Math.random() > 0.5 ? i.toUpperCase() : i;
            }
            return e;
          })(40)),
          (e = "ckCsrfToken"),
          (n = t),
          (document.cookie =
            encodeURIComponent(e) + "=" + encodeURIComponent(n) + ";path=/")),
        t
      );
    }
    class r extends i.j {
      static get requires() {
        return [s.b];
      }
      static get pluginName() {
        return "CKFinderUploadAdapter";
      }
      init() {
        const t = this.editor.config.get("ckfinder.uploadUrl");
        t &&
          (this.editor.plugins.get(s.b).createUploadAdapter = (e) =>
            new a(e, t, this.editor.t));
      }
    }
    class a {
      constructor(t, e, n) {
        (this.loader = t), (this.url = e), (this.t = n);
      }
      upload() {
        return this.loader.file.then(
          (t) =>
            new Promise((e, n) => {
              this._initRequest(),
                this._initListeners(e, n, t),
                this._sendRequest(t);
            })
        );
      }
      abort() {
        this.xhr && this.xhr.abort();
      }
      _initRequest() {
        const t = (this.xhr = new XMLHttpRequest());
        t.open("POST", this.url, !0), (t.responseType = "json");
      }
      _initListeners(t, e, n) {
        const i = this.xhr,
          s = this.loader,
          o = (0, this.t)("Cannot upload file:") + ` ${n.name}.`;
        i.addEventListener("error", () => e(o)),
          i.addEventListener("abort", () => e()),
          i.addEventListener("load", () => {
            const n = i.response;
            if (!n || !n.uploaded)
              return e(n && n.error && n.error.message ? n.error.message : o);
            t({ default: n.url });
          }),
          i.upload &&
            i.upload.addEventListener("progress", (t) => {
              t.lengthComputable &&
                ((s.uploadTotal = t.total), (s.uploaded = t.loaded));
            });
      }
      _sendRequest(t) {
        const e = new FormData();
        e.append("upload", t), e.append("ckCsrfToken", o()), this.xhr.send(e);
      }
    }
  },
  function (t, e, n) {
    "use strict";
    var i = n(261),
      s = n(30);
    e.a = function (t, e, n) {
      var o = !0,
        r = !0;
      if ("function" != typeof t) throw new TypeError("Expected a function");
      return (
        Object(s.a)(n) &&
          ((o = "leading" in n ? !!n.leading : o),
          (r = "trailing" in n ? !!n.trailing : r)),
        Object(i.a)(t, e, { leading: o, maxWait: e, trailing: r })
      );
    };
  },
  ,
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {
    "use strict";
    var i = n(154);
    e.a = function (t) {
      return Object(i.a)(t, 4);
    };
  },
  ,
  function (t, e, n) {
    "use strict";
    var i = n(166),
      s = /[\\^$.*+?()[\]{}|]/g,
      o = RegExp(s.source);
    e.a = function (t) {
      return (t = Object(i.a)(t)) && o.test(t) ? t.replace(s, "\\$&") : t;
    };
  },
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  function (t, e, n) {},
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  function (t, e, n) {
    "use strict";
    var i = n(155);
    var s = function (t) {
        var e = null == t ? 0 : t.length;
        return e ? t[e - 1] : void 0;
      },
      o = n(216),
      r = n(237);
    var a = function (t, e) {
        return e.length < 2 ? t : Object(o.a)(t, Object(r.a)(e, 0, -1));
      },
      c = n(153);
    var l = function (t, e) {
      return (
        (e = Object(i.a)(e, t)),
        null == (t = a(t, e)) || delete t[Object(c.a)(s(e))]
      );
    };
    e.a = function (t, e) {
      return null == t || l(t, e);
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(148),
      s = n(155),
      o = n(146),
      r = n(30),
      a = n(153);
    var c = function (t, e, n, c) {
      if (!Object(r.a)(t)) return t;
      for (
        var l = -1, u = (e = Object(s.a)(e, t)).length, d = u - 1, h = t;
        null != h && ++l < u;

      ) {
        var f = Object(a.a)(e[l]),
          m = n;
        if ("__proto__" === f || "constructor" === f || "prototype" === f)
          return t;
        if (l != d) {
          var g = h[f];
          void 0 === (m = c ? c(g, f, h) : void 0) &&
            (m = Object(r.a)(g) ? g : Object(o.a)(e[l + 1]) ? [] : {});
        }
        Object(i.a)(h, f, m), (h = h[f]);
      }
      return t;
    };
    e.a = function (t, e, n) {
      return null == t ? t : c(t, e, n);
    };
  },
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return A;
    });
    var i = n(1),
      s = n(130),
      o = n(13),
      r = n(2);
    function a(t) {
      const e = t.t,
        n = t.config.get("codeBlock.languages");
      for (const t of n)
        "Plain text" === t.label && (t.label = e("Plain text")),
          void 0 === t.class && (t.class = "language-" + t.language);
      return n;
    }
    function c(t, e, n) {
      const i = {};
      for (const s of t)
        "class" === e ? (i[s[e].split(" ").shift()] = s[n]) : (i[s[e]] = s[n]);
      return i;
    }
    function l(t) {
      return t.data.match(/^(\s*)/)[0];
    }
    function u(t) {
      const e = t.document.selection,
        n = [];
      if (e.isCollapsed) n.push(e.anchor);
      else {
        const i = e
          .getFirstRange()
          .getWalker({ ignoreElementEnd: !0, direction: "backward" });
        for (const { item: e } of i)
          if (e.is("$textProxy") && e.parent.is("element", "codeBlock")) {
            const i = l(e.textNode),
              { parent: s, startOffset: o } = e.textNode,
              r = t.createPositionAt(s, o + i.length);
            n.push(r);
          }
      }
      return n;
    }
    function d(t) {
      const e = Object(r.n)(t.getSelectedBlocks());
      return e && e.is("element", "codeBlock");
    }
    class h extends i.a {
      constructor(t) {
        super(t), (this._lastLanguage = null);
      }
      refresh() {
        (this.value = this._getValue()),
          (this.isEnabled = this._checkEnabled());
      }
      execute(t = {}) {
        const e = this.editor,
          n = e.model,
          i = n.document.selection,
          s = a(e)[0],
          o = Array.from(i.getSelectedBlocks()),
          r = void 0 === t.forceValue ? !this.value : t.forceValue,
          c = (function (t, e, n) {
            if (t.language) return t.language;
            if (t.usePreviousLanguageChoice && e) return e;
            return n;
          })(t, this._lastLanguage, s.language);
        n.change((t) => {
          r ? this._applyCodeBlock(t, o, c) : this._removeCodeBlock(t, o);
        });
      }
      _getValue() {
        const t = this.editor.model.document.selection,
          e = Object(r.n)(t.getSelectedBlocks());
        return (
          !!!(!e || !e.is("element", "codeBlock")) && e.getAttribute("language")
        );
      }
      _checkEnabled() {
        if (this.value) return !0;
        const t = this.editor.model.document.selection,
          e = this.editor.model.schema,
          n = Object(r.n)(t.getSelectedBlocks());
        return !!n && f(e, n);
      }
      _applyCodeBlock(t, e, n) {
        this._lastLanguage = n;
        const i = this.editor.model.schema,
          s = e.filter((t) => f(i, t));
        for (const e of s)
          t.rename(e, "codeBlock"),
            t.setAttribute("language", n, e),
            i.removeDisallowedAttributes([e], t),
            Array.from(e.getChildren())
              .filter((t) => !i.checkChild(e, t))
              .forEach((e) => t.remove(e));
        s.reverse().forEach((e, n) => {
          const i = s[n + 1];
          e.previousSibling === i &&
            (t.appendElement("softBreak", i),
            t.merge(t.createPositionBefore(e)));
        });
      }
      _removeCodeBlock(t, e) {
        const n = e.filter((t) => t.is("element", "codeBlock"));
        for (const e of n) {
          const n = t.createRangeOn(e);
          for (const e of Array.from(n.getItems()).reverse())
            if (
              e.is("element", "softBreak") &&
              e.parent.is("element", "codeBlock")
            ) {
              const { position: n } = t.split(t.createPositionBefore(e));
              t.rename(n.nodeAfter, "paragraph"),
                t.removeAttribute("language", n.nodeAfter),
                t.remove(e);
            }
          t.rename(e, "paragraph"), t.removeAttribute("language", e);
        }
      }
    }
    function f(t, e) {
      return (
        !e.is("rootElement") &&
        !t.isLimit(e) &&
        t.checkChild(e.parent, "codeBlock")
      );
    }
    class m extends i.a {
      constructor(t) {
        super(t),
          (this._indentSequence = t.config.get("codeBlock.indentSequence"));
      }
      refresh() {
        this.isEnabled = this._checkEnabled();
      }
      execute() {
        const t = this.editor.model;
        t.change((e) => {
          const n = u(t);
          for (const t of n) e.insertText(this._indentSequence, t);
        });
      }
      _checkEnabled() {
        return (
          !!this._indentSequence && d(this.editor.model.document.selection)
        );
      }
    }
    class g extends i.a {
      constructor(t) {
        super(t),
          (this._indentSequence = t.config.get("codeBlock.indentSequence"));
      }
      refresh() {
        this.isEnabled = this._checkEnabled();
      }
      execute() {
        const t = this.editor.model;
        t.change((e) => {
          const n = u(t);
          for (const t of n) {
            const n = p(this.editor.model, t, this._indentSequence);
            n && e.remove(n);
          }
        });
      }
      _checkEnabled() {
        if (!this._indentSequence) return !1;
        const t = this.editor.model;
        return (
          !!d(t.document.selection) &&
          u(t).some((e) => p(t, e, this._indentSequence))
        );
      }
    }
    function p(t, e, n) {
      const i = (function (t) {
        let e = t.parent.getChild(t.index);
        (e && !e.is("element", "softBreak")) || (e = t.nodeBefore);
        if (!e || e.is("element", "softBreak")) return null;
        return e;
      })(e);
      if (!i) return null;
      const s = l(i),
        o = s.lastIndexOf(n);
      if (o + n.length !== s.length) return null;
      if (-1 === o) return null;
      const { parent: r, startOffset: a } = i;
      return t.createRange(
        t.createPositionAt(r, a + o),
        t.createPositionAt(r, a + o + n.length)
      );
    }
    function b(t, e, n = !1) {
      const i = c(e, "language", "class"),
        s = c(e, "language", "label");
      return (e, o, r) => {
        const { writer: a, mapper: c, consumable: l } = r;
        if (!l.consume(o.item, "insert")) return;
        const u = o.item.getAttribute("language"),
          d = c.toViewPosition(t.createPositionBefore(o.item)),
          h = {};
        n && ((h["data-language"] = s[u]), (h.spellcheck = "false"));
        const f = a.createContainerElement("pre", h),
          m = a.createContainerElement("code", { class: i[u] || null });
        a.insert(a.createPositionAt(f, 0), m),
          a.insert(d, f),
          c.bindElements(o.item, m);
      };
    }
    class w extends i.j {
      static get pluginName() {
        return "CodeBlockEditing";
      }
      static get requires() {
        return [s.b];
      }
      constructor(t) {
        super(t),
          t.config.define("codeBlock", {
            languages: [
              { language: "plaintext", label: "Plain text" },
              { language: "c", label: "C" },
              { language: "cs", label: "C#" },
              { language: "cpp", label: "C++" },
              { language: "css", label: "CSS" },
              { language: "diff", label: "Diff" },
              { language: "html", label: "HTML" },
              { language: "java", label: "Java" },
              { language: "javascript", label: "JavaScript" },
              { language: "php", label: "PHP" },
              { language: "python", label: "Python" },
              { language: "ruby", label: "Ruby" },
              { language: "typescript", label: "TypeScript" },
              { language: "xml", label: "XML" },
            ],
            indentSequence: "\t",
          });
      }
      init() {
        const t = this.editor,
          e = t.model.schema,
          n = t.model,
          i = (t.editing.view, a(t));
        t.commands.add("codeBlock", new h(t)),
          t.commands.add("indentCodeBlock", new m(t)),
          t.commands.add("outdentCodeBlock", new g(t));
        const s = (t) => (e, n) => {
          this.editor.commands.get(t).isEnabled &&
            (this.editor.execute(t), n());
        };
        t.keystrokes.set("Tab", s("indentCodeBlock")),
          t.keystrokes.set("Shift+Tab", s("outdentCodeBlock")),
          e.register("codeBlock", {
            allowWhere: "$block",
            allowChildren: "$text",
            isBlock: !0,
            allowAttributes: ["language"],
          }),
          e.addAttributeCheck((t) => {
            if (t.endsWith("codeBlock $text")) return !1;
          }),
          t.model.schema.addChildCheck((t, e) => {
            if (t.endsWith("codeBlock") && e.isObject) return !1;
          }),
          t.editing.downcastDispatcher.on("insert:codeBlock", b(n, i, !0)),
          t.data.downcastDispatcher.on("insert:codeBlock", b(n, i)),
          t.data.downcastDispatcher.on(
            "insert:softBreak",
            (function (t) {
              return (e, n, i) => {
                if ("codeBlock" !== n.item.parent.name) return;
                const { writer: s, mapper: o, consumable: r } = i;
                if (!r.consume(n.item, "insert")) return;
                const a = o.toViewPosition(t.createPositionBefore(n.item));
                s.insert(a, s.createText("\n"));
              };
            })(n),
            { priority: "high" }
          ),
          t.data.upcastDispatcher.on(
            "element:code",
            (function (t, e) {
              const n = c(e, "class", "language"),
                i = e[0].language;
              return (t, e, s) => {
                const o = e.viewItem,
                  r = o.parent;
                if (!r || !r.is("element", "pre")) return;
                if (e.modelCursor.findAncestor("codeBlock")) return;
                const { consumable: a, writer: c } = s;
                if (!a.test(o, { name: !0 })) return;
                const l = c.createElement("codeBlock"),
                  u = [...o.getClassNames()];
                u.length || u.push("");
                for (const t of u) {
                  const e = n[t];
                  if (e) {
                    c.setAttribute("language", e, l);
                    break;
                  }
                }
                l.hasAttribute("language") || c.setAttribute("language", i, l),
                  s.convertChildren(o, l),
                  s.safeInsert(l, e.modelCursor) &&
                    (a.consume(o, { name: !0 }),
                    s.updateConversionResult(l, e));
              };
            })(0, i)
          ),
          t.data.upcastDispatcher.on(
            "text",
            (t, e, { consumable: n, writer: i }) => {
              let s = e.modelCursor;
              if (!n.test(e.viewItem)) return;
              if (!s.findAncestor("codeBlock")) return;
              n.consume(e.viewItem);
              const o = e.viewItem.data.split("\n").map((t) => i.createText(t)),
                r = o[o.length - 1];
              for (const t of o)
                if (
                  (i.insert(t, s), (s = s.getShiftedBy(t.offsetSize)), t !== r)
                ) {
                  const t = i.createElement("softBreak");
                  i.insert(t, s), (s = i.createPositionAfter(t));
                }
              (e.modelRange = i.createRange(e.modelCursor, s)),
                (e.modelCursor = s);
            }
          ),
          this.listenTo(t.editing.view.document, "clipboardInput", (e, i) => {
            let s = n.createRange(n.document.selection.anchor);
            if (
              (i.targetRanges &&
                (s = t.editing.mapper.toModelRange(i.targetRanges[0])),
              !s.start.parent.is("element", "codeBlock"))
            )
              return;
            const r = i.dataTransfer.getData("text/plain"),
              a = new o.q(t.editing.view.document);
            i.content = (function (t, e) {
              const n = t.createDocumentFragment(),
                i = e.split("\n"),
                s = i.reduce(
                  (e, n, s) => (
                    e.push(n),
                    s < i.length - 1 && e.push(t.createElement("br")),
                    e
                  ),
                  []
                );
              return t.appendChild(s, n), n;
            })(a, r);
          }),
          this.listenTo(n, "getSelectedContent", (t, [i]) => {
            const s = i.anchor;
            !i.isCollapsed &&
              s.parent.is("element", "codeBlock") &&
              s.hasSameParentAs(i.focus) &&
              n.change((n) => {
                const o = t.return;
                if (o.childCount > 1 || i.containsEntireContent(s.parent)) {
                  const e = n.createElement(
                    "codeBlock",
                    s.parent.getAttributes()
                  );
                  n.append(o, e);
                  const i = n.createDocumentFragment();
                  n.append(e, i), (t.return = i);
                } else {
                  const t = o.getChild(0);
                  e.checkAttribute(t, "code") && n.setAttribute("code", !0, t);
                }
              });
          });
      }
      afterInit() {
        const t = this.editor,
          e = t.commands,
          n = e.get("indent"),
          i = e.get("outdent");
        n && n.registerChildCommand(e.get("indentCodeBlock")),
          i && i.registerChildCommand(e.get("outdentCodeBlock")),
          this.listenTo(
            t.editing.view.document,
            "enter",
            (e, n) => {
              t.model.document.selection
                .getLastPosition()
                .parent.is("element", "codeBlock") &&
                ((function (t, e) {
                  const n = t.model.document,
                    i = t.editing.view,
                    s = n.selection.getLastPosition(),
                    o = s.nodeAfter;
                  if (e || !n.selection.isCollapsed || !s.isAtStart) return !1;
                  if (!_(o)) return !1;
                  return (
                    t.model.change((e) => {
                      t.execute("enter");
                      const i = n.selection.anchor.parent.previousSibling;
                      e.rename(i, "paragraph"),
                        e.setSelection(i, "in"),
                        t.model.schema.removeDisallowedAttributes([i], e),
                        e.remove(o);
                    }),
                    i.scrollToTheSelection(),
                    !0
                  );
                })(t, n.isSoft) ||
                  (function (t, e) {
                    const n = t.model,
                      i = n.document,
                      s = t.editing.view,
                      o = i.selection.getLastPosition(),
                      r = o.nodeBefore;
                    let a;
                    if (
                      e ||
                      !i.selection.isCollapsed ||
                      !o.isAtEnd ||
                      !r ||
                      !r.previousSibling
                    )
                      return !1;
                    if (_(r) && _(r.previousSibling))
                      a = n.createRange(
                        n.createPositionBefore(r.previousSibling),
                        n.createPositionAfter(r)
                      );
                    else if (
                      v(r) &&
                      _(r.previousSibling) &&
                      _(r.previousSibling.previousSibling)
                    )
                      a = n.createRange(
                        n.createPositionBefore(
                          r.previousSibling.previousSibling
                        ),
                        n.createPositionAfter(r)
                      );
                    else {
                      if (
                        !(
                          v(r) &&
                          _(r.previousSibling) &&
                          v(r.previousSibling.previousSibling) &&
                          _(r.previousSibling.previousSibling.previousSibling)
                        )
                      )
                        return !1;
                      a = n.createRange(
                        n.createPositionBefore(
                          r.previousSibling.previousSibling.previousSibling
                        ),
                        n.createPositionAfter(r)
                      );
                    }
                    return (
                      t.model.change((e) => {
                        e.remove(a), t.execute("enter");
                        const n = i.selection.anchor.parent;
                        e.rename(n, "paragraph"),
                          t.model.schema.removeDisallowedAttributes([n], e);
                      }),
                      s.scrollToTheSelection(),
                      !0
                    );
                  })(t, n.isSoft) ||
                  (function (t) {
                    const e = t.model.document,
                      n = e.selection.getLastPosition(),
                      i = n.nodeBefore || n.textNode;
                    let s;
                    i && i.is("$text") && (s = l(i));
                    t.model.change((n) => {
                      t.execute("shiftEnter"),
                        s && n.insertText(s, e.selection.anchor);
                    });
                  })(t),
                n.preventDefault(),
                e.stop());
            },
            { context: "pre" }
          );
      }
    }
    function v(t) {
      return t && t.is("$text") && !t.data.match(/\S/);
    }
    function _(t) {
      return t && t.is("element", "softBreak");
    }
    var y = n(4);
    n(448);
    class k extends i.j {
      static get pluginName() {
        return "CodeBlockUI";
      }
      init() {
        const t = this.editor,
          e = t.t,
          n = t.ui.componentFactory,
          i = a(t);
        n.add("codeBlock", (n) => {
          const s = t.commands.get("codeBlock"),
            o = Object(y.I)(n, y.w),
            r = o.buttonView;
          return (
            r.set({
              label: e("Insert code block"),
              tooltip: !0,
              icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.87 12.61a.75.75 0 0 1-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 0 1 .237.95l-.057.095a.75.75 0 0 1-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 0 1 1.047.174zm2.795-.231.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 0 1-.88-.151l-.07-.086-.058-.095a.75.75 0 0 1 .15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 0 1 .862-1.207zM16 0a2 2 0 0 1 2 2v9.354l-.663-.492-.837-.001V2a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3.118L7.156 19H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h14zM5.009 15l.003 1H3v-1h2.009zm2.188-2-1.471 1H5v-1h2.197zM10 11v.095L8.668 12H7v-1h3zm4-2v1H7V9h7zm0-2v1H7V7h7zm-4-2v1H5V5h5zM6 3v1H3V3h3z"/></svg>',
              isToggleable: !0,
            }),
            r.bind("isOn").to(s, "value", (t) => !!t),
            r.on("execute", () => {
              t.execute("codeBlock", { usePreviousLanguageChoice: !0 }),
                t.editing.view.focus();
            }),
            o.on("execute", (e) => {
              t.execute("codeBlock", {
                language: e.source._codeBlockLanguage,
                forceValue: !0,
              }),
                t.editing.view.focus();
            }),
            (o.class = "ck-code-block-dropdown"),
            o.bind("isEnabled").to(s),
            Object(y.F)(o, this._getLanguageListItemDefinitions(i)),
            o
          );
        });
      }
      _getLanguageListItemDefinitions(t) {
        const e = this.editor.commands.get("codeBlock"),
          n = new r.b();
        for (const i of t) {
          const t = {
            type: "button",
            model: new y.u({
              _codeBlockLanguage: i.language,
              label: i.label,
              withText: !0,
            }),
          };
          t.model
            .bind("isOn")
            .to(e, "value", (e) => e === t.model._codeBlockLanguage),
            n.add(t);
        }
        return n;
      }
    }
    class A extends i.j {
      static get requires() {
        return [w, k];
      }
      static get pluginName() {
        return "CodeBlock";
      }
    }
  },
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  function (t, e, n) {},
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  function (t, e, n) {
    "use strict";
    n.d(e, "a", function () {
      return h;
    });
    var i = n(1),
      s = n(19),
      o = n(4),
      r = n(2);
    class a extends i.a {
      refresh() {
        const t = this.editor.model,
          e = t.schema,
          n = t.document.selection,
          i = c(n);
        (this.isEnabled = (function (t, e, n) {
          const i = (function (t, e) {
            const n = Object(s.d)(t, e).start.parent;
            if (n.isEmpty && !n.is("element", "$root")) return n.parent;
            return n;
          })(t, n);
          return e.checkChild(i, "rawHtml");
        })(n, e, t)),
          (this.value = i ? i.getAttribute("value") || "" : null);
      }
      execute(t) {
        const e = this.editor.model,
          n = e.document.selection;
        e.change((i) => {
          let s;
          null !== this.value
            ? (s = c(n))
            : ((s = i.createElement("rawHtml")),
              e.insertContent(s),
              i.setSelection(s, "on")),
            i.setAttribute("value", t, s);
        });
      }
    }
    function c(t) {
      const e = t.getSelectedElement();
      return e && e.is("element", "rawHtml") ? e : null;
    }
    n(724);
    class l extends i.j {
      static get pluginName() {
        return "HtmlEmbedEditing";
      }
      constructor(t) {
        super(t),
          t.config.define("htmlEmbed", {
            showPreviews: !1,
            sanitizeHtml: (t) => (
              Object(r.u)("html-embed-provide-sanitize-function"),
              { html: t, hasChanged: !1 }
            ),
          }),
          (this._widgetButtonViewReferences = new Set());
      }
      init() {
        const t = this.editor;
        t.model.schema.register("rawHtml", {
          isObject: !0,
          allowWhere: "$block",
          allowAttributes: ["value"],
        }),
          t.commands.add("htmlEmbed", new a(t)),
          this._setupConversion();
      }
      _setupConversion() {
        const t = this.editor,
          e = t.t,
          n = t.editing.view,
          i = this._widgetButtonViewReferences,
          o = t.config.get("htmlEmbed");
        function a({ domElement: t, editor: n, state: s, props: o }) {
          t.textContent = "";
          const a = t.ownerDocument;
          let l;
          if (s.isEditable) {
            const e = { isDisabled: !1, placeholder: o.textareaPlaceholder };
            (l = c({ domDocument: a, state: s, props: e })), t.append(l);
          } else if (s.showPreviews) {
            const i = { sanitizeHtml: o.sanitizeHtml };
            t.append(
              (function ({ domDocument: t, state: n, props: i, editor: s }) {
                const o = i.sanitizeHtml(n.getRawHtmlValue()),
                  a =
                    n.getRawHtmlValue().length > 0
                      ? e("No preview available")
                      : e("Empty snippet content"),
                  c = Object(r.k)(
                    t,
                    "div",
                    {
                      class:
                        "ck ck-reset_all raw-html-embed__preview-placeholder",
                    },
                    a
                  ),
                  l = Object(r.k)(t, "div", {
                    class: "raw-html-embed__preview-content",
                    dir: s.locale.contentLanguageDirection,
                  }),
                  u = t.createRange().createContextualFragment(o.html);
                l.appendChild(u);
                return Object(r.k)(
                  t,
                  "div",
                  { class: "raw-html-embed__preview" },
                  [c, l]
                );
              })({ domDocument: a, state: s, props: i, editor: n })
            );
          } else {
            const e = { isDisabled: !0, placeholder: o.textareaPlaceholder };
            t.append(c({ domDocument: a, state: s, props: e }));
          }
          const d = {
            onEditClick: o.onEditClick,
            onSaveClick: () => {
              o.onSaveClick(l.value);
            },
            onCancelClick: o.onCancelClick,
          };
          t.prepend(
            (function ({ editor: t, domDocument: e, state: n, props: s }) {
              const o = Object(r.k)(e, "div", {
                class: "raw-html-embed__buttons-wrapper",
              });
              if (n.isEditable) {
                const e = u(t, "save", s.onSaveClick),
                  n = u(t, "cancel", s.onCancelClick);
                o.append(e.element, n.element), i.add(e).add(n);
              } else {
                const e = u(t, "edit", s.onEditClick);
                o.append(e.element), i.add(e);
              }
              return o;
            })({ editor: n, domDocument: a, state: s, props: d })
          );
        }
        function c({ domDocument: t, state: e, props: n }) {
          const i = Object(r.k)(t, "textarea", {
            placeholder: n.placeholder,
            class: "ck ck-reset ck-input ck-input-text raw-html-embed__source",
          });
          return (
            (i.disabled = n.isDisabled), (i.value = e.getRawHtmlValue()), i
          );
        }
        this.editor.editing.view.on(
          "render",
          () => {
            for (const t of i) {
              if (t.element.isConnected) return;
              t.destroy(), i.delete(t);
            }
          },
          { priority: "lowest" }
        ),
          t.data.registerRawContentMatcher({
            name: "div",
            classes: "raw-html-embed",
          }),
          t.conversion.for("upcast").elementToElement({
            view: { name: "div", classes: "raw-html-embed" },
            model: (t, { writer: e }) =>
              e.createElement("rawHtml", {
                value: t.getCustomProperty("$rawContent"),
              }),
          }),
          t.conversion.for("dataDowncast").elementToElement({
            model: "rawHtml",
            view: (t, { writer: e }) =>
              e.createRawElement(
                "div",
                { class: "raw-html-embed" },
                function (e) {
                  e.innerHTML = t.getAttribute("value") || "";
                }
              ),
          }),
          t.conversion.for("editingDowncast").elementToElement({
            triggerBy: { attributes: ["value"] },
            model: "rawHtml",
            view: (i, { writer: r }) => {
              let c, l, u;
              const d = r.createContainerElement("div", {
                  class: "raw-html-embed",
                  "data-html-embed-label": e("HTML snippet"),
                  dir: t.locale.uiLanguageDirection,
                }),
                h = r.createRawElement(
                  "div",
                  { class: "raw-html-embed__content-wrapper" },
                  function (e) {
                    (c = e),
                      a({ domElement: e, editor: t, state: l, props: u }),
                      c.addEventListener(
                        "mousedown",
                        () => {
                          if (l.isEditable) {
                            const e = t.model;
                            e.document.selection.getSelectedElement() !== i &&
                              e.change((t) => t.setSelection(i, "on"));
                          }
                        },
                        !0
                      );
                  }
                ),
                f = {
                  makeEditable() {
                    (l = Object.assign({}, l, { isEditable: !0 })),
                      a({ domElement: c, editor: t, state: l, props: u }),
                      n.change((t) => {
                        t.setAttribute("data-cke-ignore-events", "true", h);
                      }),
                      c.querySelector("textarea").focus();
                  },
                  save(e) {
                    e !== l.getRawHtmlValue()
                      ? (t.execute("htmlEmbed", e), t.editing.view.focus())
                      : this.cancel();
                  },
                  cancel() {
                    (l = Object.assign({}, l, { isEditable: !1 })),
                      a({ domElement: c, editor: t, state: l, props: u }),
                      t.editing.view.focus(),
                      n.change((t) => {
                        t.removeAttribute("data-cke-ignore-events", h);
                      });
                  },
                };
              return (
                (l = {
                  showPreviews: o.showPreviews,
                  isEditable: !1,
                  getRawHtmlValue: () => i.getAttribute("value") || "",
                }),
                (u = {
                  sanitizeHtml: o.sanitizeHtml,
                  textareaPlaceholder: e("Paste raw HTML here..."),
                  onEditClick() {
                    f.makeEditable();
                  },
                  onSaveClick(t) {
                    f.save(t);
                  },
                  onCancelClick() {
                    f.cancel();
                  },
                }),
                r.insert(r.createPositionAt(d, 0), h),
                r.setCustomProperty("rawHtmlApi", f, d),
                r.setCustomProperty("rawHtml", !0, d),
                Object(s.g)(d, r, {
                  widgetLabel: e("HTML snippet"),
                  hasSelectionHandle: !0,
                })
              );
            },
          });
      }
    }
    function u(t, e, n) {
      const s = t.locale.t,
        r = new o.e(t.locale),
        a = t.commands.get("htmlEmbed");
      return (
        r.set({
          class: `raw-html-embed__${e}-button`,
          icon: i.l.pencil,
          tooltip: !0,
          tooltipPosition: "rtl" === t.locale.uiLanguageDirection ? "e" : "w",
        }),
        r.render(),
        "edit" === e
          ? (r.set({ icon: i.l.pencil, label: s("Edit source") }),
            r.bind("isEnabled").to(a))
          : "save" === e
          ? (r.set({ icon: i.l.check, label: s("Save changes") }),
            r.bind("isEnabled").to(a))
          : r.set({ icon: i.l.cancel, label: s("Cancel") }),
        r.on("execute", n),
        r
      );
    }
    class d extends i.j {
      static get pluginName() {
        return "HtmlEmbedUI";
      }
      init() {
        const t = this.editor,
          e = t.t;
        t.ui.componentFactory.add("htmlEmbed", (n) => {
          const i = t.commands.get("htmlEmbed"),
            s = new o.e(n);
          return (
            s.set({
              label: e("Insert HTML"),
              icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17 0a2 2 0 0 1 2 2v7a1 1 0 0 1 1 1v5a1 1 0 0 1-.883.993l-.118.006L19 17a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2l-.001-1.001-.116-.006A1 1 0 0 1 0 15v-5a1 1 0 0 1 .999-1L1 2a2 2 0 0 1 2-2h14zm.499 15.999h-15L2.5 17a.5.5 0 0 0 .5.5h14a.5.5 0 0 0 .5-.5l-.001-1.001zm-3.478-6.013-.014.014H14v.007l-1.525 1.525-1.46-1.46-.015.013V10h-1v5h1v-3.53l1.428 1.43.048.043.131-.129L14 11.421V15h1v-5h-.965l-.014-.014zM2 10H1v5h1v-2h2v2h1v-5H4v2H2v-2zm7 0H6v1h1v4h1v-4h1v-1zm8 0h-1v5h3v-1h-2v-4zm0-8.5H3a.5.5 0 0 0-.5.5l-.001 6.999h15L17.5 2a.5.5 0 0 0-.5-.5zM10 7v1H4V7h6zm3-2v1H4V5h9zm-3-2v1H4V3h6z"/></svg>',
              tooltip: !0,
            }),
            s.bind("isEnabled").to(i, "isEnabled"),
            this.listenTo(s, "execute", () => {
              t.execute("htmlEmbed"), t.editing.view.focus();
              t.editing.view.document.selection
                .getSelectedElement()
                .getCustomProperty("rawHtmlApi")
                .makeEditable();
            }),
            s
          );
        });
      }
    }
    class h extends i.j {
      static get requires() {
        return [l, d, s.a];
      }
      static get pluginName() {
        return "HtmlEmbed";
      }
    }
  },
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  function (t, e, n) {},
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  ,
  function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(262),
      s = n(245),
      o = n(707),
      r = n(429);
    i.a.builtinPlugins.push(o.a), i.a.builtinPlugins.push(r.a);
    i.a
      .create(document.querySelector("#snippet-html-embed"), {
        initialData: "",
        toolbar: {
          items: [
            "heading",
            "|",
            "bold",
            "italic",
            "bulletedList",
            "numberedList",
            "|",
            "htmlEmbed",
            "codeBlock",
            "blockQuote",
            "link",
            "uploadImage",
            "mediaEmbed",
            "insertTable",
            "|",
            "outdent",
            "indent",
            "|",
            "undo",
            "redo",
          ],
        },
        ui: { viewportOffset: { top: window.getViewportTopOffsetConfig() } },
        image: {
          toolbar: [
            "imageStyle:inline",
            "imageStyle:wrapText",
            "imageStyle:breakText",
            "|",
            "toggleImageCaption",
            "imageTextAlternative",
          ],
        },
        table: {
          contentToolbar: ["tableColumn", "tableRow", "mergeTableCells"],
        },
        cloudServices: s.a,
      })
      .then((t) => {
        (window.editor = t),
        editorInt = function () { 
          return t;
          },
            seteditor = function (params) {
            t.data.set(params);
          };
        //     ,
        //   window.attachTourBalloon({
        //     target: window.findToolbarItem(
        //       t.ui.view.toolbar,
        //       (t) => t.label && "Insert HTML" === t.label
        //     ),
        //     text: "Click to embed a new HTML snippet.",
        //     editor: t,
        //   });
      })
      .catch((t) => {
        console.error(t.stack);
      });
  },
]);
